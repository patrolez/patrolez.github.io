<!DOCTYPE html>
<html lang="en">
<head>

<base href="../..">

<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">


<title>Gapless and instant URI switching in playback elements
</title>

<link rel="stylesheet" href="assets/css/dark-frontend.css" type="text/css" title="dark">
<link rel="alternate stylesheet" href="assets/css/light-frontend.css" type="text/css" title="light">
<link rel="stylesheet" href="assets/css/bootstrap-toc.min.css" type="text/css">
<link rel="stylesheet" href="assets/css/jquery.mCustomScrollbar.min.css">
<link rel="stylesheet" href="assets/js/search/enable_search.css" type="text/css">

<link rel="stylesheet" href="assets/css/extra_frontend.css" type="text/css">
<link rel="stylesheet" href="assets/css/devhelp.css" type="text/css">

<link rel="stylesheet" href="assets/css/prism-tomorrow.css" type="text/css" title="dark">

<link rel="alternate stylesheet" href="assets/css/prism.css" type="text/css" title="light">

<script src="assets/js/mustache.min.js"></script>
<script src="assets/js/jquery.js"></script>
<script src="assets/js/bootstrap.js"></script>
<script src="assets/js/scrollspy.js"></script>
<script src="assets/js/typeahead.jquery.min.js"></script>
<script src="assets/js/search.js"></script>
<script src="assets/js/compare-versions.js"></script>
<script src="assets/js/jquery.mCustomScrollbar.concat.min.js"></script>
<script src="assets/js/bootstrap-toc.min.js"></script>
<script src="assets/js/jquery.touchSwipe.min.js"></script>
<script src="assets/js/anchor.min.js"></script>
<script src="assets/js/tag_filtering.js"></script>
<script src="assets/js/language_switching.js"></script>
<script src="assets/js/styleswitcher.js"></script>

<script src="assets/js/lines_around_headings.js"></script>

<script src="assets/js/prism-core.js"></script>
<script src="assets/js/prism-autoloader.js"></script>
<script src="assets/js/prism_autoloader_path_override.js"></script>
<script src="assets/js/trie.js"></script>

<!-- generic -->
<link rel="icon" type="image/png" href="assets/images/favicon-16.png" sizes="16x16">
<link rel="icon" type="image/png" href="assets/images/favicon-32.png" sizes="32x32">
<link rel="icon" type="image/png" href="assets/images/favicon-57.png" sizes="57x57">
<link rel="icon" type="image/png" href="assets/images/favicon-64.png" sizes="64x64">
<link rel="icon" type="image/png" href="assets/images/favicon-76.png" sizes="76x76">
<link rel="icon" type="image/png" href="assets/images/favicon-96.png" sizes="96x96">
<link rel="icon" type="image/png" href="assets/images/favicon-128.png" sizes="128x128">
<link rel="icon" type="image/png" href="assets/images/favicon-192.png" sizes="192x192">
<link rel="icon" type="image/png" href="assets/images/favicon-228.png" sizes="228x228">

<!-- Android -->
<link rel="shortcut icon" sizes="196x196" href="assets/images/favicon-196.png">

<!-- iOS -->
<link rel="apple-touch-icon" href="assets/images/favicon-120.png" sizes="120x120">
<link rel="apple-touch-icon" href="assets/images/favicon-152.png" sizes="152x152">
<link rel="apple-touch-icon" href="assets/images/favicon-180.png" sizes="180x180">

</head>

<body class="no-script
">

<script>
$('body').removeClass('no-script');
</script>

<nav class="navbar navbar-fixed-top navbar-default" id="topnav">
	<div class="container-fluid">
		<div class="navbar-right">
			<a id="toc-toggle">
				<span class="glyphicon glyphicon-menu-right"></span>
				<span class="glyphicon glyphicon-menu-left"></span>
			</a>
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-wrapper" aria-expanded="false">
				<span class="sr-only">Toggle navigation</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<span title="light mode switch" class="glyphicon glyphicon-sunglasses pull-right" id="lightmode-icon"></span>
			<form class="navbar-form pull-right" id="navbar-search-form">
                               <div class="form-group has-feedback">
                                       <input type="text" class="form-control input-sm" name="search" id="sidenav-lookup-field" placeholder="search" disabled>
				       <span class="glyphicon glyphicon-search form-control-feedback" id="search-mgn-glass"></span>
                               </div>
                        </form>
		</div>
		<div class="navbar-header">
			<a id="sidenav-toggle">
				<span class="glyphicon glyphicon-menu-right"></span>
				<span class="glyphicon glyphicon-menu-left"></span>
			</a>
			<a id="home-link" href="index.html" class="hotdoc-navbar-brand">
				<img src="assets/images/gstreamer-logo.svg" alt="Home">
			</a>
		</div>
		<div class="navbar-collapse collapse" id="navbar-wrapper">
			<ul class="nav navbar-nav" id="menu">
				
<li class="dropdown">
    <a class="dropdown-toggle" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
        API References<span class="caret"></span>
    </a>
	<ul class="dropdown-menu" id="modules-menu">
					<li>
				<a href="gstreamer/gi-index.html">GStreamer core</a>
			</li>
					<li>
				<a href="libs.html">GStreamer Libraries</a>
			</li>
					<li>
				<a href="plugins_doc.html">GStreamer Plugins</a>
			</li>
		</ul>
</li>

<li>
    <a href="application-development/index.html">Application manual</a>
</li>


<li>
    <a href="tutorials/index.html">Tutorials</a>
</li>

			</ul>
			<div class="hidden-xs hidden-sm navbar-text navbar-center">
							</div>
		</div>
	</div>
</nav>

<main>
<div data-extension="gi-extension" data-hotdoc-in-toplevel="True" data-hotdoc-project="GStreamer" data-hotdoc-ref="additional/design/playback-gapless.html" class="page_container" id="page-wrapper" data-hotdoc-meta-gi-languages="['c', 'javascript', 'python']" data-hotdoc-meta-gi-language="c">
<script src="assets/js/utils.js"></script>

<div class="panel panel-collapse oc-collapsed" id="sidenav" data-hotdoc-role="navigation">
	<script src="assets/js/full-width.js"></script>
  <div id="sitenav-wrapper">
    <iframe src="hotdoc-sitemap.html" id="sitenav-frame"></iframe>
  </div>
</div>

<div id="body">
	<div id="main">
				    <div id="page-description" data-hotdoc-role="main">
        <h1 id="gapless-and-instant-uri-switching-in-playback-elements">Gapless and instant URI switching in playback elements</h1>
<p>This document explains the various changes and improvements to the playback
elements in order to support gapless playback and instantaneous URI switching.</p>
<p>Last Update: November 23rd 2022</p>
<h1 id="background">Background</h1>
<p>The new <code>playbin3</code> element and its components (<code>uridecodebin3</code>, <code>decodebin3</code> and
<code>urisourcebin</code>) are replacements to the legacy <code>playbin2</code> and <code>decodebin2</code>
elements.</p>
<p>The goals of these new elements are to both allow new use-cases and improve
performance (lower memory/cpu/io usage, lower latency). One of the key
principles is also to re-use elements as much as possible. For example, when
switching audio tracks the decoder can be re-used (if compatible).</p>
<p>The separation of roles was also more clearly split up into various new elements
(from lowest-level to highest-level):</p>
<ul>
<li>
<p><code>urisourcebin</code> handles choosing the right source elements for the given URI,
and handles buffering (via <code>queue2</code>) if needed (for network sources for example).</p>
</li>
<li>
<p><code>parsebin</code> takes an input stream and figures out which demuxer, parsers and/or
payloaders are needed to provide timed elementary streams.</p>
</li>
<li>
<p><code>decodebin3</code> internally uses <code>parsebin</code> to handle any input stream and will
handle the decoding, inter-stream muxing interleave, stream selection and
switching. It can also handle multiple inputs (such as an audio/video file and
a separate subtitle file).</p>
</li>
<li>
<p><code>uridecodebin3</code> wraps <code>urisourcebin</code>s and <code>decodebin3</code> for any use-cases where
one wishes to have decoded streams from given URIs.</p>
</li>
<li>
<p>Finally <code>playbin3</code> combines <code>uridecodebin3</code> and <code>playsink</code> for providing a
high-level convenience pipeline for playing back content.</p>
</li>
</ul>
<p>This design has received many improvements over time:</p>
<ul>
<li>
<p><code>decodebin3</code> was able to detect input changes (caps changes) and reconfigure
the associated <code>parsebin</code> if incompatible. This allows use-cases where
upstream is an HLS/DASH stream where codecs are different across bitrates. The
playback remains seamless if the decoders are compatible.</p>
</li>
<li>
<p><code>decodebin3</code> was able to bypass the usage of <code>parsebin</code> altogether if the
incoming stream is pull-based, provides a <code>GstStreamCollection</code> and is
compatible with the decoders or output caps.</p>
</li>
<li>
<p><code>urisourcebin</code> can handle sources that handle buffering internally, avoiding
dual-buffering.</p>
</li>
<li>
<p>A new core query <code>GST_QUERY_SELECTABLE</code> was added so that (source) elements
could notify <code>decodebin3</code> that they can handle stream selection and switching
themselves.</p>
</li>
<li>
<p>Several improvements were made to <code>playbin3</code> to allow complete stream type
changes (such as going from playing audio+video to just audio or just video,
and back), This allows temporarily disabling whole chains of elements when not
needed.</p>
</li>
</ul>
<h1 id="limitationissue">Limitation/Issue</h1>
<p>Two limitations existed though, which are both related:</p>
<ul>
<li>
<p>Changing URI required bringing <code>playbin3</code> (and all contained elements) down to
<code>GST_STATE_READY</code>, setting the uri, and then bringing all elements back to
<code>GST_STATE_PAUSED</code>.</p>
<ul>
<li>This meant that all elements contained within were either discarded
(decoders, demuxers, parsers, sources, ...) or reset (sinks)... despite
potentially being 100% compatible (ex: going from h264/aac to h264/aac).</li>
</ul>
</li>
<li>
<p>Gapless playback (i.e. automatically switching from one source to another, and
removing any potential gap in the data arriving to the sinks) was implemented by
pre-rolling a full <code>uridecodebin3</code> for the next item to play and switching the
inputs to <code>playsink</code> when the original <code>uridecodebin3</code> was EOS.</p>
<ul>
<li>This meant that none of the existing elements (demuxers, parsers, decoders,
..) contained in the original <code>uridecodebin3</code> were re-used.</li>
</ul>
</li>
</ul>
<p>Those two use-cases are the same thing: We want to change the URI
(i.e. <code>urisourcebin</code>) but re-use as much as possible of existing elements
(i.e. <code>decodebin3</code> and <code>playsink</code>). The only difference between the two
use-cases is that changing URI should happen instantaneously in the first case,
whereas in the second case it happens when the initial source is done (EOS).</p>
<p>Fixing this will allow:</p>
<ul>
<li>
<p>Reducing memory and cpu usage (no duplicate elements)</p>
</li>
<li>
<p>Lowering latency (no longer re-instantiate/reconfigure elements and re-use
compatible ones as fast as possible).</p>
</li>
</ul>
<p>Another issue which is related, is figuring out the <em>optimal</em> time at which the
next item should be prepared so that it has enough data to playback immediately:</p>
<ul>
<li>This shouldn't be too early, some URIs expire after a given time, or the user
might change their mind in between</li>
<li>This shouldn't be too late, otherwise we risk not having enough data to
playback seamlessly.</li>
</ul>
<h1 id="changes">Changes</h1>
<h2 id="parsebin-in-urisourcebin">parsebin in urisourcebin</h2>
<p>In order to figure out the <em>optimal</em> time at which a switch should happen
(i.e. a given amount of "time" before the end of the previous play entry), this
can only be done on "timed" data (i.e. parsed elementary streams).</p>
<p>There is therefore a new option on <code>urisourcebin</code> : <code>parse-streams</code>, which if
set to <code>TRUE</code> (non-default) will add a <code>parsebin</code> (if and where needed) so that
<code>urisourcebin</code> only outputs elementary streams. A <code>multiqueue</code> will also be
present to handle any interleave present (i.e. only queue up what is needed to
offer coherent streams downstream).</p>
<p>If buffering is activated on <code>urisourcebin</code>, the <code>multiqueue</code> present after the
<code>parsebin</code> will be configured in order to handle it (and post the appropriate
buffering messages).</p>
<p>This offers the following benefits:</p>
<ul>
<li>
<p><code>about-to-finish</code> can be emitted by <code>urisourcebin</code> as soon as <code>EOS</code> enters
those <code>multiqueue</code>, which will be more precise than the previous usage (before
<code>queue2</code> on non-timed data)</p>
</li>
<li>
<p>buffering is much closer to the actual buffering amount (in time) which is
specified on the properties.</p>
</li>
<li>
<p><em>ALL</em> scheduling downstream of <code>urisourcebin</code> is push-based, removing a lot of
issues when trying to change scheduling modes (push vs pull) dynamically.</p>
</li>
</ul>
<p>The <code>parse-streams</code> property is set to <code>TRUE</code> when used in <code>uridecodebin3</code></p>
<h2 id="only-use-a-single-uridecodebin3-in-playbin3">Only use a single uridecodebin3 in playbin3</h2>
<p>Only a single <code>uridecodebin3</code> is in use in <code>playbin3</code> and the source pads it
provides are directly linked to <code>playsink</code>.</p>
<p>There can only be at most one stream of each stream type (audio, video, text) on
the output side of <code>uridecodebin3</code>. The exception to this is if the user/application
configured a specific multi-sinkpad combiner element for a given stream type,
in which case all streams of that given stream type are linked to that.</p>
<p>All uri-related properties are forwarded directly to <code>uridecodebin3</code>, which will
handle switching the sources to the single <code>decodebin3</code> it contains.</p>
<h2 id="uridecodebin3-uri-and-source-handling">uridecodebin3 URI and source handling</h2>
<p>The URI for a given entry are handled in a <code>GstPlayItem</code> structure which
controls (via intermediary structures):</p>
<ul>
<li>
<p>The <code>urisourcebin</code> associated with the specified URI (and optional subtitle
URI)</p>
</li>
<li>
<p>The pads provided by those sources, and which states they are in (eos,
blocked, ...) and the associated GstStream (if present)</p>
</li>
<li>
<p>The buffering messages posted by those sources.</p>
</li>
</ul>
<p>At any given point there is:</p>
<ul>
<li>
<p>A <code>input_play_item</code>, which is the play item currently feeding data into
<code>decodebin3</code></p>
</li>
<li>
<p>A <code>output_play_itm</code>, which is the play item currently being outputted by
<code>decodebin3</code></p>
</li>
</ul>
<p>Most of the time those two will be the same. But when switching play items
(going from one URI to another, whether gapless or not) this switch will happen
asynchronously.</p>
<h2 id="switching-inputs-to-decodebin3">Switching inputs to decodebin3</h2>
<p>The high-level goal is to add to <code>uridecodebin3</code> the capability of being able to
change <code>GstPlayItem</code> with the same <code>decodebin3</code> either:</p>
<ul>
<li>
<p>When the previous <code>GstPlayItem</code> has finished and there is a pending next
<code>GstPlayItem</code>. This is the "gapless" scenario.</p>
</li>
<li>
<p>Or immediately switch to the given <code>GstPlayItem</code> <em>without</em> having to change
state. This is the "instantaneous URI switch" scenario.</p>
</li>
</ul>
<p>For this, the following points need to be solved:</p>
<ol>
<li>both scenarios: Add a way for "next" <code>GstPlayItem</code> to be pre-rolled</li>
<li>gapless: Determining when the switch can happen</li>
<li>instant-uri: pre-roll next <code>GstPlayItem</code> and flush downstream (to make the
switch as quick as possile)</li>
<li>both scenarios: Do the actual switch</li>
</ol>
<h3 id="prerolling-play-items">pre-rolling play items</h3>
<p>In order to be able to re-use the same decoders (within <code>decodebin3</code>) as much as
possible from the outside, we need to ensure that we feed the ideal
"replacement" stream to the same <code>decodebin3</code> sink pad.</p>
<p>For example, if we are switching from an audio+video HLS source to another
audio+video DASH source, we want to make sure we link the new <code>urisourcebin</code>
source pad providing video to the <code>decodebin3</code> pad that was previously consuming
the old video stream.</p>
<p>In order to do this, the <code>urisourcebin</code> we wish to switch to needs to be
pre-rolled (set to PAUSED, new pads are set to be blocked, and we wait for a
buffer/GAP to arrive on at least one of the pads).</p>
<p>At that point we will know the streams which are present in the new and old
<code>urisourcebin</code>s and can unlink/relink compatible pads. If new sink pads are
required they will be requested, and if old pads are no longer needed (for
example switching from two streams to a single one) they will be removed.</p>
<blockquote>
<p>Note: Doing this also has the benefit that "replacing" the inputs to
<code>decodebin3</code> are done from a new streaming thread, and not the old
<code>urisourcebin</code> streaming thread which could cause deadlocks.</p>
</blockquote>
<blockquote>
<p>Note: This "waiting" is only done when "switching", i.e. on sources which
aren't in the current input play item. If the pads are from the current play
entry they are linked/unlinked as soon as they are added/removed.</p>
</blockquote>
<p>The moment at which the next play item is pre-rolled is done:</p>
<ul>
<li>
<p>When the current play item has posted <code>about-to-finish</code> and the
user/application has set a new play item.</p>
</li>
<li>
<p>When a new play item has been set and the <code>instant-uri</code> property has been set
to TRUE.</p>
</li>
</ul>
<p>When a play item is pre-rolled, it is marked as "active". There can only be one
"active" play item in addition to the input play item.</p>
<h3 id="gapless-determining-when-the-switch-can-happen">gapless: determining when the switch can happen</h3>
<p>For gapless use-cases, we want to know the earliest time we can switch from one
play item to another.</p>
<p>Since all streams coming from <code>urisourcebin parse-streams=True</code> are push-based,
this is when the last EOS has been pushed through all pads of the source.</p>
<h3 id="instantaneous-uri-switching">Instantaneous URI switching</h3>
<p>In order to be able to switch URI as soon as possible while re-using as many
existing elements as possible, there is a new <code>instant-uri</code> boolean property on
<code>uridecodebin3</code>/<code>playbin3</code>. The default value is FALSE.</p>
<p>If it is set to TRUE, the following happens whenever the <code>uri</code> property is set:</p>
<ul>
<li>
<p>On all pads of the current input play item:</p>
<ul>
<li>
<code>FLUSH_START</code> is sent to the downstream peer pads</li>
<li>The pad is made blocking</li>
<li>The pad is marked as EOS (i.e. as if EOS had been seen)</li>
</ul>
</li>
<li>
<p>And then again on all pads:</p>
<ul>
<li>
<code>FLUSH_STOP</code> is sent to the downstream peer pads</li>
</ul>
</li>
<li>
<p>Finally the new play item for the new URI is activated (pre-rolled).</p>
<ul>
<li>Once it is pre-rolled it will switch over</li>
</ul>
</li>
</ul>
<p>This ensures all downstream elements are kept and are ready to receive the new
data.</p>
<h3 id="switching-play-items">Switching play items</h3>
<p>Switching play items requires special attention since it needs to be done
"atomically". We need to ensure it is done by a single thread. This is done by
having a lock (<code>play_items_lock</code>) which is taken whenever we need to modify the
list of play items and which play item is the current input/output.</p>
<p>We need to ensure the streaming thread(s) that were previously used are
stopped. Since we are only dealing with push-based sources this is simple: we
wait for the moment EOS is pushed on the last pad of the play item.</p>
<p>Another important consideration is that we need to ensure the thread that does
the switch is not the previous streaming thread (it needs to be stopped).</p>
<p>In order to solve those issues, the actual replacement of the inputs will always
happen from the streaming thread of the <em>new</em> play item, i.e. the one we wish to
make the current input. This is done in a pad block probe on the new item source
pad. Whenever a buffer (or GAP event) is received, we check whether we can
switch:</p>
<ul>
<li>
<p>If the current input play item is completely EOS, the switch can happen
immediately. This will always be the case in instant-uri scenario and if the
current input play item is pull-based.</p>
</li>
<li>
<p>If the current input play item is not completely EOS, the probe waits on the
<code>GCond input_source_drained</code>. This is the case that will commonly happen in
gapless push-based scenarios, since we are waiting for the current input play
item to be finished.</p>
</li>
</ul>
<p>Once the switch can happen, we unlink all pads from <code>decodebin3</code> and attempt to
match compatible new source pads from <code>urisourcebin</code> to <code>decodebin3</code>. If new
sink pads are required they are requested, and if some sink pads are no longer
needed or do not match they are released.</p>
<p>Once all pads are linked, the new play item is set as the current play item.</p>
<h2 id="uridecodebin3-handles-abouttofinish-signalling">uridecodebin3 handles <code>about-to-finish</code> signalling</h2>
<p>In regards to gapless playback, the API does not change. Users are still
expected to listen to <code>about-to-finish</code> and set the next URI to play back.</p>
<p>One thing that needs to be taken care of is making sure we don't emit
<code>about-to-finish</code> for play items which aren't currently used. This would end up
in a situation where <code>about-to-finish</code> would cause a snowball effect of pending
play items emitting it, which would cause a future entry to be created,
prerolled and emitting it again.</p>
<p>For that reason, if a play item emits that signal but isn't the input or output
play item, then it is just stored and not propagated upstream. When that play
entry becomes the new input entry it will be propagated.</p>

    </div>
        




		
	</div>
	<div id="search_results">
		<p>The results of the search are</p>
	</div>
	<div id="footer">
		    

	</div>
</div>

<div id="toc-column">
	
		<div class="edit-button">
		<a href="https://gitlab.freedesktop.org/gstreamer/gst-docs//edit/master/subprojects/gst-docs/markdown/additional/design/playback-gapless.md" data-hotdoc-role="edit-button">Edit on GitLab</a>

	</div>
		<div id="toc-wrapper">
		<nav id="toc"></nav>
	</div>
</div>
</div>
</main>


<script src="assets/js/navbar_offset_scroller.js"></script>
</body>
</html>
