<!DOCTYPE html>
<html lang="en">
<head>

<base href="../..">

<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">


<title>Stream selection</title>

<link rel="stylesheet" href="assets/css/dark-frontend.css" type="text/css" title="dark">
<link rel="alternate stylesheet" href="assets/css/light-frontend.css" type="text/css" title="light">
<link rel="stylesheet" href="assets/css/bootstrap-toc.min.css" type="text/css">
<link rel="stylesheet" href="assets/css/jquery.mCustomScrollbar.min.css">
<link rel="stylesheet" href="assets/js/search/enable_search.css" type="text/css">

<link rel="stylesheet" href="assets/css/extra_frontend.css" type="text/css">
<link rel="stylesheet" href="assets/css/devhelp.css" type="text/css">

<link rel="stylesheet" href="assets/css/prism-tomorrow.css" type="text/css" title="dark">

<link rel="alternate stylesheet" href="assets/css/prism.css" type="text/css" title="light">

<script src="assets/js/mustache.min.js"></script>
<script src="assets/js/jquery.js"></script>
<script src="assets/js/bootstrap.js"></script>
<script src="assets/js/scrollspy.js"></script>
<script src="assets/js/typeahead.jquery.min.js"></script>
<script src="assets/js/search.js"></script>
<script src="assets/js/compare-versions.js"></script>
<script src="assets/js/jquery.mCustomScrollbar.concat.min.js"></script>
<script src="assets/js/bootstrap-toc.min.js"></script>
<script src="assets/js/jquery.touchSwipe.min.js"></script>
<script src="assets/js/anchor.min.js"></script>
<script src="assets/js/tag_filtering.js"></script>
<script src="assets/js/language_switching.js"></script>
<script src="assets/js/styleswitcher.js"></script>

<script src="assets/js/lines_around_headings.js"></script>

<script src="assets/js/prism-core.js"></script>
<script src="assets/js/prism-autoloader.js"></script>
<script src="assets/js/prism_autoloader_path_override.js"></script>
<script src="assets/js/trie.js"></script>

<!-- generic -->
<link rel="icon" type="image/png" href="assets/images/favicon-16.png" sizes="16x16">
<link rel="icon" type="image/png" href="assets/images/favicon-32.png" sizes="32x32">
<link rel="icon" type="image/png" href="assets/images/favicon-57.png" sizes="57x57">
<link rel="icon" type="image/png" href="assets/images/favicon-64.png" sizes="64x64">
<link rel="icon" type="image/png" href="assets/images/favicon-76.png" sizes="76x76">
<link rel="icon" type="image/png" href="assets/images/favicon-96.png" sizes="96x96">
<link rel="icon" type="image/png" href="assets/images/favicon-128.png" sizes="128x128">
<link rel="icon" type="image/png" href="assets/images/favicon-192.png" sizes="192x192">
<link rel="icon" type="image/png" href="assets/images/favicon-228.png" sizes="228x228">

<!-- Android -->
<link rel="shortcut icon" sizes="196x196" href="assets/images/favicon-196.png">

<!-- iOS -->
<link rel="apple-touch-icon" href="assets/images/favicon-120.png" sizes="120x120">
<link rel="apple-touch-icon" href="assets/images/favicon-152.png" sizes="152x152">
<link rel="apple-touch-icon" href="assets/images/favicon-180.png" sizes="180x180">

</head>

<body class="no-script
">

<script>
$('body').removeClass('no-script');
</script>

<nav class="navbar navbar-fixed-top navbar-default" id="topnav">
	<div class="container-fluid">
		<div class="navbar-right">
			<a id="toc-toggle">
				<span class="glyphicon glyphicon-menu-right"></span>
				<span class="glyphicon glyphicon-menu-left"></span>
			</a>
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-wrapper" aria-expanded="false">
				<span class="sr-only">Toggle navigation</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<span title="light mode switch" class="glyphicon glyphicon-sunglasses pull-right" id="lightmode-icon"></span>
			<form class="navbar-form pull-right" id="navbar-search-form">
                               <div class="form-group has-feedback">
                                       <input type="text" class="form-control input-sm" name="search" id="sidenav-lookup-field" placeholder="search" disabled>
				       <span class="glyphicon glyphicon-search form-control-feedback" id="search-mgn-glass"></span>
                               </div>
                        </form>
		</div>
		<div class="navbar-header">
			<a id="sidenav-toggle">
				<span class="glyphicon glyphicon-menu-right"></span>
				<span class="glyphicon glyphicon-menu-left"></span>
			</a>
			<a id="home-link" href="index.html" class="hotdoc-navbar-brand">
				<img src="assets/images/gstreamer-logo.svg" alt="Home">
			</a>
		</div>
		<div class="navbar-collapse collapse" id="navbar-wrapper">
			<ul class="nav navbar-nav" id="menu">
				
<li class="dropdown">
    <a class="dropdown-toggle" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
        API References<span class="caret"></span>
    </a>
	<ul class="dropdown-menu" id="modules-menu">
					<li>
				<a href="gstreamer/gi-index.html">GStreamer core</a>
			</li>
					<li>
				<a href="libs.html">GStreamer Libraries</a>
			</li>
					<li>
				<a href="plugins_doc.html">GStreamer Plugins</a>
			</li>
		</ul>
</li>

<li>
    <a href="application-development/index.html">Application manual</a>
</li>


<li>
    <a href="tutorials/index.html">Tutorials</a>
</li>

			</ul>
			<div class="hidden-xs hidden-sm navbar-text navbar-center">
							</div>
		</div>
	</div>
</nav>

<main>
<div data-extension="gi-extension" data-hotdoc-in-toplevel="True" data-hotdoc-project="GStreamer" data-hotdoc-ref="additional/design/stream-selection.html" class="page_container" id="page-wrapper" data-hotdoc-meta-gi-languages="['c', 'javascript', 'python']" data-hotdoc-meta-gi-language="c">
<script src="assets/js/utils.js"></script>

<div class="panel panel-collapse oc-collapsed" id="sidenav" data-hotdoc-role="navigation">
	<script src="assets/js/full-width.js"></script>
  <div id="sitenav-wrapper">
    <iframe src="hotdoc-sitemap.html" id="sitenav-frame"></iframe>
  </div>
</div>

<div id="body">
	<div id="main">
				    <div id="page-description" data-hotdoc-role="main">
        <h1 id="stream-selection">Stream selection</h1>
<p>This document describes the events and objects involved in stream selection in
GStreamer pipelines, elements and applications</p>
<h2 id="history-availability">History / Availability</h2>
<p>Since 1.10:</p>
<ul>
<li>
<code>GstStream</code> and <code>GstStreamCollection</code>
</li>
<li><code>enum GstStreamType</code></li>
<li>
<code>GST_EVENT_SELECT_STREAMS</code>, <code>GST_EVENT_STREAM_COLLECTION</code>,
<code>GST_MESSAGE_STREAMS_SELECTED</code>, <code>GST_MESSAGE_STREAM_COLLECTION</code>
</li>
<li>
<code>GstStream</code> present in <code>GST_EVENT_STREAM_START</code>
</li>
<li><code>GST_BIN_FLAG_STREAMS_AWARE</code></li>
</ul>
<p>Since 1.22:</p>
<ul>
<li><code>gst_query_new_selectable()</code></li>
<li><code>gst_query_set_selectable()</code></li>
<li><code>gst_query_parse_selectable()</code></li>
</ul>
<p>Initial version: June 2015 (Edward Hervey)</p>
<p>Last reviewed: March 2022 (Edward Hervey)</p>
<h2 id="background">Background</h2>
<p>This new API is <em>intended</em> to address the use cases described in this section:</p>
<ol>
<li>
<p>As a user/app I want an overview and control of the media streams that can be
configured within a pipeline for processing, even when some streams are
mutually exclusive or logical constructs only.</p>
</li>
<li>
<p>The user/app can disable entirely streams it's not interested in so they
don't occupy memory or processing power - discarded as early as possible in
the pipeline. The user/app can also (re-)enable them at a later time.</p>
</li>
<li>
<p>If the set of possible stream configurations is changing, the user/app should
be aware of the pending change and be able to make configuration choices for
the new set of streams, as well as possibly still reconfiguring the old set</p>
</li>
<li>
<p>Elements that have some other internal mechanism for triggering stream
selections (DVD, or maybe some scripted playback playlist) should be able to
trigger 'selection' of some particular stream.</p>
</li>
<li>
<p>Indicate known relationships between streams - for example that 2 separate
video feeds represent the 2 views of a stereoscopic view, or that certain
streams are mutually exclusive.</p>
</li>
</ol>
<blockquote>
<p>Note: the streams that are "available" are not automatically the ones active,
or present in the pipeline as pads. Think HLS/DASH alternate streams.</p>
</blockquote>
<h2 id="example-use-cases">Example use cases</h2>
<ol>
<li>
<p>Playing an MPEG-TS multi-program stream, we want to tell the app that there
are multiple programs that could be extracted from the incoming
feed.</p>
<p>Furthermore, we want to provide a mechanism for the app to select which
program(s) to decode, and once that is known to further tell the app which
elementary streams are then available within those program(s) so the app/user
can choose which audio track(s) to decode and/or use.</p>
</li>
<li>
<p>A new PMT arrives for an MPEG-TS stream, due to a codec or channel
change. The pipeline will need to reconfigure to play the desired streams
from new program. Equally, there may be multiple seconds of content buffered
from the old program and it should still be possible to switch (for example)
subtitle tracks responsively in the draining out data, as well as selecting
which subs track to play from the new feed.</p>
<p>This same scenario applies when doing gapless transition to a new source
file/URL, except that likely the element providing the list of streams also
changes as a new demuxer is installed.</p>
</li>
<li>
<p>When playing a multi-angle DVD, the DVD Virtual Machine needs to extract 1
angle from the data for presentation. It can publish the available angles as
logical streams, even though only one stream can be chosen.</p>
</li>
<li>
<p>When playing a DVD, the user can make stream selections from the DVD menu to
choose audio or sub-picture tracks, or the DVD VM can trigger automatic
selections.</p>
<p>In addition, the player UI should be able to show which audio/subtitle tracks
are available and allow direct selection in a GUI the same as for normal
files with subtitle tracks in them.</p>
</li>
<li>
<p>Playing a SCHC (3DTV) feed, where one view is MPEG-2 and the other is H.264
and they should be combined for 3D presentation, or not bother decoding 1
stream if displaying 2D.  (bug
https://gitlab.freedesktop.org/gstreamer/gst-plugins-bad/issues/118)</p>
</li>
<li>
<p>Playing an adaptive stream (HLS or DASH), the user can know the various
streams it can select, and only the required streams will be downloaded. This
is independent of the bitrate selection mechanism.</p>
</li>
</ol>
<h2 id="design-overview">Design Overview</h2>
<p>Stream selection in GStreamer is implemented in several parts:</p>
<ol>
<li>Objects describing streams : <code>GstStream</code>
</li>
<li>Objects describing a collection of streams : <code>GstStreamCollection</code>
</li>
<li>Events from the app allowing selection and activation of some streams:
<code>GST_EVENT_SELECT_STREAMS</code>
</li>
<li>Messages informing the user/application about the available streams and
current status: <code>GST_MESSAGE_STREAM_COLLECTION</code> and
<code>GST_MESSAGE_STREAMS_SELECTED</code>
</li>
<li>A field on <code>GST_EVENT_SELECT_STREAMS</code> to inform downstream elements that a
certain element can handle the stream selection itself.</li>
</ol>
<h2 id="gststream-objects">GstStream objects</h2>
<p>API:</p>
<pre><code class="language-c">typedef enum {
  GST_STREAM_TYPE_UNKNOWN   = 1 &lt;&lt; 0,
  GST_STREAM_TYPE_AUDIO     = 1 &lt;&lt; 1,
  GST_STREAM_TYPE_VIDEO     = 1 &lt;&lt; 2,
  GST_STREAM_TYPE_CONTAINER = 1 &lt;&lt; 3,
  GST_STREAM_TYPE_TEXT      = 1 &lt;&lt; 4
} GstStreamType;

struct {
	const gchar *stream_id;
} GstStream;

GstStream *gst_stream_new(...);

GstStream *gst_stream_get_*(...);

GstStream *gst_stream_set_*(...);

GstStream *gst_event_set_stream(GstEvent *stream_start, GstStream *stream)

void gst_event_parse_stream (GstEvent * event, GstStream ** stream);
</code></pre>
<p><code>GstStream</code> objects are a high-level convenience object containing information
regarding a possible data stream that can be exposed by GStreamer elements.</p>
<p>They are mostly the aggregation of information present in other GStreamer
components (<code>STREAM_START</code>, <code>CAPS</code>, <code>TAGS</code> events) but are not tied to the
presence of a <code>GstPad</code>, and for some use-cases provide information that the
existing components don't provide.</p>
<p>The various properties (available via setters/getters) of a <code>GstStream</code> object
are:</p>
<ul>
<li>stream_id (from the <code>STREAM_START</code> event)</li>
<li>flags (from the <code>STREAM_START</code> event)</li>
<li>caps</li>
<li>tags</li>
<li>type (high-level type of stream: Audio, Video, Container,...)</li>
</ul>
<p><code>GstStream</code> objects can be subclassed so that they can be re-used by elements
already using the notion of stream (which is common for example in demuxers).</p>
<p><strong>Note</strong>: While the intent of the design was indeed to allow providers to
subclass <code>GstStream</code>, it turns out it is better to <em>not</em> subclass it. Stream
providers should instead have separate structures to track their internal
properties of streams, and use a separate <code>GstStream</code> for storing information
they want to share.</p>
<p>Elements that create <code>GstStream</code> should also set it on the
<code>GST_EVENT_STREAM_START</code> event of the relevant pad. This helps downstream
elements have all information in one location.</p>
<h2 id="exposing-collections-of-streams">Exposing collections of streams</h2>
<p>API:</p>
<pre><code class="language-c">struct GstStreamCollection;

gst_stream_collection_new(...);
gst_stream_collection_add_stream(...);
gst_stream_collection_get_size(...);
gst_stream_collection_get_stream(...);

GST_MESSAGE_STREAM_COLLECTION
gst_message_new_stream_collection(...)
gst_message_parse_stream_collection(...)

GST_EVENT_STREAM_COLLECTION
gst_event_new_stream_collection(...)
gst_event_parse_stream_collection(...)
</code></pre>
<p>Elements that create new streams (such as demuxers) or can create new streams
(like the HLS/DASH alternative streams) can list the streams they can make
available with the <code>GstStreamCollection</code> object.</p>
<p>Other elements that might generate <code>GstStreamCollections</code> are the DVD-VM, which
handles internal switching of tracks, or <code>parsebin</code> and <code>decodebin3</code> when it
aggregates and presents multiple internal stream sources as a single
configurable collection.</p>
<p>The <code>GstStreamCollection</code> object is a flat listing of <code>GstStream</code> objects.</p>
<p>The various properties of a <code>GstStreamCollection</code> are:</p>
<ul>
<li>
<p>'identifier'</p>
<ul>
<li>the identifier of the collection (unique name)</li>
<li>Generated from the 'upstream stream id' (or stream ids, plural)</li>
</ul>
</li>
<li>
<p>the list of <code>GstStreams</code> in the collection.</p>
</li>
<li>
<p><strong>Not implemented</strong> : Flags</p>
<p>For now, the only flag is <code>INFORMATIONAL</code> - used by container parsers to
publish information about detected streams without allowing selection of the
streams. <em>Solving this might be possible through different means and needs
more investigation.</em></p>
</li>
<li>
<p><strong>Not implemented yet</strong> : The relationship between the various streams</p>
<p>This specifies which streams are exclusive (can not be selected at the same
time), are related (such as <code>LINKED_VIEW</code> or <code>ENHANCEMENT</code>), or need to be
selected together. <em>This requires more investigation</em></p>
</li>
</ul>
<p>An element will inform outside components about that collection of streams via:</p>
<ul>
<li>a <code>GST_MESSAGE_STREAM_COLLECTION</code> message on the bus.</li>
<li>a <code>GST_EVENT_STREAM_COLLECTION</code> on each source pads.</li>
</ul>
<p>Applications and container bin elements can listen and collect the various
stream collections to know the full range of streams available within a
bin/pipeline.</p>
<p>Once posted on the bus, a <code>GstStreamCollection</code> is immutable. It is updated by
subsequent messages with a matching identifier.</p>
<p>If the element that provided the collection goes away, there is no way to know
that the streams are no longer valid (without having the user/app track that
element). The exception to that is if the bin containing that element (such as
<code>parsebin</code> or <code>decodebin3</code>) informs that the next collection is a replacement of
the former one.</p>
<p>The mutual exclusion and relationship lists use stream-ids rather than
<code>GstStream</code> references in order to avoid circular referencing problems.</p>
<h3 id="usage-from-elements">Usage from elements</h3>
<p>When a demuxer knows the list of streams it can expose, it creates a new
<code>GstStream</code> for each stream it can provide with the appropriate information
(stream id, flag, tags, caps, ...).</p>
<p>The demuxer then creates a <code>GstStreamCollection</code> object in which it will put the
list of <code>GstStream</code> it can expose.  That collection is then both posted on the
bus (via a <code>GST_MESSAGE_COLLECTION</code>) and on each pad (via a
<code>GST_EVENT_STREAM_COLLECTION</code>).</p>
<p>That new collection must be posted on the bus <em>before</em> the changes are made
available. i.e. before pads corresponding to that selection are added/removed.</p>
<p>If an element can handle selecting a sub-set of those streams (for example a
HLS/DASH demuxer which only download the required streams), it can inform
downstream elements by answer the <code>GST_QUERY_SELECTABLE</code> with <code>TRUE</code>. It should
therefore be able to handle <code>GST_EVENT_SELECT_STREAMS</code> at any point in time
(including while posting the initial collection on the bus).</p>
<p>In order to be backwards-compatible and support elements that don't create
streams/collection yet, the <code>parsebin</code> element (used by <code>decodebin3</code>) will
automatically create the stream and collection if not provided by the elements
within.</p>
<h3 id="usage-from-application">Usage from application</h3>
<p>Applications can know what streams are available by listening to the
<code>GST_MESSAGE_STREAM_COLLECTION</code> messages posted on the bus.</p>
<p>The application can list the available streams per-type (such as all the audio
streams, or all the video streams) by iterating the streams available in the
collection by <code>GST_STREAM_TYPE</code>.</p>
<p>The application will also be able to use these stream information to decide
which streams should be activated or not (see the stream selection event below).</p>
<h3 id="backwards-compatibility">Backwards compatibility</h3>
<p>Not all demuxers will create the various <code>GstStream</code> and <code>GstStreamCollection</code>
objects. In order to remain backwards compatible, a parent bin (parsebin in
decodebin3) will create the <code>GstStream</code> and <code>GstStreamCollection</code> based on the
pads being added/removed from an element.</p>
<p>This allows providing stream listing/selection for any demuxer-like element even
if it doesn't implement the <code>GstStreamCollection</code> usage.</p>
<h2 id="adding-and-removing-pads-dynamically">Adding and removing pads dynamically</h2>
<p>API:</p>
<pre><code class="language-c">GST_BIN_FLAG_STREAMS_AWARE
</code></pre>
<p>If an element is within a <code>GstBin</code> with the <code>GST_BIN_FLAG_STREAMS_AWARE</code> set, it
can add and remove streams (and corresponding source <code>GstPad</code>) dynamically. It
does <strong>not</strong> have to (re)add all pads of the new stream set, emit <code>no-more-pads</code>
and then remove olds source pads.</p>
<p>This method is more efficient than the legacy behaviour, but is opt-in. Several
elements (<code>playbin3</code>, <code>decodebin3</code>, <code>urisourcebin</code> and more) have this flag set
by default. Application developers creating custom <code>GstBin</code> can set the flag to
make compatible elements add/remove pads dynamically.</p>
<h2 id="stream-selection-event">Stream selection event</h2>
<p>API:</p>
<pre><code class="language-c">GST_EVENT_SELECT_STREAMS

gst_event_new_select_streams(...)
gst_event_parse_select_streams(...)
</code></pre>
<p>Stream selection events are generated by the application and sent into the
pipeline to configure the streams.</p>
<p>The event carries:</p>
<ul>
<li>
<p>List of <code>GstStreams</code> to activate</p>
<ul>
<li>a subset of the <code>GstStreamCollection</code>
</li>
</ul>
</li>
<li>
<p><strong>Not implemented</strong> List of <code>GstStreams</code> to be kept discarded</p>
<ul>
<li>a subset of streams for which hot-swapping will not be desired, allowing
elements (such as decodebin3, demuxers, ...) to not parse or buffer those
streams at all. <em>This will be solved in a different fashion.</em>
</li>
</ul>
</li>
</ul>
<h3 id="usage-from-application1">Usage from application</h3>
<p>There are two use-cases where an application needs to specify in a generic
fashion which streams it wants in output:</p>
<ol>
<li>
<p>When there are several present streams of which it only wants a subset (such
as one audio, one video and one subtitle stream). Those streams are demuxed
and present in the pipeline.</p>
</li>
<li>
<p>When the stream the user wants require some element to undertake some action
to expose that stream in the pipeline (such as DASH/HLS alternative streams).</p>
</li>
</ol>
<p>From the point of view of the application, those two use-cases are treated
identically.  The streams are all available through the <code>GstStreamCollection</code>
posted on the bus, and the applications selects a subset.</p>
<p>The application can select the streams it wants by creating a
<code>GST_EVENT_SELECT_STREAMS</code> event with the list of stream-id of the streams it
wants. That event is then sent on the pipeline, eventually traveling all the way
upstream from each sink.</p>
<p>In some cases, selecting one stream may trigger the availability of other
dependent streams, resulting in new <code>GstStreamCollection</code> messages. This can
happen in the case where choosing a different DVB channel would create a new
single-program collection.</p>
<h3 id="usage-in-elements">Usage in elements</h3>
<p>Elements that receive the <code>GST_EVENT_SELECT_STREAMS</code> event and that can
activate/deactivate streams need to look at the list of stream-id contained in
the event and decide if they need to do some action.</p>
<p>In the standard demuxer case (demuxing and exposing all streams), there is
nothing to do by default (see below).</p>
<p>In <code>decodebin3</code>, activating or deactivating streams is taken care of by linking
only the streams present in the event to decoders and output ghostpad.</p>
<p>In the case of elements that can expose alternate streams that are not present
in the pipeline as pads, they will take the appropriate action to add/remove
those streams.</p>
<p>Containers that receive the event (via <code>GstElement::send_event()</code>) should pass
it to any elements with no downstream peers, so that streams can be configured
during pre-roll before a pipeline is completely linked down to sinks.</p>
<h4 id="which-elements-should-handle-streamselection-">Which elements should handle stream-selection ?</h4>
<p>By default demuxers <em>must</em> process and expose all streams contained within the
multiplex. This is to allow downstream stream switching to happen as fast as
possible.</p>
<p>The only exception to this is if extra processing (such as network download) can
be avoided upstream as is the case with HLS/DASH sources. Those elements inform
other downstream elements of this capability by replying to the
<code>GST_QUERY_SELECTABLE</code>. They are also responsible for selecting a default
selection of streams to output (one of each available <code>GstStreamType</code>) if no
<code>GST_EVENT_SELECT_STREAMS</code> was received before.</p>
<p>Furthermore, for all elements, stream-selection can only happen if the <code>GstBin</code>
they are in has the <code>GST_BIN_FLAG_STREAMS_AWARE</code> flag set.</p>
<p>Later design/API will be researched to allow use-cases where regular demuxers
could completely disable outputting some of the contained streams (to allow more
efficient I/O and memory usage).</p>
<h2 id="decodebin3-usage-and-example">decodebin3 usage and example</h2>
<p>This is an example of how decodebin3 works by using the above-mentioned
objects/events/messages.</p>
<p>For clarity/completeness, we will consider a MPEG-TS stream that has multiple
audio streams. Furthermore that stream might have changes at some point
(switching video codec, or adding/removing audio streams).</p>
<h3 id="initial-differences-with-decodebin2">Initial differences with <code>decodebin2</code>
</h3>
<p><code>decodebin3</code> is different, compared to <code>decodebin2</code>, in the sense that, by
default:</p>
<ul>
<li>it will only expose as output ghost source pads one stream of each type (one
audio, one video, ..).</li>
<li>It will only decode the exposed streams</li>
</ul>
<p>The <code>multiqueue</code> element is still used and takes in all elementary (non-decoded)
streams. If parsers are needed/present they are placed before the
multiqueue. This is needed in order for multiqueue to work only with packetized
and properly timestamped streams.</p>
<p>Note that the whole typefinding of streams, and optional depayloading, demuxing
and parsing are done in a new <code>parsebin</code> element.</p>
<p>Just like the current implementation, demuxers will expose all streams present
within a program as source pads. They will connect to parsers and multiqueue.</p>
<p>Initial setup. 1 video stream, 2 audio streams.</p>
<pre><code>  +---------------------+
  | parsebin            |
  | ---------           | +-------------+
  | | demux |--[parser]-+-| multiqueue  |--[videodec]---[
]-+-|       |--[parser]-+-|             |
  | |       |--[parser]-+-|             |--[audiodec]---[
  | ---------           | +-------------+
  +---------------------+
</code></pre>
<h3 id="generating-gststreamcollection">Generating GstStreamCollection</h3>
<p>When parsing the initial PAT/PMT, the demuxer will:</p>
<ol>
<li>
<p>create the various <code>GstStream</code> objects for each stream.</p>
</li>
<li>
<p>create the <code>GstStreamCollection</code> for that initial PMT</p>
</li>
<li>
<p>post the <code>GST_MESSAGE_STREAM_COLLECTION</code>. Decodebin will intercept that
message and know what the demuxer will be exposing.</p>
</li>
<li>
<p>The demuxer creates the various pads and sends the corresponding
<code>STREAM_START</code> event (with the same stream-id as the corresponding
<code>GstStream</code> objects), <code>CAPS</code> event, and <code>TAGS</code> event.</p>
</li>
</ol>
<ul>
<li>
<p><code>parsebin</code> will add all relevant parsers and expose those streams.</p>
</li>
<li>
<p><code>decodebin3</code> will be able to correlate, based on <code>STREAM_START</code> event
stream-id, what pad corresponds to which stream. It links each stream from
parsebin to multiqueue.</p>
</li>
<li>
<p><code>decodebin3</code> knows all the streams that will be available. Since by default
it is configured to only expose a stream of each type, it will pick a stream
of each for which it will complete the auto-plugging (finding a decoder and
then exposing that stream as a source ghostpad.</p>
</li>
</ul>
<blockquote>
<p>Note: If the demuxer doesn't create/post the <code>GstStreamCollection</code>, <code>parsebin</code>
will create it on itself, as explained in the previous sections above.</p>
</blockquote>
<h3 id="changing-the-active-selection-from-the-application">Changing the active selection from the application</h3>
<p>The user wants to change the audio track. The application received the
<code>GST_MESSAGE_STREAM_COLLECTION</code> containing the list of available streams. For
clarity, we will assume those stream-ids are <code>"video-main"</code>, <code>"audio-english"</code>
and <code>"audio-french"</code>.</p>
<p>The user prefers to use the french soundtrack (which it knows based on the
language tag contained in the <code>GstStream</code> objects).</p>
<p>The application will create and send a <code>GST_EVENT_SELECT_STREAM</code> event
containing the list of streams: <code>"video-main", "audio-french"</code>.</p>
<p>That event gets sent on the pipeline, the sinks send it upstream and eventually
reach <code>decodebin3</code>.</p>
<p><code>decodebin3</code> compares:</p>
<ul>
<li>The currently active selection (<code>"video-main", "audio-english"</code>)</li>
<li>The available stream collection (<code>"video-main", "audio-english", "audio-french"</code>)</li>
<li>The list of streams in the event (<code>"video-main", "audio-french"</code>)</li>
</ul>
<p><code>decodebin3</code> determines that no change is required for <code>"video-main"</code>, but sees
that it needs to deactivate <code>"audio-english"</code> and activate <code>"audio-french"</code>.</p>
<p>It unlinks the <code>multiqueue</code> source pad connected to the current audio
decoder. Then it queries that audio decoder, using the <code>GST_QUERY_ACCEPT_CAPS</code>,
whether it can accept as-is the caps from the <code>"audio-french"</code> stream.</p>
<ol>
<li>
<p>If it does, the multiqueue source pad corresponding to <code>"audio-french"</code> is
linked to the decoder.</p>
</li>
<li>
<p>If it does not, the existing audio decoder is removed, a new decoder is
selected (like during initial auto-plugging), and replaces the old audio
decoder element.</p>
</li>
</ol>
<p>The newly selected stream gets decoded and output through the same pad as the
previous audio stream.</p>
<p><em>Note:</em> The default behavior is to only expose one stream of each type. But
nothing prevents <code>decodebin3</code> from outputting more/less of each type if the
<code>GST_EVENT_SELECT_STREAM</code> event specifies that. This allows covering more
use-case than the simple playback one. Such examples could be :</p>
<ul>
<li>Wanting just a video stream or just an audio stream</li>
<li>Wanting all decoded streams</li>
<li>Wanting all audio streams
...</li>
</ul>
<h3 id="changes-of-stream-collection">Changes of stream collection</h3>
<p>At some point in time, a PMT change happens. Let's assume a change in
video-codec and/or PID.</p>
<p>The demuxer creates a new <code>GstStream</code> for the changed/new stream, creates a new
<code>GstStreamCollection</code> for the updated PMT and posts it.</p>
<p><code>decodebin3</code> sees the new <code>GstStreamCollection</code> message.</p>
<p>The demuxer (and <code>parsebin</code>) then adds and removes pads:</p>
<ol>
<li>
<p><code>decodebin3</code> will match the new pads to <code>GstStream</code> in the <em>new</em>
<code>GstStreamCollection</code> the <a href="additional/design/stream-selection.html#generating-gststreamcollection">same way it did</a>
for the initial pads previously.</p>
</li>
<li>
<p><code>decodebin3</code> will see whether the new stream can re-use a <code>multiqueue</code> slot
used by a stream of the same type no longer present (it compares the old
collection to the new collection).  In this case, <code>decodebin3</code> sees that the
new video stream can re-use the same slot as the previous video stream.</p>
</li>
<li>
<p>If the new stream is going to be active by default (in this case it does
because we are replacing the only video stream, which was active), it will
check whether the caps are compatible with the existing video decoder (in the
same way it was done for the <a href="additional/design/stream-selection.html#changing-the-active-selection-from-the-application">audio decoder
switch</a>).</p>
</li>
</ol>
<p>Finally, the stream that switched will be decoded and output through the same
pad as the previous video stream in a gapless fashion.</p>
<h3 id="further-examples">Further examples</h3>
<h5 id="dashhls-alternates-selection-handled-upstream-of-decodebin3">DASH/HLS alternates (selection handled upstream of decodebin3)</h5>
<p>There is a main (multi-bitrate or not) stream with audio and video interleaved
in MPEG-TS. The manifest also indicates the presence of alternate language
audio-only streams.</p>
<ul>
<li>(main) variant stream : <code>video</code>, <code>audio-eng</code>
</li>
<li>alternate rendition streams : <code>audio-kor</code>, <code>audio-fre</code>
</li>
</ul>
<p>A new element, <code>hlsdemux2</code>, used within <code>urisourcebin</code>, exposes one collection
containing all individual elementary streams (regardless of bitrates). This is
based on the contents of the manifest:</p>
<ul>
<li><code>[ video , audio-eng, audio-kor, audio-fre ]</code></li>
</ul>
<p>Similar to other demuxers, it will post the collection on the bus, and will
add/remove pads dynamically based on <code>GST_EVENT_SELECT_STREAMS</code> (or make a
default choice if no event was received).</p>
<p>Since it can offer a selection of "elementary" streams, it will internally
demux, parse and buffer the requested streams.</p>
<p>If ever it receives the <code>GST_QUERY_SELECTABLE</code>, it will set the <code>selectable</code>
field of that query to TRUE. This informs <code>decodebin3</code> that it should handle all
incoming streams and not do any selection (it is done upstream).</p>
<pre><code>  +-----------+               + decodebin3 -----------------------------+
  | hlsdemux2 |               |                                         |
  |           |               |             +------------+              |
  |           +-   `video`   -+-[parsebin]--+ multiqueue +--[videodec]--[
  |           +- `audio-eng` -+-[parsebin]--+------------+--[audiodec]--[
  |           |               |                                         |
  +-----------+               +-----------------------------------------+
</code></pre>
<p>The user might want to use the korean audio track instead of the default english
one.</p>
<pre><code>  =&gt; SELECT_STREAMS ("video", "kor")
</code></pre>
<ol start="0">
<li>
<p>When <code>decodebin3</code> received <code>GST_EVENT_STREAM_START</code> on the <em>initial</em> incoming
streams, it sent a <code>GST_QUERY_SELECTABLE</code> which <code>hlsdemux2</code> answered
succesfully. <code>decodebin3</code> therefore knows that the upstream of that stream can
handle stream-selection itself.</p>
</li>
<li>
<p><code>decodebin3</code> receives the new <code>SELECT_STREAMS</code> event, and knows that upstream
can handle stream selection and therefore forwards it upstream.</p>
</li>
<li>
<p><code>hlsdemux2</code> receives the event, and prepares the <code>audio-kor</code> backing stream
to be downloaded and returns. <code>decodebin3</code> also returns the event as is and
doesn't do any selection itself.</p>
</li>
<li>
<p>Once <code>hlsdemux2</code> has downloaded enough from the target <code>audio-kor</code> stream,
which it has demuxed, parsed and buffered internally, it will output it to the
same output pad (replacing <code>audio-eng</code>):</p>
</li>
</ol>
<ul>
<li>Send a new <code>GST_EVENT_STREAM_START</code> containing the information about
<code>audio-kor</code>
</li>
<li>Send the various required events (caps, stream-collection,...)</li>
<li>Send the buffers for the new stream</li>
</ul>
<ol start="4">
<li>If the incoming stream isn't compatible with the existing <code>parsebin</code>,
<code>decodebin3</code> will reset it so that it reconfigures itself.</li>
</ol>
<pre><code>  +-----------+               + decodebin3 -----------------------------+
  | hlsdemux2 |               |                                         |
  |           |               |             +------------+              |
  |           +-   `video`   -+-[parsebin]--+ multiqueue +--[videodec]--[
  |           +- `audio-kor` -+-[parsebin]--+------------+--[audiodec]--[
  |           |               |                                         |
  +-----------+               +-----------------------------------------+
</code></pre>
<h4 id="multiprogram-mpegts">Multi-program MPEG-TS</h4>
<p><strong>NOTE:</strong> Not properly handled yet.</p>
<p>Assuming the case of a MPEG-TS stream which contains multiple programs.</p>
<p>There would be three "levels" of collection:</p>
<ol>
<li>The collection of programs presents in the stream</li>
<li>The collection of elementary streams presents in a stream</li>
<li>The collection of streams decodebin can expose</li>
</ol>
<p>Initially <code>tsdemux</code> exposes the first program present (default)</p>
<pre><code>    [ Collection 1 ]         [ Collection 2     ]        [ Collection 3    ]
    [  (tsdemux)   ]         [   (tsdemux)      ]        [ (decodebin)     ]
    [ id:Programs  ]&lt;-\      [ id:BBC1          ]&lt;-\     [ id:BBC1-decoded ]
    [ upstream:nil ]   \-----[ upstream:Programs]   \----[ upstream:BBC1   ]
    [              ]         [                  ]        [                 ]
    [ "BBC1" (C)   ]         [ id:"bbcvideo"(V) ]        [ id:"bbcvideo"(V)]
    [ "ITV"  (C)   ]         [ id:"bbcaudio"(A) ]        [ id:"bbcaudio"(A)]
    [ "NBC"  (C)   ]         [                  ]        [                 ]
</code></pre>
<p>At some point the user wants to switch to ITV (of which we do not know the
topology at this point in time. A <code>SELECT_STREAMS</code> event is sent with "ITV" in
it and the pointer to the Collection1.</p>
<ol>
<li>
<p>The event travels up the pipeline until <code>tsdemux</code> receives it and begins the
switch.</p>
</li>
<li>
<p><code>tsdemux</code> publishes a new 'Collection 2a/ITV' and marks 'Collection 2/BBC' as
replaced.</p>
<ol>
<li>App may send a <code>SELECT_STREAMS</code> event configuring which demuxer output
streams should be selected (parsed)</li>
</ol>
</li>
<li>
<p><code>tsdemux</code> adds/removes pads as needed (flushing pads as it removes them?)</p>
</li>
<li>
<p><code>decodebin3</code> feeds new pad streams through existing parsers/decoders as
needed. As data from the new collection arrives out each decoder,
<code>decodebin3</code> sends new <code>GstStreamCollection</code> messages to the app so it can
know that the new streams are now switchable at that level.</p>
<ol>
<li>As new <code>GstStreamCollections</code> are published, the app may override the
default decodebin stream selection to expose more/fewer streams.  The
default is to decode and output 1 stream of each type.</li>
</ol>
</li>
</ol>
<p>Final state:</p>
<pre><code>    [ Collection 1 ]         [ Collection 4     ]        [ Collection 5    ]
    [  (tsdemux)   ]         [   (tsdemux)      ]        [ (decodebin)     ]
    [ id:Programs  ]&lt;-\      [ id:ITV           ]&lt;-\     [ id:ITV-decoded  ]
    [ upstream:nil ]   \-----[ upstream:Programs]   \----[ upstream:ITV    ]
    [              ]         [                  ]        [                 ]
    [ "BBC1" (C)   ]         [ id:"itvvideo"(V) ]        [ id:"itvvideo"(V)]
    [ "ITV"  (C)   ]         [ id:"itvaudio"(A) ]        [ id:"itvaudio"(A)]
    [ "NBC"  (C)   ]         [                  ]        [                 ]
</code></pre>
<h3 id="todo">TODO</h3>
<ul>
<li>
<p>Figure out how to handle <em>mutual-exclusion</em> and <em>relationship</em> API with
collection of streams.</p>
</li>
<li>
<p>~~Add flags to <code>GstStreamCollection</code>~~</p>
</li>
<li>
<p>Add helper API to figure out whether a collection is a replacement of another
or a completely new one. This will require a more generic system to know
whether a certain stream-id is a replacement of another or not.</p>
</li>
</ul>
<h3 id="open-questions">Open Questions</h3>
<ul>
<li>
<p>~~Is a <code>FLUSHING</code> flag for stream-selection required or not?~~</p>
<p>This would make the handler of the <code>SELECT_STREAMS</code> event send <code>FLUSH START/STOP</code> before switching to the other streams. This is tricky when dealing
where situations where we keep some streams and only switch some others. Do we
flush all streams? Do we only flush the new streams, potentially resulting in
delay to fully switch?  Furthermore, due to efficient buffering in
<code>decodebin3</code>, the switching time has been minimized extensively, to the point
where flushing might not bring a noticeable improvement.</p>
<p><strong>Note:</strong> This flushing capability was not needed in the end. Leveraging
minimal buffering in <code>decodebin3</code> and various other elements allows
<em>almost-instantaneous</em> stream switching without this.</p>
</li>
<li>
<p>Store the stream collection in bins/pipelines?</p>
<p>A Bin/Pipeline could store all active collection internally, so that it could
be queried later on. This could be useful to then get, on any pipeline, at any
point in time, the full list of collections available without having to listen
to all COLLECTION messages on the bus. This would require fixing the "is a
collection a replacement or not" issue first.</p>
</li>
<li>
<p>When switching to new collections, should <code>decodebin3</code> make any effort to
<em>map</em> corresponding streams from the old to new PMT - that is, try and stick
to the <em>english</em> language audio track, for example?  Alternatively, rely on
the app to do such smarts with stream-select messages?</p>
<p><strong>Note:</strong> If an application listens synchronously to the collection bus
messages, it can indeed decide which streams it wants to select. And therefore
stick to the (new) english audio track.</p>
</li>
</ul>

    </div>
        




		
	</div>
	<div id="search_results">
		<p>The results of the search are</p>
	</div>
	<div id="footer">
		    

	</div>
</div>

<div id="toc-column">
	
		<div class="edit-button">
		<a href="https://gitlab.freedesktop.org/gstreamer/gst-docs//edit/master/subprojects/gst-docs/markdown/additional/design/stream-selection.md" data-hotdoc-role="edit-button">Edit on GitLab</a>

	</div>
		<div id="toc-wrapper">
		<nav id="toc"></nav>
	</div>
</div>
</div>
</main>


<script src="assets/js/navbar_offset_scroller.js"></script>
</body>
</html>
