fragment_downloaded_cb({"url":"base/gstaggregator.html#gstaggregator-page","fragment":"GstAggregator\nManages a set of pads with the purpose of aggregating their buffers.\nControl is given to the subclass when all pads have data.\nBase class for mixers and muxers. Subclasses should at least implement\nthe aggregate virtual method.\nInstalls a GstPadChainFunction, a GstPadEventFullFunction and a\nGstPadQueryFunction to queue all serialized data packets per sink pad.\nSubclasses should not overwrite those, but instead implement\nsink_event and sink_query as\nneeded.\nWhen data is queued on all pads, the aggregate vmethod is called.\nOne can peek at the data on any given GstAggregatorPad with the\ngst_aggregator_pad_peek_buffer method, and remove it from the pad\nwith the gst_aggregator_pad_pop_buffer () method. When a buffer\nhas been taken with pop_buffer (), a new buffer can be queued\non that pad.\nWhen gst_aggregator_pad_peek_buffer or gst_aggregator_pad_has_buffer\nare called, a reference is taken to the returned buffer, which stays\nvalid until either:\nSubsequent calls to gst_aggregator_pad_peek_buffer or\ngst_aggregator_pad_has_buffer return / check the same buffer that was\nreturned / checked, until one of the conditions listed above is met.\nSubclasses are only allowed to call these methods from the aggregate\nthread.\nIf the subclass wishes to push a buffer downstream in its aggregate\nimplementation, it should do so through the\ngst_aggregator_finish_buffer method. This method will take care\nof sending and ordering mandatory events such as stream start, caps\nand segment. Buffer lists can also be pushed out with\ngst_aggregator_finish_buffer_list.\nSame goes for EOS events, which should not be pushed directly by the\nsubclass, it should instead return GST_FLOW_EOS in its aggregate\nimplementation.\nNote that the aggregator logic regarding gap event handling is to turn\nthese into gap buffers with matching PTS and duration. It will also\nflag these buffers with GST_BUFFER_FLAG_GAP and GST_BUFFER_FLAG_DROPPABLE\nto ease their identification and subsequent processing.\nIn addition, if the gap event was flagged with GST_GAP_FLAG_MISSING_DATA,\na custom meta is added to the resulting gap buffer (GstAggregatorMissingDataMeta).\nSubclasses must use (a subclass of) GstAggregatorPad for both their\nsink and source pads.\nSee gst_element_class_add_static_pad_template_with_gtype.\nThis class used to live in gst-plugins-bad and was moved to core.\n\n\nBase class for mixers and muxers. Subclasses should at least implement\nthe aggregate virtual method.\n\n\nInstalls a GstPadChainFunction, a GstPadEventFullFunction and a\nGstPadQueryFunction to queue all serialized data packets per sink pad.\nSubclasses should not overwrite those, but instead implement\nsink_event and sink_query as\nneeded.\n\n\nWhen data is queued on all pads, the aggregate vmethod is called.\n\n\nOne can peek at the data on any given GstAggregatorPad with the\ngst_aggregator_pad_peek_buffer method, and remove it from the pad\nwith the gst_aggregator_pad_pop_buffer () method. When a buffer\nhas been taken with pop_buffer (), a new buffer can be queued\non that pad.\n\n\nWhen gst_aggregator_pad_peek_buffer or gst_aggregator_pad_has_buffer\nare called, a reference is taken to the returned buffer, which stays\nvalid until either:\n\n\ngst_aggregator_pad_pop_buffer is called, in which case the caller\nis guaranteed that the buffer they receive is the same as the peeked\nbuffer.\n\ngst_aggregator_pad_drop_buffer is called, in which case the caller\nis guaranteed that the dropped buffer is the one that was peeked.\nthe subclass implementation of aggregate returns.\n\nSubsequent calls to gst_aggregator_pad_peek_buffer or\ngst_aggregator_pad_has_buffer return / check the same buffer that was\nreturned / checked, until one of the conditions listed above is met.\nSubclasses are only allowed to call these methods from the aggregate\nthread.\n\n\nIf the subclass wishes to push a buffer downstream in its aggregate\nimplementation, it should do so through the\ngst_aggregator_finish_buffer method. This method will take care\nof sending and ordering mandatory events such as stream start, caps\nand segment. Buffer lists can also be pushed out with\ngst_aggregator_finish_buffer_list.\n\n\nSame goes for EOS events, which should not be pushed directly by the\nsubclass, it should instead return GST_FLOW_EOS in its aggregate\nimplementation.\n\n\nNote that the aggregator logic regarding gap event handling is to turn\nthese into gap buffers with matching PTS and duration. It will also\nflag these buffers with GST_BUFFER_FLAG_GAP and GST_BUFFER_FLAG_DROPPABLE\nto ease their identification and subsequent processing.\nIn addition, if the gap event was flagged with GST_GAP_FLAG_MISSING_DATA,\na custom meta is added to the resulting gap buffer (GstAggregatorMissingDataMeta).\n\n\nSubclasses must use (a subclass of) GstAggregatorPad for both their\nsink and source pads.\nSee gst_element_class_add_static_pad_template_with_gtype.\n\n\n\n\ngst_aggregator_pad_pop_buffer is called, in which case the caller\nis guaranteed that the buffer they receive is the same as the peeked\nbuffer.\n\ngst_aggregator_pad_drop_buffer is called, in which case the caller\nis guaranteed that the dropped buffer is the one that was peeked.\nthe subclass implementation of aggregate returns.\n\n"});