fragment_downloaded_cb({"url":"base/gstbaseparse.html#parsing-phase","fragment":"Parsing phase\nGstBaseParse gathers at least min_frame_size bytes of data either\nby pulling it from upstream or collecting buffers in an internal\nGstAdapter.\nA buffer of (at least) min_frame_size bytes is passed to subclass\nwith handle_frame. Subclass checks the contents\nand can optionally return GST_FLOW_OK along with an amount of data\nto be skipped to find a valid frame (which will result in a\nsubsequent DISCONT).  If, otherwise, the buffer does not hold a\ncomplete frame, handle_frame can merely return\nand will be called again when additional data is available.  In push\nmode this amounts to an additional input buffer (thus minimal\nadditional latency), in pull mode this amounts to some arbitrary\nreasonable buffer size increase.\nOf course, gst_base_parse_set_min_frame_size could also be used if\na very specific known amount of additional data is required.  If,\nhowever, the buffer holds a complete valid frame, it can pass the\nsize of this frame to gst_base_parse_finish_frame.\nIf acting as a converter, it can also merely indicate consumed input\ndata while simultaneously providing custom output data.  Note that\nbaseclass performs some processing (such as tracking overall consumed\ndata rate versus duration) for each finished frame, but other state\nis only updated upon each call to handle_frame\n(such as tracking upstream input timestamp).\nSubclass is also responsible for setting the buffer metadata\n(e.g. buffer timestamp and duration, or keyframe if applicable).\n(although the latter can also be done by GstBaseParse if it is\nappropriately configured, see below).  Frame is provided with\ntimestamp derived from upstream (as much as generally possible),\nduration obtained from configuration (see below), and offset\nif meaningful (in pull mode).\nNote that handle_frame might receive any small\namount of input data when leftover data is being drained (e.g. at\nEOS).\nAs part of finish frame processing, just prior to actually pushing\nthe buffer in question, it is passed to\npre_push_frame which gives subclass yet one last\nchance to examine buffer metadata, or to send some custom (tag)\nevents, or to perform custom (segment) filtering.\nDuring the parsing process GstBaseParseClass will handle both srcpad\nand sinkpad events. They will be passed to subclass if\nsink_event or src_event\nimplementations have been provided.\n\n\nGstBaseParse gathers at least min_frame_size bytes of data either\nby pulling it from upstream or collecting buffers in an internal\nGstAdapter.\n\n\nA buffer of (at least) min_frame_size bytes is passed to subclass\nwith handle_frame. Subclass checks the contents\nand can optionally return GST_FLOW_OK along with an amount of data\nto be skipped to find a valid frame (which will result in a\nsubsequent DISCONT).  If, otherwise, the buffer does not hold a\ncomplete frame, handle_frame can merely return\nand will be called again when additional data is available.  In push\nmode this amounts to an additional input buffer (thus minimal\nadditional latency), in pull mode this amounts to some arbitrary\nreasonable buffer size increase.\nOf course, gst_base_parse_set_min_frame_size could also be used if\na very specific known amount of additional data is required.  If,\nhowever, the buffer holds a complete valid frame, it can pass the\nsize of this frame to gst_base_parse_finish_frame.\nIf acting as a converter, it can also merely indicate consumed input\ndata while simultaneously providing custom output data.  Note that\nbaseclass performs some processing (such as tracking overall consumed\ndata rate versus duration) for each finished frame, but other state\nis only updated upon each call to handle_frame\n(such as tracking upstream input timestamp).\nSubclass is also responsible for setting the buffer metadata\n(e.g. buffer timestamp and duration, or keyframe if applicable).\n(although the latter can also be done by GstBaseParse if it is\nappropriately configured, see below).  Frame is provided with\ntimestamp derived from upstream (as much as generally possible),\nduration obtained from configuration (see below), and offset\nif meaningful (in pull mode).\nNote that handle_frame might receive any small\namount of input data when leftover data is being drained (e.g. at\nEOS).\n\n\nAs part of finish frame processing, just prior to actually pushing\nthe buffer in question, it is passed to\npre_push_frame which gives subclass yet one last\nchance to examine buffer metadata, or to send some custom (tag)\nevents, or to perform custom (segment) filtering.\n\n\nDuring the parsing process GstBaseParseClass will handle both srcpad\nand sinkpad events. They will be passed to subclass if\nsink_event or src_event\nimplementations have been provided.\n\n\n"});