fragment_downloaded_cb({"url":"tutorials/android/a-running-pipeline.html#check_initialization_complete","fragment":"check_initialization_complete()\nThis method does not do much in this tutorial, but it will also be used\nin the next ones, with progressively more complex functionality. Its\npurpose is to check if the native code is ready to accept commands, and,\nif so, notify the UI code.\nIn tutorial 2, the only conditions are 1) the code is not already\ninitialized and 2) the main loop is running. If these two are met, the\nJava onGStreamerInitialized() method is called via the\nCallVoidMethod()\nJNI call.\nHere comes a tricky bit. JNI calls require a JNI Environment, which is\ndifferent for every thread. C methods called from Java receive a\nJNIEnv pointer as a parameter, but this is not the situation with\ncheck_initialization_complete(). Here, we are in a thread which has\nnever been called from Java, so we have no JNIEnv. We need to use the\nJavaVM pointer (passed to us in the JNI_OnLoad() method, and shared\namong all threads) to attach this thread to the Java Virtual Machine and\nobtain a JNIEnv. This JNIEnv is stored in the Thread-Local\nStorage (TLS) using\nthe pthread key we created in JNI_OnLoad(), so we do not need to\nattach the thread anymore.\nThis behavior is implemented in the get_jni_env() method, used for\nexample in check_initialization_complete() as we have just seen. Letâ€™s\nsee how it works, step by step:\n"});