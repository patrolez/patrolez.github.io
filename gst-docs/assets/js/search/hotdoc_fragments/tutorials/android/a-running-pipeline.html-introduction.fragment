fragment_downloaded_cb({"url":"tutorials/android/a-running-pipeline.html#introduction","fragment":"Introduction\nWhen using a Graphical User Interface (UI), if the application waits for\nGStreamer calls to complete the user experience will suffer. The usual\napproach, with the GTK+ toolkit for example, is to\nrelinquish control to a GLib GMainLoop and let it control the events\ncoming from the UI or GStreamer.\nThis approach can be very cumbersome when GStreamer and the Android UI\ncommunicate through the JNI interface, so we take a cleaner route: We\nuse a GLib main loop, and move it to its own thread, so it does not\nblock the application. This simplifies the GStreamer-Android\nintegration, and we only need to worry about a few inter-process\nsynchronization bits, which are detailed in this tutorial.\nAdditionally, this tutorial shows how to obtain, from any thread, the\nJNI Environment\npointer\nrequired to make JNI calls. This is necessary, for example, to call Java\ncode from callbacks in threads spawned deep within GStreamer, which\nnever received this pointer directly.\nFinally, this tutorial explains how to call Java methods from native C\ncode, which involves locating the desired methodâ€™s ID in the class.\nThese IDs never change, so they are cached as global variables in the C\ncode and obtained in the static initializer of the class.\nThe code below builds a pipeline with an audiotestsrc and an\nautoaudiosink (it plays an audible tone). Two buttons in the UI allow\nsetting the pipeline to PLAYING or PAUSED. A TextView in the UI shows\nmessages sent from the C code (for errors and state changes).\n"});