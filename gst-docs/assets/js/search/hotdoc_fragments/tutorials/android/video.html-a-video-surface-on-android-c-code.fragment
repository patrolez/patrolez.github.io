fragment_downloaded_cb({"url":"tutorials/android/video.html#a-video-surface-on-android-c-code","fragment":"A video surface on Android [C code]\njni/tutorial-3.c\nFirst, our CustomData structure is augmented to keep a pointer to the\nvideo sink element and the native window\nhandle:\nThe check_initialization_complete() method is also augmented so that\nit requires a native window before considering GStreamer to be\ninitialized:\nAlso, once the pipeline has been built and a native window has been\nreceived, we inform the video sink of the window handle to use via the\ngst_video_overlay_set_window_handle() method.\nThe GStreamer pipeline for this tutorial involves a videotestsrc, a\nwarptv psychedelic distorter effect (check out other cool video\neffects in the GSTREAMER_PLUGINS_EFFECTS package), and an\nautovideosink which will instantiate the adequate video sink for the\nplatform:\nHere things start to get more\ninteresting:\nWe start by setting the pipeline to the READY state. No data flow occurs\nyet, but the autovideosink will instantiate the actual sink so we can\nask for it immediately.\nThe gst_bin_get_by_interface() method will examine the whole pipeline\nand return a pointer to an element which supports the requested\ninterface. We are asking for the VideoOverlay interface, explained in\nBasic tutorial 5: GUI toolkit integration,\nwhich controls how to perform rendering into foreign (non-GStreamer)\nwindows. The internal video sink instantiated by autovideosink is the\nonly element in this pipeline implementing it, so it will be returned.\nNow we will implement the two native functions called by the Java code\nwhen the drawing surface becomes available or is about to be\ndestroyed:\nThis method is responsible for providing the video sink with the window\nhandle coming from the Java code. We are passed a\nSurface\nobject, and we use ANativeWindow_fromSurface() to obtain the\nunderlying native window pointer. There is no official online\ndocumentation for the NDK, but fortunately the header files are well\ncommented. Native window management functions can be found in\n$(ANDROID_NDK_ROOT)\\platforms\\android-9\\arch-arm\\usr\\include\\android\\native_window.h and native_window_jni.h\nIf we had already stored a native window, the one we just received can\neither be a new one, or just an update of the one we have. If the\npointers are the same, we assume the geometry of the surface has\nchanged, and simply instruct the video sink to redraw itself, via the\ngst_video_overlay_expose() method. The video sink will recover the new\nsize from the surface itself, so we do not need to bother about it\nhere. We need to call gst_video_overlay_expose() twice because of the way\nthe surface changes propagate down the OpenGL ES / EGL pipeline (The\nonly video sink available for Android in GStreamer uses OpenGL\nES). By the time we call the first expose, the surface that the sink\nwill pick up still contains the old size.\nOn the other hand, if the pointers are different, we mark GStreamer as\nnot being initialized. Next time we call\ncheck_initialization_complete(), the video sink will be informed of\nthe new window handle.\nWe finally store the new window handle and call\ncheck_initialization_complete() to inform the Java code that\neverything is set up, if that is the case.\nThe complementary function, gst_native_surface_finalize() is called\nwhen a surface is about to be destroyed and should not be used anymore.\nHere, we simply instruct the video sink to stop using the window handle\nand set the pipeline to READY so no rendering occurs. We release the\nwindow pointer we had stored with ANativeWindow_release(), and mark\nGStreamer as not being initialized anymore.\nAnd this is all there is to it, regarding the main code. Only a couple\nof details remain, the subclass we made for SurfaceView and the\nAndroid.mk file.\n"});