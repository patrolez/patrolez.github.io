fragment_downloaded_cb({"url":"tutorials/android/a-running-pipeline.html#a-pipeline-on-android-java-code","fragment":"A pipeline on Android [Java code]\nsrc/org/freedesktop/gstreamer/tutorials/tutorial_2/Tutorial2.java\nAs usual, the first bit that gets executed is the static initializer of\nthe class:\nAs explained in the previous tutorial, the two native libraries are\nloaded and their JNI_OnLoad() methods are executed. Here, we also call\nthe native method nativeClassInit(), previously declared with the\nnative keyword in line 19. We will later see what its purpose is\nIn the onCreate() method GStreamer is initialized as in the previous\ntutorial with GStreamer.init(this), and then the layout is inflated\nand listeners are setup for the two UI buttons:\nEach button instructs the native code to set the pipeline to the desired\nstate, and also remembers this state in the\nis_playing_desired variable.  This is required so, when the\napplication is restarted (for example, due to an orientation change), it\ncan set the pipeline again to the desired state. This approach is easier\nand safer than tracking the actual pipeline state, because orientation\nchanges can happen before the pipeline has moved to the desired state,\nfor example.\nRestore the previous playing state (if any) from savedInstanceState.\nWe will first build the GStreamer pipeline (below) and only when the\nnative code reports itself as initialized we will use\nis_playing_desired.\nAs will be shown in the C code, nativeInit() creates a dedicated\nthread, a GStreamer pipeline, a GLib main loop, and, right before\ncalling g_main_loop_run() and going to sleep, it warns the Java code\nthat the native code is initialized and ready to accept commands.\nThis finishes the onCreate() method and the Java initialization. The\nUI buttons are disabled, so nothing will happen until native code is\nready and onGStreamerInitialized() is called:\nThis is called by the native code when its main loop is finally running.\nWe first retrieve the desired playing state from is_playing_desired,\nand then set that state:\nHere comes the first caveat, when re-enabling the UI buttons:\nThis method is being called from the thread that the native code created\nto run its main loop, and is not allowed to issue UI-altering commands:\nOnly the UI thread can do that. The solution is easy though: Android\nActivities have a handy\nrunOnUiThread()\nmethod which lets bits of code to be executed from the correct thread. A\nRunnable\ninstance has to be constructed and any parameter can be passed either by\nsub-classing\nRunnable\nand adding a dedicated constructor, or by using the final modifier, as\nshown in the above snippet.\nThe same problem exists when the native code wants to output a string in\nour TextView using the setMessage() method: it has to be done from the\nUI thread. The solution is the same:\nFinally, a few remaining bits:\nThis method stores the currently desired playing state when Android is\nabout to shut us down, so next time it restarts (after an orientation\nchange, for example), it can restore the same state.\nAnd this is called before Android destroys our application. We call the\nnativeFinalize()method to exit the main loop, destroy its thread and\nall allocated resources.\nThis concludes the UI part of the tutorial.\n"});