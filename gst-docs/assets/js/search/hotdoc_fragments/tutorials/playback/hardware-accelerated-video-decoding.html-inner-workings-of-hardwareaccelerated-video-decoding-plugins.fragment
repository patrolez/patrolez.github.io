fragment_downloaded_cb({"url":"tutorials/playback/hardware-accelerated-video-decoding.html#inner-workings-of-hardwareaccelerated-video-decoding-plugins","fragment":"Inner workings of hardware-accelerated video decoding plugins\nThese APIs generally offer a number of functionalities, like video\ndecoding, post-processing, or presentation of the decoded\nframes. Correspondingly, plugins generally offer a different GStreamer\nelement for each of these functions, so pipelines can be built to\naccommodate any need.\nFor example, the gstreamer-vaapi plugin offers the vaapidecode,\nvaapipostproc and vaapisink elements that allow\nhardware-accelerated decoding through VAAPI, upload of raw video frames\nto GPU memory, download of GPU frames to system memory and presentation\nof GPU frames, respectively.\nIt is important to distinguish between conventional GStreamer frames,\nwhich reside in system memory, and frames generated by\nhardware-accelerated APIs. The latter reside in GPU memory and cannot\nbe touched by GStreamer. They can usually be downloaded to system\nmemory and treated as conventional GStreamer frames when they are\nmapped, but it is far more efficient to leave them in the GPU and\ndisplay them from there.\nGStreamer needs to keep track of where these “hardware buffers” are\nthough, so conventional buffers still travel from element to\nelement. They look like regular buffers, but mapping their content is\nmuch slower as it has to be retrieved from the special memory used by\nhardware accelerated elements. This special memory types are\nnegotiated using the allocation query mechanism.\nThis all means that, if a particular hardware acceleration API is\npresent in the system, and the corresponding GStreamer plugin is also\navailable, auto-plugging elements like playbin are free to use\nhardware acceleration to build their pipelines; the application does not\nneed to do anything special to enable it. Almost:\nWhen playbin has to choose among different equally valid elements,\nlike conventional software decoding (through vp8dec, for example) or\nhardware accelerated decoding (through vaapidecode, for example), it\nuses their rank to decide. The rank is a property of each element that\nindicates its priority; playbin will simply select the element that\nis able to build a complete pipeline and has the highest rank.\nSo, whether playbin will use hardware acceleration or not will depend\non the relative ranks of all elements capable of dealing with that media\ntype. Therefore, the easiest way to make sure hardware acceleration is\nenabled or disabled is by changing the rank of the associated element,\nas shown in this code:\nThe first parameter passed to this method is the name of the element to\nmodify, for example, vaapidecode or fluvadec.\nThe key method is gst_plugin_feature_set_rank(), which will set the\nrank of the requested element factory to the desired level. For\nconvenience, ranks are divided in NONE, MARGINAL, SECONDARY and PRIMARY,\nbut any number will do. When enabling an element, we set it to\nPRIMARY+1, so it has a higher rank than the rest of elements which\ncommonly have PRIMARY rank. Setting an element’s rank to NONE will make\nthe auto-plugging mechanism to never select it.\n The GStreamer developers often rank hardware decoders lower than\nthe software ones when they are defective. This should act as a warning.\n"});