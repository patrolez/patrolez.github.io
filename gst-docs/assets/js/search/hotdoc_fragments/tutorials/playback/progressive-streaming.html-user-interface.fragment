fragment_downloaded_cb({"url":"tutorials/playback/progressive-streaming.html#user-interface","fragment":"User Interface\nIn main we also install a timer which we use to refresh the UI every\nsecond.\nThe refresh_ui method queries the pipeline to find out which parts of\nthe file have been downloaded and what the currently playing position\nis. It builds a graph to display this information (sort of a text-mode\nuser interface) and prints it on screen, overwriting the previous one so\nit looks like it is animated:\nThe dashes ‘-’ indicate the downloaded parts, and the greater-than\nsign ‘>’ shows the current position (turning into an ‘X’ when the\npipeline is paused). Keep in mind that if your network is fast enough,\nyou will not see the download bar (the dashes) advance at all; it will\nbe completely full from the beginning.\nThe first thing we do in refresh_ui is construct a new Buffering\nGstQuery with gst_query_new_buffering() and pass it to the pipeline\n(playbin) with gst_element_query(). In Basic tutorial 4: Time management we have\nalready seen how to perform simple queries like Position and Duration\nusing specific methods. More complex queries, like Buffering, need to\nuse the more general gst_element_query().\nThe Buffering query can be made in different GstFormat (TIME, BYTES,\nPERCENTAGE and a few more). Not all elements can answer the query in all\nthe formats, so you need to check which ones are supported in your\nparticular pipeline. If gst_element_query() returns TRUE, the query\nsucceeded. The answer to the query is contained in the same\nGstQuery structure we created, and can be retrieved using multiple\nparse methods:\nData does not need to be downloaded in consecutive pieces from the\nbeginning of the file: Seeking, for example, might force to start\ndownloading from a new position and leave a downloaded chunk behind.\nTherefore, gst_query_get_n_buffering_ranges() returns the number of\nchunks, or ranges of downloaded data, and then, the position and size\nof each range is retrieved with gst_query_parse_nth_buffering_range().\nThe format of the returned values (start and stop position for each\nrange) depends on what we requested in the\ngst_query_new_buffering() call. In this case, PERCENTAGE. These\nvalues are used to generate the graph.\nNext, the current position is queried. It could be queried in the\nPERCENT format, so code similar to the one used for the ranges is used,\nbut currently this format is not well supported for position queries.\nInstead, we use the TIME format and also query the duration to obtain a\npercentage.\nThe current position is indicated with either a ‘>’ or an ‘X’\ndepending on the buffering level. If it is below 100%, the code in the\ncb_message method will have set the pipeline to PAUSED, so we print\nan ‘X’. If the buffering level is 100% the pipeline is in the\nPLAYING state and we print a ‘>’.\nFinally, if the buffering level is below 100%, we report this\ninformation (and delete it otherwise).\n"});