fragment_downloaded_cb({"url":"tutorials/ios/a-basic-media-player.html#seek-throttling","fragment":"Seek throttling\nA seek is potentially a lengthy operation. The demuxer (the element\ntypically in charge of seeking) needs to estimate the appropriate byte\noffset inside the media file that corresponds to the time position to\njump to. Then, it needs to start decoding from that point until the\ndesired position is reached. If the initial estimate is accurate, this\nwill not take long, but, on some container formats, or when indexing\ninformation is missing, it can take up to several seconds.\nIf a demuxer is in the process of performing a seek and receives a\nsecond one, it is up to it to finish the first one, start the second one\nor abort both, which is a bad thing. A simple method to avoid this issue\nis throttling, which means that we will only allow one seek every half\na second (for example): after performing a seek, only the last seek\nrequest received during the next 500ms is stored, and will be honored\nonce this period elapses.\nTo achieve this, all seek requests are routed through\nthe execute_seek() method:\nThe time at which the last seek was performed is stored in\nthe last_seek_time variable. This is wall clock time, not to be\nconfused with the stream time carried in the media time stamps, and is\nobtained with gst_util_get_timestamp().\nIf enough time has passed since the last seek operation, the new one is\ndirectly executed and last_seek_time is updated. Otherwise, the new\nseek is scheduled for later. If there is no previously scheduled seek, a\none-shot timer is setup to trigger 500ms after the last seek operation.\nIf another seek was already scheduled, its desired position is simply\nupdated with the new one.\nThe one-shot timer calls delayed_seek_cb(), which simply\ncalls execute_seek() again.\n\nIdeally, execute_seek() will now find that enough time has indeed passed since the last seek and the scheduled one will proceed. It might happen, though, that after 500ms of the previous seek, and before the timer wakes up, yet another seek comes through and is executed. delayed_seek_cb() needs to check for this condition to avoid performing two very close seeks, and therefore calls execute_seek() instead of performing the seek itself.\nThis is not a complete solution: the scheduled seek will still be executed, even though a more-recent seek has already been executed that should have cancelled it. However, it is a good tradeoff between functionality and simplicity.\n"});