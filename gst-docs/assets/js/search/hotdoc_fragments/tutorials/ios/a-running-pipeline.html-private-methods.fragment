fragment_downloaded_cb({"url":"tutorials/ios/a-running-pipeline.html#private-methods","fragment":"Private methods:\nsetUIMessage: turns the C strings that GStreamer uses (UTF8 char *)\ninto NSString * and displays them through the\ngstreamerSetUIMessage method of the GStreamerBackendDelegate. The\nimplementation of this method is marked as @optional, and hence the\ncheck for its existence in the delegate with respondsToSelector:\nThe error_cb() and state_changed_cb() are callbacks registered to\nthe error and state-changed events in GStreamer, and their goal is\nto inform the user about these events. These callbacks have been widely\nused in the Basic tutorials and their\nimplementation is very similar, except for two points:\nFirstly, the messages are conveyed to the user through the\nsetUIMessage: private method discussed above.\nSecondly, they require an instance of a GStreamerBackend object in\norder to call its instance method setUIMessage:, which is passed\nthrough the userdata pointer of the callbacks (the self pointer in\nthese implementations). This is discussed below when registering the\ncallbacks in the app_function.\ncheck_initialization_complete() verifies that all conditions are met\nto consider the backend ready to accept commands and tell the\napplication if so. In this simple tutorial the only conditions are that\nthe main loop exists and that we have not already told the application\nabout this fact. Later (more complex) tutorials include additional\nconditions.\nFinally, most of the GStreamer work is performed in the app_function.\nIt exists with almost identical content in the Android tutorial, which\nexemplifies how the same code can run on both platforms with little\nchange.\nIt first creates a GLib context so all GSources are kept in the same\nplace. This also helps cleaning after GSources created by other\nlibraries which might not have been properly disposed of. A new context\nis created with g_main_context_new() and then it is made the default\none for the thread with g_main_context_push_thread_default().\nIt then creates a pipeline the easy way, with gst_parse_launch(). In\nthis case, it is simply an  audiotestsrc (which produces a continuous\ntone) and an autoaudiosink, with accompanying adapter\nelements.\nThese lines create a bus signal watch and connect to some interesting\nsignals, just like we have been doing in the Basic\ntutorials. The creation of the watch is done\nstep by step instead of using gst_bus_add_signal_watch() to exemplify\nhow to use a custom GLib context. The interesting bit here is the usage\nof a\n__bridge\ncast to convert an Objective-C object into a plain C pointer. In this\ncase we do not worry much about transferal of ownership of the object,\nbecause it travels through C-land untouched. It re-emerges at the\ndifferent callbacks through the userdata pointer and cast again to a\nGStreamerBackend *.\nFinally, the main loop is created and set to run. Before entering the\nmain loop, though, check_initialization_complete() is called. Upon\nexit, the main loop is disposed of.\nAnd this is it! This has been a rather long tutorial, but we covered a\nlot of territory. Building on top of this one, the following ones are\nshorter and focus only on the new topics.\n"});