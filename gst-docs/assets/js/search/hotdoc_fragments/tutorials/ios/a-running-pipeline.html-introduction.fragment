fragment_downloaded_cb({"url":"tutorials/ios/a-running-pipeline.html#introduction","fragment":"Introduction\nWhen using a Graphical User Interface (UI), if the application waits for\nGStreamer calls to complete the user experience will suffer. The usual\napproach, with the GTK+ toolkit for example, is\nto relinquish control to a GLib GMainLoop and let it control the\nevents coming from the UI or GStreamer.\nOther graphical toolkits that are not based on GLib, like the Cocoa\nTouch\nframework used on iOS devices, cannot use this option, though. The\nsolution used in this tutorial uses a GLib GMainLoop for its\nsimplicity, but moves it to a separate thread (a Dispatch\nQueue\ndifferent than the main one) so it does not block the user interface\noperation.\nAdditionally, this tutorial shows a few places where caution has to be\ntaken when calling from Objective-C to C and vice versa.\nThe code below builds a pipeline with an audiotestsrc and\nan autoaudiosink (it plays an audible tone). Two buttons in the UI\nallow setting the pipeline to PLAYING or PAUSED. A Label in the UI shows\nmessages sent from the C code (for errors and state changes).\n"});