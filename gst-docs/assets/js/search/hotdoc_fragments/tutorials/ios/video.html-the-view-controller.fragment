fragment_downloaded_cb({"url":"tutorials/ios/video.html#the-view-controller","fragment":"The View Controller\nThe ViewControllerclass manages the UI, instantiates\nthe GStreamerBackend and also performs some UI-related tasks on its\nbehalf:\nViewController.m\nWe expand the class to remember the width and height of the media we are\ncurrently playing:\nIn later tutorials this data is retrieved from the GStreamer pipeline,\nbut in this tutorial, for simplicityâ€™s sake, the width and height of the\nmedia is constant and initialized in viewDidLoad:\nAs shown below, the GStreamerBackend constructor has also been\nexpanded to accept another parameter: the UIView * where the video\nsink should draw.\nThe rest of the ViewControllercode is the same as the previous\ntutorial, except for the code that adapts the video_view size to the\nmedia size, respecting its aspect ratio:\nThe viewDidLayoutSubviews method is called every time the main view\nsize has changed (for example, due to a device orientation change) and\nthe entire layout has been recalculated. At this point, we can access\nthe bounds property of the video_container_view to retrieve its new\nsize and change the video_view size accordingly.\nThe simple algorithm above maximizes either the width or the height of\nthe video_view, while changing the other axis so the aspect ratio of\nthe media is preserved. The goal is to provide the GStreamer video sink\nwith a surface of the correct proportions, so it does not need to add\nblack borders (letterboxing), which is a waste of processing power.\nThe final size is reported to the layout engine by changing the\nconstant field in the width and height Constraints of the\nvideo_view. These constraints have been created in the storyboard and\nare accessible to the ViewControllerthrough IBOutlets, as is usually\ndone with other widgets.\n"});