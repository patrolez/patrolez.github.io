fragment_downloaded_cb({"url":"tutorials/basic/streaming.html#walkthrough","fragment":"Walkthrough\nThe only special thing this tutorial does is react to certain messages;\ntherefore, the initialization code is very simple and should be\nself-explanatory by now. The only new bit is the detection of live\nstreams:\nLive streams cannot be paused, so they behave in PAUSED state as if they\nwere in the PLAYING state. Setting live streams to PAUSED succeeds, but\nreturns GST_STATE_CHANGE_NO_PREROLL, instead of\nGST_STATE_CHANGE_SUCCESS to indicate that this is a live stream. We\nare receiving the NO_PREROLL return code even though we are trying to\nset the pipeline to PLAYING, because state changes happen progressively\n(from NULL to READY, to PAUSED and then to PLAYING).\nWe care about live streams because we want to disable buffering for\nthem, so we take note of the result of gst_element_set_state() in the\nis_live variable.\nLetâ€™s now review the interesting parts of the message parsing callback:\nFirst, if this is a live source, ignore buffering messages.\nWe parse the buffering message with gst_message_parse_buffering() to\nretrieve the buffering level.\nThen, we print the buffering level on the console and set the pipeline\nto PAUSED if it is below 100%. Otherwise, we set the pipeline to\nPLAYING.\nAt startup, we will see the buffering level rise up to 100% before\nplayback starts, which is what we wanted to achieve. If, later on, the\nnetwork becomes slow or unresponsive and our buffer depletes, we will\nreceive new buffering messages with levels below 100% so we will pause\nthe pipeline again until enough buffer has been built up.\nFor the second network issue, the loss of clock, we simply set the\npipeline to PAUSED and back to PLAYING, so a new clock is selected,\nwaiting for new media chunks to be received if necessary.\n"});