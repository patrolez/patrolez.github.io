fragment_downloaded_cb({"url":"tutorials/basic/short-cutting-the-pipeline.html#introduction","fragment":"Introduction\nApplications can interact with the data flowing through a GStreamer\npipeline in several ways. This tutorial describes the easiest one, since\nit uses elements that have been created for this sole purpose.\nThe element used to inject application data into a GStreamer pipeline is\nappsrc, and its counterpart, used to extract GStreamer data back to\nthe application is appsink. To avoid confusing the names, think of it\nfrom GStreamer's point of view: appsrc is just a regular source, that\nprovides data magically fallen from the sky (provided by the\napplication, actually). appsink is a regular sink, where the data\nflowing through a GStreamer pipeline goes to die (it is recovered by the\napplication, actually).\nappsrc and appsink are so versatile that they offer their own API\n(see their documentation), which can be accessed by linking against the\ngstreamer-app library. In this tutorial, however, we will use a\nsimpler approach and control them through signals.\nappsrc can work in a variety of modes: in pull mode, it requests\ndata from the application every time it needs it. In push mode, the\napplication pushes data at its own pace. Furthermore, in push mode, the\napplication can choose to be blocked in the push function when enough\ndata has already been provided, or it can listen to the\nenough-data and need-data signals to control flow. This example\nimplements the latter approach. Information regarding the other methods\ncan be found in the appsrc documentation.\n"});