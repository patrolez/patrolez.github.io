fragment_downloaded_cb({"url":"tutorials/basic/multithreading-and-pad-availability.html#walkthrough","fragment":"Walkthrough\nAll the elements in the above picture are instantiated here:\naudiotestsrc produces a synthetic tone. wavescope consumes an audio\nsignal and renders a waveform as if it was an (admittedly cheap)\noscilloscope. We have already worked with the autoaudiosink and\nautovideosink.\nThe conversion elements (audioconvert, audioresample and\nvideoconvert) are necessary to guarantee that the pipeline can be\nlinked. Indeed, the Capabilities of the audio and video sinks depend on\nthe hardware, and you do not know at design time if they will match the\nCaps produced by the audiotestsrc and wavescope. If the Caps\nmatched, though, these elements act in “pass-through” mode and do not\nmodify the signal, having negligible impact on performance.\nSmall adjustments for better demonstration: The “freq” property of\naudiotestsrc controls the frequency of the wave (215Hz makes the wave\nappear almost stationary in the window), and this style and shader for\nwavescope make the wave continuous. Use the gst-inspect-1.0 tool\ndescribed in Basic tutorial 10: GStreamer\ntools to learn all\nthe properties of these\nelements.\nThis code block adds all elements to the pipeline and then links the\nones that can be automatically linked (the ones with Always Pads, as the\ncomment says).\n\ngst_element_link_many() can actually link elements with Request Pads. It internally requests the Pads so you do not have worry about the elements being linked having Always or Request Pads. Strange as it might seem, this is actually inconvenient, because you still need to release the requested Pads afterwards, and, if the Pad was requested automatically by gst_element_link_many(), it is easy to forget. Stay out of trouble by always requesting Request Pads manually, as shown in the next code block.\nTo link Request Pads, they need to be obtained by “requesting” them to\nthe element. An element might be able to produce different kinds of\nRequest Pads, so, when requesting them, the desired Pad Template name must be\nprovided.\nIn the documentation for the tee element we see that it has two pad\ntemplates named “sink” (for its sink Pads) and “src_%u” (for the Request\nPads). We request two Pads from the tee (for the\naudio and video branches) with gst_element_request_pad_simple().\nWe then obtain the Pads from the downstream elements to which these\nRequest Pads need to be linked. These are normal Always Pads, so we\nobtain them with gst_element_get_static_pad().\nFinally, we link the pads with gst_pad_link(). This is the function\nthat gst_element_link() and gst_element_link_many() use internally.\nThe sink Pads we have obtained need to be released with\ngst_object_unref(). The Request Pads will be released when we no\nlonger need them, at the end of the program.\nWe then set the pipeline to playing as usual, and wait until an error\nmessage or an EOS is produced. The only thing left to do is cleanup the\nrequested Pads:\ngst_element_release_request_pad() releases the pad from the tee, but\nit still needs to be unreferenced (freed) with gst_object_unref().\n"});