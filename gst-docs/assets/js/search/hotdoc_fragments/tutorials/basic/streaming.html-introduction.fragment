fragment_downloaded_cb({"url":"tutorials/basic/streaming.html#introduction","fragment":"Introduction\nWhen streaming, media chunks are decoded and queued for presentation as\nsoon as they arrive from the network. This means that if a chunk is\ndelayed (which is not an uncommon situation at all on the Internet) the\npresentation queue might run dry and media playback could stall.\nThe universal solution is to build a “buffer”, this is, allow a certain\nnumber of media chunks to be queued before starting playback. In this\nway, playback start is delayed a bit, but, if some chunks are late,\nreproduction is not impacted as there are more chunks in the queue,\nwaiting.\nAs it turns out, this solution is already implemented in GStreamer, but\nthe previous tutorials have not been benefiting from it. Some elements,\nlike the queue2 and multiqueue found inside playbin, are capable\nof building this buffer and post bus messages regarding the buffer level\n(the state of the queue). An application wanting to have more network\nresilience, then, should listen to these messages and pause playback if\nthe buffer level is not high enough (usually, whenever it is below\n100%).\nTo achieve synchronization among multiple sinks (for example an audio\nand a video sink) a global clock is used. This clock is selected by\nGStreamer among all elements which can provide one. Under some\ncircumstances, for example, an RTP source switching streams or changing\nthe output device, this clock can be lost and a new one needs to be\nselected. This happens mostly when dealing with streaming, so the\nprocess is explained in this tutorial.\nWhen the clock is lost, the application receives a message on the bus;\nto select a new one, the application just needs to set the pipeline to\nPAUSED and then to PLAYING again.\n"});