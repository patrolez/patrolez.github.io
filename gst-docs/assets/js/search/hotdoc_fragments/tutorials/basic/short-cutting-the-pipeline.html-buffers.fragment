fragment_downloaded_cb({"url":"tutorials/basic/short-cutting-the-pipeline.html#buffers","fragment":"Buffers\nData travels through a GStreamer pipeline in chunks called buffers.\nSince this example produces and consumes data, we need to know about\nGstBuffers.\nSource Pads produce buffers, that are consumed by Sink Pads; GStreamer\ntakes these buffers and passes them from element to element.\nA buffer simply represents a unit of data, do not assume that all\nbuffers will have the same size, or represent the same amount of time.\nNeither should you assume that if a single buffer enters an element, a\nsingle buffer will come out. Elements are free to do with the received\nbuffers as they please. GstBuffers may also contain more than one\nactual memory buffer. Actual memory buffers are abstracted away using\nGstMemory objects, and a GstBuffer can contain multiple GstMemory objects.\nEvery buffer has attached time-stamps and duration, that describe in\nwhich moment the content of the buffer should be decoded, rendered or\ndisplayed. Time stamping is a very complex and delicate subject, but\nthis simplified vision should suffice for now.\nAs an example, a filesrc (a GStreamer element that reads files)\nproduces buffers with the “ANY” caps and no time-stamping information.\nAfter demuxing (see Basic tutorial 3: Dynamic pipelines)\nbuffers can have some specific caps, for example “video/x-h264”. After\ndecoding, each buffer will contain a single video frame with raw caps\n(for example, “video/x-raw-yuv”) and very precise time stamps indicating\nwhen should that frame be displayed.\n"});