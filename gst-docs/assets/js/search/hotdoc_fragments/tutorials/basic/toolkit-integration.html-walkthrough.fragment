fragment_downloaded_cb({"url":"tutorials/basic/toolkit-integration.html#walkthrough","fragment":"Walkthrough\nRegarding this tutorial's structure, we are not going to use forward\nfunction definitions anymore: Functions will be defined before they are\nused. Also, for clarity of explanation, the order in which the snippets\nof code are presented will not always match the program order. Use the\nline numbers to locate the snippets in the complete code.\nThis tutorial is composed mostly of callback functions, which will be\ncalled from GStreamer or GTK+, so let's review the main function,\nwhich registers all these callbacks.\nStandard GStreamer initialization and playbin pipeline creation, along\nwith GTK initialization. We also create our video sink element which will render\ninto a GTK Widget. We will use this widget in our UI later on.\"\nWe are interested in being notified when new tags (metadata) appears on\nthe stream. For simplicity, we are going to handle all kinds of tags\n(video, audio and text) from the same callback tags_cb.\nAll GTK+ widget creation and signal registration happens in this\nfunction. It contains only GTK-related function calls, so we will skip\nover its definition. The signals to which it registers convey user\ncommands, as shown below when reviewing the\ncallbacks.\nIn Playback tutorial 1: Playbin usage, gst_bus_add_watch() is\nused to register a function that receives every message posted to the\nGStreamer bus. We can achieve a finer granularity by using signals\ninstead, which allow us to register only to the messages we are\ninterested in. By calling gst_bus_add_signal_watch() we instruct the\nbus to emit a signal every time it receives a message. This signal has\nthe name message::detail where detail is the message that\ntriggered the signal emission. For example, when the bus receives the\nEOS message, it emits a signal with the name message::eos.\nThis tutorial is using the Signals's details to register only to the\nmessages we care about. If we had registered to the message signal, we\nwould be notified of every single message, just like\ngst_bus_add_watch() would do.\nKeep in mind that, in order for the bus watches to work (be it a\ngst_bus_add_watch() or a gst_bus_add_signal_watch()), there must be\nGLib Main Loop running. In this case, it is hidden inside the\nGTK+ main loop.\nBefore transferring control to GTK+, we use g_timeout_add_seconds () to register yet another callback, this time with a timeout, so it\ngets called every second. We are going to use it to refresh the GUI from\nthe refresh_ui function.\nAfter this, we are done with the setup and can start the GTK+ main loop.\nWe will regain control from our callbacks when interesting things\nhappen. Let's review the callbacks. Each callback has a different\nsignature, depending on who will call it. You can look up the signature\n(the meaning of the parameters and the return value) in the\ndocumentation of the signal.\nThese three little callbacks are associated with the PLAY, PAUSE and\nSTOP buttons in the GUI. They simply set the pipeline to the\ncorresponding state. Note that in the STOP state we set the pipeline to\nREADY. We could have brought the pipeline all the way down to the\nNULL state, but, the transition would then be a little slower, since some\nresources (like the audio device) would need to be released and\nre-acquired.\ngtk_main_quit() will eventually make the call to to gtk_main_run()\nin main to terminate, which, in this case, finishes the program. Here,\nwe call it when the main window is closed, after stopping the pipeline\n(just for the sake of tidiness).\nThis is an example of how a complex GUI element like a seeker bar (or\nslider that allows seeking) can be very easily implemented thanks to\nGStreamer and GTK+ collaborating. If the slider has been dragged to a\nnew position, tell GStreamer to seek to that position\nwith gst_element_seek_simple() (as seen in Basic tutorial 4: Time\nmanagement). The\nslider has been setup so its value represents seconds.\nIt is worth mentioning that some performance (and responsiveness) can be\ngained by doing some throttling, this is, not responding to every single\nuser request to seek. Since the seek operation is bound to take some\ntime, it is often nicer to wait half a second (for example) after a seek\nbefore allowing another one. Otherwise, the application might look\nunresponsive if the user drags the slider frantically, which would not\nallow any seek to complete before a new one is queued.\nThis function will move the slider to reflect the current position of\nthe media. First off, if we are not in the PLAYING state, we have\nnothing to do here (plus, position and duration queries will normally\nfail).\nWe recover the duration of the clip if we didn't know it, so we can set\nthe range for the slider.\nWe query the current pipeline position, and set the position of the\nslider accordingly. This would trigger the emission of the\nvalue-changed signal, which we use to know when the user is dragging\nthe slider. Since we do not want seeks happening unless the user\nrequested them, we disable the value-changed signal emission during\nthis operation with g_signal_handler_block() and\ng_signal_handler_unblock().\nReturning TRUE from this function will keep it called in the future. If\nwe return FALSE, the timer will be\nremoved.\nThis is one of the key points of this tutorial. This function will be\ncalled when new tags are found in the media, from a streaming\nthread, this is, from a thread other than the application (or main)\nthread. What we want to do here is to update a GTK+ widget to reflect\nthis new information, but GTK+ does not allow operating from threads\nother than the main one.\nThe solution is to make playbin post a message on the bus and return\nto the calling thread. When appropriate, the main thread will pick up\nthis message and update GTK.\ngst_element_post_message() makes a GStreamer element post the given\nmessage to the bus. gst_message_new_application() creates a new\nmessage of the APPLICATION type. GStreamer messages have different\ntypes, and this particular type is reserved to the application: it will\ngo through the bus unaffected by GStreamer. The list of types can be\nfound in the GstMessageType documentation.\nMessages can deliver additional information through their embedded\nGstStructure, which is a very flexible data container. Here, we create\na new structure with gst_structure_new(), and name it tags-changed, to\navoid confusion in case we wanted to send other application messages.\nLater, once in the main thread, the bus will receive this message and\nemit the message::application signal, which we have associated to the\napplication_cb function:\nOnce me made sure it is the tags-changed message, we call the\nanalyze_streams function, which is also used in Playback tutorial 1: Playbin usage and is\nmore detailed there. It basically recovers the tags from the stream and\nwrites them in a text widget in the GUI.\nThe error_cb, eos_cb and state_changed_cb are not really worth\nexplaining, since they do the same as in all previous tutorials, but\nfrom their own function now.\nAnd this is it! The amount of code in this tutorial might seem daunting\nbut the required concepts are few and easy. If you have followed the\nprevious tutorials and have a little knowledge of GTK, you probably\nunderstood this one can now enjoy your very own media player!\n\n"});