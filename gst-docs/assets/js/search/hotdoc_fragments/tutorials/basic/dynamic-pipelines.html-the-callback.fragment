fragment_downloaded_cb({"url":"tutorials/basic/dynamic-pipelines.html#the-callback","fragment":"The callback\nWhen our source element finally has enough information to start\nproducing data, it will create source pads, and trigger the “pad-added”\nsignal. At this point our callback will be\ncalled:\nsrc is the GstElement which triggered the signal. In this example,\nit can only be the uridecodebin, since it is the only signal to which\nwe have attached. The first parameter of a signal handler is always the object\nthat has triggered it.\nnew_pad is the GstPad that has just been added to the src element.\nThis is usually the pad to which we want to link.\ndata is the pointer we provided when attaching to the signal. In this\nexample, we use it to pass the CustomData pointer.\nFrom CustomData we extract the converter element, and then retrieve\nits sink pad using gst_element_get_static_pad (). This is the pad to\nwhich we want to link new_pad. In the previous tutorial we linked\nelement against element, and let GStreamer choose the appropriate pads.\nNow we are going to link the pads directly.\nuridecodebin can create as many pads as it sees fit, and for each one,\nthis callback will be called. These lines of code will prevent us from\ntrying to link to a new pad once we are already linked.\nNow we will check the type of data this new pad is going to output, because we\nare only interested in pads producing audio. We have previously created a\npiece of pipeline which deals with audio (an audioconvert linked with an\naudioresample and an autoaudiosink), and we will not be able to link it to\na pad producing video, for example.\ngst_pad_get_current_caps() retrieves the current capabilities of the pad\n(that is, the kind of data it currently outputs), wrapped in a GstCaps\nstructure. All possible caps a pad can support can be queried with\ngst_pad_query_caps(). A pad can offer many capabilities, and hence GstCaps\ncan contain many GstStructure, each representing a different capability. The\ncurrent caps on a pad will always have a single GstStructure and represent a\nsingle media format, or if there are no current caps yet NULL will be\nreturned.\nSince, in this case, we know that the pad we want only had one\ncapability (audio), we retrieve the first GstStructure with\ngst_caps_get_structure().\nFinally, with gst_structure_get_name() we recover the name of the\nstructure, which contains the main description of the format (its media\ntype, actually).\nIf the name is not audio/x-raw, this is not a decoded\naudio pad, and we are not interested in it.\nOtherwise, attempt the link:\ngst_pad_link() tries to link two pads. As it was the case\nwith gst_element_link(), the link must be specified from source to\nsink, and both pads must be owned by elements residing in the same bin\n(or pipeline).\nAnd we are done! When a pad of the right kind appears, it will be\nlinked to the rest of the audio-processing pipeline and execution will\ncontinue until ERROR or EOS. However, we will squeeze a bit more content\nfrom this tutorial by also introducing the concept of State.\n"});