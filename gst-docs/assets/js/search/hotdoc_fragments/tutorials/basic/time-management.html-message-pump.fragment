fragment_downloaded_cb({"url":"tutorials/basic/time-management.html#message-pump","fragment":"Message Pump\nThe handle_message function processes all messages received through\nthe pipeline's bus. ERROR and EOS handling is the same as in previous\ntutorials, so we skip to the interesting part:\nThis message is posted on the bus whenever the duration of the stream\nchanges. Here we simply mark the current duration as invalid, so it gets\nre-queried later.\nSeeks and time queries generally only get a valid reply when in the\nPAUSED or PLAYING state, since all elements have had a chance to\nreceive information and configure themselves. Here, we use the playing\nvariable to keep track of whether the pipeline is in PLAYING state.\nAlso, if we have just entered the PLAYING state, we do our first query.\nWe ask the pipeline if seeking is allowed on this stream:\ngst_query_new_seeking() creates a new query object of the \"seeking\"\ntype, with GST_FORMAT_TIME format. This indicates that we are\ninterested in seeking by specifying the new time to which we want to\nmove. We could also ask for GST_FORMAT_BYTES, and then seek to a\nparticular byte position inside the source file, but this is normally\nless useful.\nThis query object is then passed to the pipeline with\ngst_element_query(). The result is stored in the same query, and can\nbe easily retrieved with gst_query_parse_seeking(). It extracts a\nboolean indicating if seeking is allowed, and the range in which seeking\nis possible.\nDon't forget to unref the query object when you are done with it.\nAnd that's it! With this knowledge a media player can be built which\nperiodically updates a slider based on the current stream position and\nallows seeking by moving the slider!\n"});