fragment_downloaded_cb({"url":"tutorials/basic/dynamic-pipelines.html#introduction","fragment":"Introduction\nAs you are about to see, the pipeline in this tutorial is not\ncompletely built before it is set to the playing state. This is OK. If\nwe did not take further action, data would reach the end of the\npipeline and the pipeline would produce an error message and stop. But\nwe are going to take further action...\nIn this example we are opening a file which is multiplexed (or muxed),\nthis is, audio and video are stored together inside a container file.\nThe elements responsible for opening such containers are called\ndemuxers, and some examples of container formats are Matroska (MKV),\nQuick Time (QT, MOV), Ogg, or Advanced Systems Format (ASF, WMV, WMA).\nIf a container embeds multiple streams (one video and two audio tracks,\nfor example), the demuxer will separate them and expose them through\ndifferent output ports. In this way, different branches can be created\nin the pipeline, dealing with different types of data.\nThe ports through which GStreamer elements communicate with each other\nare called pads (GstPad). There exists sink pads, through which data\nenters an element, and source pads, through which data exits an element.\nIt follows naturally that source elements only contain source pads, sink\nelements only contain sink pads, and filter elements contain\nboth.\n  \nFigure 1. GStreamer elements with their pads.\nA demuxer contains one sink pad, through which the muxed data arrives,\nand multiple source pads, one for each stream found in the container:\n\nFigure 2. A demuxer with two source pads.\nFor completeness, here you have a simplified pipeline containing a\ndemuxer and two branches, one for audio and one for video. This is\nNOT the pipeline that will be built in this example:\n\nFigure 3. Example pipeline with two branches.\nThe main complexity when dealing with demuxers is that they cannot\nproduce any information until they have received some data and have had\na chance to look at the container to see what is inside. This is,\ndemuxers start with no source pads to which other elements can link, and\nthus the pipeline must necessarily terminate at them.\nThe solution is to build the pipeline from the source down to the\ndemuxer, and set it to run (play). When the demuxer has received enough\ninformation to know about the number and kind of streams in the\ncontainer, it will start creating source pads. This is the right time\nfor us to finish building the pipeline and attach it to the newly added\ndemuxer pads.\nFor simplicity, in this example, we will only link to the audio pad and\nignore the video.\n"});