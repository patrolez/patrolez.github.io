fragment_downloaded_cb({"url":"tutorials/basic/short-cutting-the-pipeline.html#walkthrough","fragment":"Walkthrough\nThe code to create the pipeline (Lines 131 to 205) is an enlarged\nversion of Basic tutorial 7: Multithreading and Pad\nAvailability.\nIt involves instantiating all the elements, link the elements with\nAlways Pads, and manually link the Request Pads of the tee element.\nRegarding the configuration of the appsrc and appsink elements:\nThe first property that needs to be set on the appsrc is caps. It\nspecifies the kind of data that the element is going to produce, so\nGStreamer can check if linking with downstream elements is possible\n(this is, if the downstream elements will understand this kind of data).\nThis property must be a GstCaps object, which is easily built from a\nstring with gst_caps_from_string().\nWe then connect to the need-data and enough-data signals. These are\nfired by appsrc when its internal queue of data is running low or\nalmost full, respectively. We will use these signals to start and stop\n(respectively) our signal generation process.\nRegarding the appsink configuration, we connect to the\nnew-sample signal, which is emitted every time the sink receives a\nbuffer. Also, the signal emission needs to be enabled through the\nemit-signals property, because, by default, it is disabled.\nStarting the pipeline, waiting for messages and final cleanup is done as\nusual. Let's review the callbacks we have just\nregistered:\nThis function is called when the internal queue of appsrc is about to\nstarve (run out of data). The only thing we do here is register a GLib\nidle function with g_idle_add() that feeds data to appsrc until it\nis full again. A GLib idle function is a method that GLib will call from\nits main loop whenever it is “idle”, this is, when it has no\nhigher-priority tasks to perform. It requires a GLib GMainLoop to be\ninstantiated and running, obviously.\nThis is only one of the multiple approaches that appsrc allows. In\nparticular, buffers do not need to be fed into appsrc from the main\nthread using GLib, and you do not need to use the need-data and\nenough-data signals to synchronize with appsrc (although this is\nallegedly the most convenient).\nWe take note of the sourceid that g_idle_add() returns, so we can\ndisable it\nlater.\nThis function is called when the internal queue of appsrc is full\nenough so we stop pushing data. Here we simply remove the idle function\nby using g_source_remove() (The idle function is implemented as a\nGSource).\nThis is the function that feeds appsrc. It will be called by GLib at\ntimes and rates which are out of our control, but we know that we will\ndisable it when its job is done (when the queue in appsrc is full).\nIts first task is to create a new buffer with a given size (in this\nexample, it is arbitrarily set to 1024 bytes) with\ngst_buffer_new_and_alloc().\nWe count the number of samples that we have generated so far with the\nCustomData.num_samples variable, so we can time-stamp this buffer\nusing the GST_BUFFER_TIMESTAMP macro in GstBuffer.\nSince we are producing buffers of the same size, their duration is the\nsame and is set using the GST_BUFFER_DURATION in GstBuffer.\ngst_util_uint64_scale() is a utility function that scales (multiply\nand divide) numbers which can be large, without fear of overflows.\nIn order access the memory of the buffer you first have to map it with\ngst_buffer_map(), which will give you a pointer and a size inside the\nGstMapInfo structure which gst_buffer_map() will populate on success.\nBe careful not to write past the end of the buffer: you allocated it,\nso you know its size in bytes and samples.\nWe will skip over the waveform generation, since it is outside the scope\nof this tutorial (it is simply a funny way of generating a pretty\npsychedelic wave).\nNote that there is also gst_app_src_push_buffer() as part of the\ngstreamer-app-1.0 library, which is perhaps a better function to use\nto push a buffer into appsrc than the signal emission above, because it has\na proper type signature so it's harder to get wrong. However, be aware\nthat if you use gst_app_src_push_buffer() it will take ownership of the\nbuffer passed instead, so in that case you won't have to unref it after pushing.\nOnce we have the buffer ready, we pass it to appsrc with the\npush-buffer action signal (see information box at the end of Playback tutorial 1: Playbin usage), and then\ngst_buffer_unref() it since we no longer need it.\nFinally, this is the function that gets called when the\nappsink receives a buffer. We use the pull-sample action signal to\nretrieve the buffer and then just print some indicator on the screen.\nNote that there is also gst_app_src_pull_sample() as part of the\ngstreamer-app-1.0 library, which is perhaps a better function to use\nto pull a sample/buffer out of an appsink than the signal emission above,\nbecause it has a proper type signature so it's harder to get wrong.\nIn order to get to the data pointer we need to use gst_buffer_map() just\nlike above, which will populate a GstMapInfo helper struct with a pointer to\nthe data and the size of the data in bytes. Don't forget to gst_buffer_unmap()\nthe buffer again when done with the data.\nRemember that this buffer does not have to match the buffer that we produced in\nthe push_data function, any element in the path could have altered the\nbuffers in any way (Not in this example: there is only a tee in the\npath between appsrc and appsink, and the tee does not change the content\nof the buffers).\nWe then gst_sample_unref() the retrieved sample, and this tutorial is done.\n"});