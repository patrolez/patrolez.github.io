fragment_downloaded_cb({"url":"audio/audio-buffer.html#gst_audio_buffer_map","fragment":"\n\tgst_audio_buffer_map\n\n\n\tGstAudio.prototype.audio_buffer_map\n\n\n\tGstAudio.audio_buffer_map\n\nMaps an audio gstbuffer so that it can be read or written and stores the\nresult of the map operation in buffer.\nThis is especially useful when the gstbuffer is in non-interleaved (planar)\nlayout, in which case this function will use the information in the\ngstbuffer's attached GstAudioMeta in order to map each channel in a\nseparate \"plane\" in GstAudioBuffer. If a GstAudioMeta is not attached\non the gstbuffer, then it must be in interleaved layout.\nIf a GstAudioMeta is attached, then the GstAudioInfo on the meta is checked\nagainst info. Normally, they should be equal, but in case they are not,\na g_critical will be printed and the GstAudioInfo from the meta will be\nused.\nIn non-interleaved buffers, it is possible to have each channel on a separate\nGstMemory. In this case, each memory will be mapped separately to avoid\ncopying their contents in a larger memory area. Do note though that it is\nnot supported to have a single channel spanning over two or more different\nGstMemory objects. Although the map operation will likely succeed in this\ncase, it will be highly sub-optimal and it is recommended to merge all the\nmemories in the buffer before calling this function.\nNote: The actual GstBuffer is not ref'ed, but it is required to stay valid\nas long as it's mapped.\nParameters:\npointer to a GstAudioBuffer\nthe audio properties of the buffer\nthe GstBuffer to be mapped\nthe access mode for the memory\nTRUE if the map operation succeeded or FALSE on failure\n\n\tSince\t\t\t: 1.16\n\t\t\nMaps an audio gstbuffer so that it can be read or written and stores the\nresult of the map operation in buffer.\nThis is especially useful when the gstbuffer is in non-interleaved (planar)\nlayout, in which case this function will use the information in the\ngstbuffer's attached GstAudio.AudioMeta in order to map each channel in a\nseparate \"plane\" in GstAudio.AudioBuffer. If a GstAudio.AudioMeta is not attached\non the gstbuffer, then it must be in interleaved layout.\nIf a GstAudio.AudioMeta is attached, then the GstAudio.AudioInfo on the meta is checked\nagainst info. Normally, they should be equal, but in case they are not,\na g_critical will be printed and the GstAudio.AudioInfo from the meta will be\nused.\nIn non-interleaved buffers, it is possible to have each channel on a separate\nGst.Memory. In this case, each memory will be mapped separately to avoid\ncopying their contents in a larger memory area. Do note though that it is\nnot supported to have a single channel spanning over two or more different\nGst.Memory objects. Although the map operation will likely succeed in this\ncase, it will be highly sub-optimal and it is recommended to merge all the\nmemories in the buffer before calling this function.\nNote: The actual Gst.Buffer is not ref'ed, but it is required to stay valid\nas long as it's mapped.\nParameters:\nthe audio properties of the buffer\nthe Gst.Buffer to be mapped\nthe access mode for the memory\nReturns a tuple made of:\ntrue if the map operation succeeded or false on failure\ntrue if the map operation succeeded or false on failure\n\n\tSince\t\t\t: 1.16\n\t\t\nMaps an audio gstbuffer so that it can be read or written and stores the\nresult of the map operation in buffer.\nThis is especially useful when the gstbuffer is in non-interleaved (planar)\nlayout, in which case this function will use the information in the\ngstbuffer's attached GstAudio.AudioMeta in order to map each channel in a\nseparate \"plane\" in GstAudio.AudioBuffer. If a GstAudio.AudioMeta is not attached\non the gstbuffer, then it must be in interleaved layout.\nIf a GstAudio.AudioMeta is attached, then the GstAudio.AudioInfo on the meta is checked\nagainst info. Normally, they should be equal, but in case they are not,\na g_critical will be printed and the GstAudio.AudioInfo from the meta will be\nused.\nIn non-interleaved buffers, it is possible to have each channel on a separate\nGst.Memory. In this case, each memory will be mapped separately to avoid\ncopying their contents in a larger memory area. Do note though that it is\nnot supported to have a single channel spanning over two or more different\nGst.Memory objects. Although the map operation will likely succeed in this\ncase, it will be highly sub-optimal and it is recommended to merge all the\nmemories in the buffer before calling this function.\nNote: The actual Gst.Buffer is not ref'ed, but it is required to stay valid\nas long as it's mapped.\nParameters:\nthe audio properties of the buffer\nthe Gst.Buffer to be mapped\nthe access mode for the memory\nReturns a tuple made of:\nTrue if the map operation succeeded or False on failure\nTrue if the map operation succeeded or False on failure\n\n\tSince\t\t\t: 1.16\n\t\t\n"});