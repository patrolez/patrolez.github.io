fragment_downloaded_cb({"url":"audio/gstdsd.html#GstDsdPlaneOffsetMeta","fragment":"\n\tGstDsdPlaneOffsetMeta\n\nMembers\n\n\tGstAudio.DsdPlaneOffsetMeta\n\nMembers\n\n\tGstAudio.DsdPlaneOffsetMeta\n\nMembers\nBuffer metadata describing planar DSD contents in the buffer. This is not needed\nfor interleaved DSD data, and is required for non-interleaved (= planar) data.\nThe different channels in offsets are always in the GStreamer channel order.\nZero-copy channel reordering can be implemented by swapping the values in\noffsets.\nIt is not allowed for channels to overlap in memory,\ni.e. for each i in [0, channels), the range\n[@offsets[i], offsets[i] + num_bytes_per_channel) must not overlap\nwith any other such range.\nIt is, however, allowed to have parts of the buffer memory unused, by using\noffsets and num_bytes_per_channel in such a way that leave gaps on it.\nThis is used to implement zero-copy clipping in non-interleaved buffers.\nObviously, due to the above, it is not safe to infer the\nnumber of valid bytes from the size of the buffer. You should always\nuse the num_bytes_per_channel variable of this metadata.\nparent GstMeta\nnumber of channels in the DSD data\nthe number of valid bytes per channel in the buffer\nthe offsets (in bytes) where each channel plane starts in the buffer\n\n\tSince\t\t\t: 1.24\n\t\t\nBuffer metadata describing planar DSD contents in the buffer. This is not needed\nfor interleaved DSD data, and is required for non-interleaved (= planar) data.\nThe different channels in offsets are always in the GStreamer channel order.\nZero-copy channel reordering can be implemented by swapping the values in\noffsets.\nIt is not allowed for channels to overlap in memory,\ni.e. for each i in [0, channels), the range\n[@offsets[i], offsets[i] + num_bytes_per_channel) must not overlap\nwith any other such range.\nIt is, however, allowed to have parts of the buffer memory unused, by using\noffsets and num_bytes_per_channel in such a way that leave gaps on it.\nThis is used to implement zero-copy clipping in non-interleaved buffers.\nObviously, due to the above, it is not safe to infer the\nnumber of valid bytes from the size of the buffer. You should always\nuse the num_bytes_per_channel variable of this metadata.\nparent Gst.Meta\nnumber of channels in the DSD data\nthe number of valid bytes per channel in the buffer\nthe offsets (in bytes) where each channel plane starts in the buffer\n\n\tSince\t\t\t: 1.24\n\t\t\nBuffer metadata describing planar DSD contents in the buffer. This is not needed\nfor interleaved DSD data, and is required for non-interleaved (= planar) data.\nThe different channels in offsets are always in the GStreamer channel order.\nZero-copy channel reordering can be implemented by swapping the values in\noffsets.\nIt is not allowed for channels to overlap in memory,\ni.e. for each i in [0, channels), the range\n[@offsets[i], offsets[i] + num_bytes_per_channel) must not overlap\nwith any other such range.\nIt is, however, allowed to have parts of the buffer memory unused, by using\noffsets and num_bytes_per_channel in such a way that leave gaps on it.\nThis is used to implement zero-copy clipping in non-interleaved buffers.\nObviously, due to the above, it is not safe to infer the\nnumber of valid bytes from the size of the buffer. You should always\nuse the num_bytes_per_channel variable of this metadata.\nparent Gst.Meta\nnumber of channels in the DSD data\nthe number of valid bytes per channel in the buffer\nthe offsets (in bytes) where each channel plane starts in the buffer\n\n\tSince\t\t\t: 1.24\n\t\t\n"});