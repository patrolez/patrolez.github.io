fragment_downloaded_cb({"url":"audio/gstaudiometa.html#GstAudioMeta","fragment":"\n\tGstAudioMeta\n\nMembers\n\n\tGstAudio.AudioMeta\n\nMembers\n\n\tGstAudio.AudioMeta\n\nMembers\nBuffer metadata describing how data is laid out inside the buffer. This\nis useful for non-interleaved (planar) buffers, where it is necessary to\nhave a place to store where each plane starts and how long each plane is.\nIt is a requirement for non-interleaved buffers to have this metadata\nattached and to be mapped with gst_audio_buffer_map in order to ensure\ncorrect handling of clipping and channel reordering.\nThe different channels in offsets are always in the GStreamer channel order.\nZero-copy channel reordering can be implemented by swapping the values in\noffsets.\nIt is not allowed for channels to overlap in memory,\ni.e. for each i in [0, channels), the range\n[@offsets[i], offsets[i] + samples * sample_stride) must not overlap\nwith any other such range.\nIt is, however, allowed to have parts of the buffer memory unused,\nby using offsets and samples in such a way that leave gaps on it.\nThis is used to implement zero-copy clipping in non-interleaved buffers.\nObviously, due to the above, it is not safe to infer the\nnumber of valid samples from the size of the buffer. You should always\nuse the samples variable of this metadata.\nNote that for interleaved audio it is not a requirement to have this\nmetadata attached and at the moment of writing, there is actually no use\ncase to do so. It is, however, allowed to attach it, for some potential\nfuture use case.\nSince 1.24 it can be serialized using gst_meta_serialize and\ngst_meta_deserialize.\nparent GstMeta\nthe audio properties of the buffer\nthe number of valid samples in the buffer\nthe offsets (in bytes) where each channel plane starts in the\nbuffer or NULL if the buffer has interleaved layout; if not NULL, this\nis guaranteed to be an array of info.channels elements\n\n\tSince\t\t\t: 1.16\n\t\t\nBuffer metadata describing how data is laid out inside the buffer. This\nis useful for non-interleaved (planar) buffers, where it is necessary to\nhave a place to store where each plane starts and how long each plane is.\nIt is a requirement for non-interleaved buffers to have this metadata\nattached and to be mapped with GstAudio.prototype.audio_buffer_map in order to ensure\ncorrect handling of clipping and channel reordering.\nThe different channels in offsets are always in the GStreamer channel order.\nZero-copy channel reordering can be implemented by swapping the values in\noffsets.\nIt is not allowed for channels to overlap in memory,\ni.e. for each i in [0, channels), the range\n[@offsets[i], offsets[i] + samples * sample_stride) must not overlap\nwith any other such range.\nIt is, however, allowed to have parts of the buffer memory unused,\nby using offsets and samples in such a way that leave gaps on it.\nThis is used to implement zero-copy clipping in non-interleaved buffers.\nObviously, due to the above, it is not safe to infer the\nnumber of valid samples from the size of the buffer. You should always\nuse the samples variable of this metadata.\nNote that for interleaved audio it is not a requirement to have this\nmetadata attached and at the moment of writing, there is actually no use\ncase to do so. It is, however, allowed to attach it, for some potential\nfuture use case.\nSince 1.24 it can be serialized using Gst.Meta.prototype.serialize and\nGst.prototype.meta_deserialize.\nparent Gst.Meta\nthe audio properties of the buffer\nthe number of valid samples in the buffer\nthe offsets (in bytes) where each channel plane starts in the\nbuffer or null if the buffer has interleaved layout; if not null, this\nis guaranteed to be an array of info.channels elements\n\n\tSince\t\t\t: 1.16\n\t\t\nBuffer metadata describing how data is laid out inside the buffer. This\nis useful for non-interleaved (planar) buffers, where it is necessary to\nhave a place to store where each plane starts and how long each plane is.\nIt is a requirement for non-interleaved buffers to have this metadata\nattached and to be mapped with GstAudio.audio_buffer_map in order to ensure\ncorrect handling of clipping and channel reordering.\nThe different channels in offsets are always in the GStreamer channel order.\nZero-copy channel reordering can be implemented by swapping the values in\noffsets.\nIt is not allowed for channels to overlap in memory,\ni.e. for each i in [0, channels), the range\n[@offsets[i], offsets[i] + samples * sample_stride) must not overlap\nwith any other such range.\nIt is, however, allowed to have parts of the buffer memory unused,\nby using offsets and samples in such a way that leave gaps on it.\nThis is used to implement zero-copy clipping in non-interleaved buffers.\nObviously, due to the above, it is not safe to infer the\nnumber of valid samples from the size of the buffer. You should always\nuse the samples variable of this metadata.\nNote that for interleaved audio it is not a requirement to have this\nmetadata attached and at the moment of writing, there is actually no use\ncase to do so. It is, however, allowed to attach it, for some potential\nfuture use case.\nSince 1.24 it can be serialized using Gst.Meta.serialize and\nGst.meta_deserialize.\nparent Gst.Meta\nthe audio properties of the buffer\nthe number of valid samples in the buffer\nthe offsets (in bytes) where each channel plane starts in the\nbuffer or None if the buffer has interleaved layout; if not None, this\nis guaranteed to be an array of info.channels elements\n\n\tSince\t\t\t: 1.16\n\t\t\n"});