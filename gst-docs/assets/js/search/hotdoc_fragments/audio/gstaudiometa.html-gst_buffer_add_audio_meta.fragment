fragment_downloaded_cb({"url":"audio/gstaudiometa.html#gst_buffer_add_audio_meta","fragment":"\n\tgst_buffer_add_audio_meta\n\n\n\tGstAudio.prototype.buffer_add_audio_meta\n\n\n\tGstAudio.buffer_add_audio_meta\n\nAllocates and attaches a GstAudioMeta on buffer, which must be writable\nfor that purpose. The fields of the GstAudioMeta are directly populated\nfrom the arguments of this function.\nWhen info->layout is GST_AUDIO_LAYOUT_NON_INTERLEAVED and offsets is\nNULL, the offsets are calculated with a formula that assumes the planes are\ntightly packed and in sequence:\noffsets[channel] = channel * samples * sample_stride\nIt is not allowed for channels to overlap in memory,\ni.e. for each i in [0, channels), the range\n[@offsets[i], offsets[i] + samples * sample_stride) must not overlap\nwith any other such range. This function will assert if the parameters\nspecified cause this restriction to be violated.\nIt is, obviously, also not allowed to specify parameters that would cause\nout-of-bounds memory access on buffer. This is also checked, which means\nthat you must add enough memory on the buffer before adding this meta.\nParameters:\na GstBuffer\nthe audio properties of the buffer\nthe number of valid samples in the buffer\nthe offsets (in bytes) where each channel plane starts\nin the buffer or NULL to calculate it (see below); must be NULL also\nwhen info->layout is GST_AUDIO_LAYOUT_INTERLEAVED\nthe GstAudioMeta that was attached on the buffer\n\n\tSince\t\t\t: 1.16\n\t\t\nAllocates and attaches a GstAudio.AudioMeta on buffer, which must be writable\nfor that purpose. The fields of the GstAudio.AudioMeta are directly populated\nfrom the arguments of this function.\nWhen info->layout is GstAudio.AudioLayout.NON_INTERLEAVED and offsets is\nnull, the offsets are calculated with a formula that assumes the planes are\ntightly packed and in sequence:\noffsets[channel] = channel * samples * sample_stride\nIt is not allowed for channels to overlap in memory,\ni.e. for each i in [0, channels), the range\n[@offsets[i], offsets[i] + samples * sample_stride) must not overlap\nwith any other such range. This function will assert if the parameters\nspecified cause this restriction to be violated.\nIt is, obviously, also not allowed to specify parameters that would cause\nout-of-bounds memory access on buffer. This is also checked, which means\nthat you must add enough memory on the buffer before adding this meta.\nParameters:\na Gst.Buffer\nthe audio properties of the buffer\nthe number of valid samples in the buffer\nthe offsets (in bytes) where each channel plane starts\nin the buffer or null to calculate it (see below); must be null also\nwhen info->layout is GstAudio.AudioLayout.INTERLEAVED\nthe GstAudio.AudioMeta that was attached on the buffer\n\n\tSince\t\t\t: 1.16\n\t\t\nAllocates and attaches a GstAudio.AudioMeta on buffer, which must be writable\nfor that purpose. The fields of the GstAudio.AudioMeta are directly populated\nfrom the arguments of this function.\nWhen info->layout is GstAudio.AudioLayout.NON_INTERLEAVED and offsets is\nNone, the offsets are calculated with a formula that assumes the planes are\ntightly packed and in sequence:\noffsets[channel] = channel * samples * sample_stride\nIt is not allowed for channels to overlap in memory,\ni.e. for each i in [0, channels), the range\n[@offsets[i], offsets[i] + samples * sample_stride) must not overlap\nwith any other such range. This function will assert if the parameters\nspecified cause this restriction to be violated.\nIt is, obviously, also not allowed to specify parameters that would cause\nout-of-bounds memory access on buffer. This is also checked, which means\nthat you must add enough memory on the buffer before adding this meta.\nParameters:\na Gst.Buffer\nthe audio properties of the buffer\nthe number of valid samples in the buffer\nthe offsets (in bytes) where each channel plane starts\nin the buffer or None to calculate it (see below); must be None also\nwhen info->layout is GstAudio.AudioLayout.INTERLEAVED\nthe GstAudio.AudioMeta that was attached on the buffer\n\n\tSince\t\t\t: 1.16\n\t\t\n"});