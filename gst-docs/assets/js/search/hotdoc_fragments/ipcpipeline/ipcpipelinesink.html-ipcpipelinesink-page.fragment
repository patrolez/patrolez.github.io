fragment_downloaded_cb({"url":"ipcpipeline/ipcpipelinesink.html#ipcpipelinesink-page","fragment":"ipcpipelinesink\nCommunicates with an ipcpipelinesrc element in another process via a socket.\nThis element, together with ipcpipelinesrc and ipcslavepipeline form a\nmechanism that allows splitting a single pipeline in different processes.\nThe main use-case for it is a playback pipeline split in two parts, where the\nfirst part contains the networking, parsing and demuxing and the second part\ncontains the decoding and display. The intention of this split is to improve\nsecurity of an application, by letting the networking, parsing and demuxing\nparts run in a less privileged process than the process that accesses the\ndecoder and display.\nOnce the pipelines in those different processes have been created, the\nplayback can be controlled entirely from the first pipeline, which is the\none that contains ipcpipelinesink. We call this pipeline the “master”.\nAll relevant events and queries sent from the application are sent to\nthe master pipeline and messages to the application are sent from the master\npipeline. The second pipeline, in the other process, is transparently slaved.\nipcpipelinesink can work only in push mode and does not synchronize buffers\nto the clock. Synchronization is meant to happen either at the real sink at\nthe end of the remote slave pipeline, or not to happen at all, if the\npipeline is live.\nA master pipeline may contain more than one ipcpipelinesink elements, which\ncan be connected either to the same slave pipeline or to different ones.\nCommunication with ipcpipelinesrc on the slave happens via a socket, using a\ncustom protocol. Each buffer, event, query, message or state change is\nserialized in a \"packet\" and sent over the socket. The sender then\nperforms a blocking wait for a reply, if a return code is needed.\nAll objects that contain a GstStructure (messages, queries, events) are\nserialized by serializing the GstStructure to a string\n(gst_structure_to_string). This implies some limitations, of course.\nAll fields of this structures that are not serializable to strings (ex.\nobject pointers) are ignored, except for some cases where custom\nserialization may occur (ex error/warning/info messages that contain a\nGError are serialized differently).\nBuffers are transported by writing their content directly on the socket.\nMore efficient ways for memory sharing could be implemented in the future.\n"});