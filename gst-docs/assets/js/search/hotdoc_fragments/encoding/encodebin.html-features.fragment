fragment_downloaded_cb({"url":"encoding/encodebin.html#features","fragment":"Features\nAutomatic encoder and muxer selection based on elements available on the\nsystem.\nConversion of raw audio/video streams (scaling, framerate conversion,\ncolorspace conversion, samplerate conversion) to conform to the profile\noutput format.\nVariable number of streams. If the presence property for a stream encoding\nprofile is 0, you can request any number of sink pads for it via the\nstandard request pad gstreamer API or the request-pad action\nsignal.\nAvoid reencoding (passthrough). If the input stream is already encoded and is\ncompatible with what the GstEncodingProfile expects, then the stream won't\nbe re-encoded but just passed through downstream to the muxer or the output.\nMix pre-encoded and raw streams as input. In addition to the passthrough\nfeature above, you can feed both raw audio/video AND already-encoded data\nto a pad. GstEncodeBaseBin will take care of passing through the compatible\nsegments and re-encoding the segments of media that need encoding.\nStandard behaviour is to use a GstEncodingContainerProfile to have both\nencoding and muxing performed. But you can also provide a single stream\nprofile (like GstEncodingAudioProfile) to only have the encoding done and\nhandle the encoded output yourself.\nAudio imperfection corrections. Incoming audio streams can have non perfect\ntimestamps (jitter), like the streams coming from ASF files. GstEncodeBaseBin\nwill automatically fix those imperfections for you. See\naudio-jitter-tolerance for more details.\nVariable or Constant video framerate. If your GstEncodingVideoProfile has\nthe variableframerate property deactivated (default), then the incoming\nraw video stream will be retimestampped in order to produce a constant\nframerate.\nCross-boundary re-encoding. When feeding compatible pre-encoded streams that\nfall on segment boundaries, and for supported formats (right now only H263),\nthe GOP will be decoded/reencoded when needed to produce an encoded output\nthat fits exactly within the request GstSegment.\nMissing plugin support. If a GstElement is missing to encode/mux to the\nrequest profile formats, a missing-plugin GstMessage will be posted on the\nGstBus, allowing systems that support the missing-plugin system to offer the\nuser a way to install the missing element.\n\n\nAutomatic encoder and muxer selection based on elements available on the\nsystem.\n\n\nConversion of raw audio/video streams (scaling, framerate conversion,\ncolorspace conversion, samplerate conversion) to conform to the profile\noutput format.\n\n\nVariable number of streams. If the presence property for a stream encoding\nprofile is 0, you can request any number of sink pads for it via the\nstandard request pad gstreamer API or the request-pad action\nsignal.\n\n\nAvoid reencoding (passthrough). If the input stream is already encoded and is\ncompatible with what the GstEncodingProfile expects, then the stream won't\nbe re-encoded but just passed through downstream to the muxer or the output.\n\n\nMix pre-encoded and raw streams as input. In addition to the passthrough\nfeature above, you can feed both raw audio/video AND already-encoded data\nto a pad. GstEncodeBaseBin will take care of passing through the compatible\nsegments and re-encoding the segments of media that need encoding.\n\n\nStandard behaviour is to use a GstEncodingContainerProfile to have both\nencoding and muxing performed. But you can also provide a single stream\nprofile (like GstEncodingAudioProfile) to only have the encoding done and\nhandle the encoded output yourself.\n\n\nAudio imperfection corrections. Incoming audio streams can have non perfect\ntimestamps (jitter), like the streams coming from ASF files. GstEncodeBaseBin\nwill automatically fix those imperfections for you. See\naudio-jitter-tolerance for more details.\n\n\nVariable or Constant video framerate. If your GstEncodingVideoProfile has\nthe variableframerate property deactivated (default), then the incoming\nraw video stream will be retimestampped in order to produce a constant\nframerate.\n\n\nCross-boundary re-encoding. When feeding compatible pre-encoded streams that\nfall on segment boundaries, and for supported formats (right now only H263),\nthe GOP will be decoded/reencoded when needed to produce an encoded output\nthat fits exactly within the request GstSegment.\n\n\nMissing plugin support. If a GstElement is missing to encode/mux to the\nrequest profile formats, a missing-plugin GstMessage will be posted on the\nGstBus, allowing systems that support the missing-plugin system to offer the\nuser a way to install the missing element.\n\n\n"});