fragment_downloaded_cb({"url":"gst-editing-services/gesasset.html#ges_asset_request_async","fragment":"\n\tges_asset_request_async\n\n\n\tGES.Asset.prototype.request_async\n\n\n\tGES.Asset.request_async\n\nRequests an asset with the given properties asynchronously (see\nges_asset_request). When the asset has been initialized or fetched\nfrom the cache, the given callback function will be called. The\nasset can then be retrieved in the callback using the\nges_asset_request_finish method on the given GAsyncResult.\nNote that the source object passed to the callback will be the\nGESAsset corresponding to the request, but it may not have loaded\ncorrectly and therefore can not be used as is. Instead,\nges_asset_request_finish should be used to fetch a usable asset, or\nindicate that an error occurred in the asset's creation.\nNote that the callback will be called in the GMainLoop running under\nthe same GMainContext that ges_init was called in. So, if you wish\nthe callback to be invoked outside the default GMainContext, you can\ncall g_main_context_push_thread_default in a new thread before\ncalling ges_init.\nExample of an asynchronous asset request:\nParameters:\nThe extractable-type of the asset\nThe id of the asset\nAn object to allow cancellation of the\nasset request, or NULL to ignore\nA function to call when the initialization is finished\nData to be passed to callback\nRequests an asset with the given properties asynchronously (see\nGES.Asset.prototype.request). When the asset has been initialized or fetched\nfrom the cache, the given callback function will be called. The\nasset can then be retrieved in the callback using the\nGES.Asset.prototype.request_finish method on the given Gio.AsyncResult.\nNote that the source object passed to the callback will be the\nGES.Asset corresponding to the request, but it may not have loaded\ncorrectly and therefore can not be used as is. Instead,\nGES.Asset.prototype.request_finish should be used to fetch a usable asset, or\nindicate that an error occurred in the asset's creation.\nNote that the callback will be called in the GLib.MainLoop running under\nthe same GLib.MainContext that GES.prototype.init was called in. So, if you wish\nthe callback to be invoked outside the default GLib.MainContext, you can\ncall GLib.MainContext.prototype.push_thread_default in a new thread before\ncalling GES.prototype.init.\nExample of an asynchronous asset request:\nParameters:\nThe extractable-type of the asset\nThe id of the asset\nAn object to allow cancellation of the\nasset request, or null to ignore\nA function to call when the initialization is finished\nData to be passed to callback\nRequests an asset with the given properties asynchronously (see\nGES.Asset.request). When the asset has been initialized or fetched\nfrom the cache, the given callback function will be called. The\nasset can then be retrieved in the callback using the\nGES.Asset.request_finish method on the given Gio.AsyncResult.\nNote that the source object passed to the callback will be the\nGES.Asset corresponding to the request, but it may not have loaded\ncorrectly and therefore can not be used as is. Instead,\nGES.Asset.request_finish should be used to fetch a usable asset, or\nindicate that an error occurred in the asset's creation.\nNote that the callback will be called in the GLib.MainLoop running under\nthe same GLib.MainContext that GES.init was called in. So, if you wish\nthe callback to be invoked outside the default GLib.MainContext, you can\ncall GLib.MainContext.push_thread_default in a new thread before\ncalling GES.init.\nExample of an asynchronous asset request:\nParameters:\nThe extractable_type of the asset\nThe id of the asset\nAn object to allow cancellation of the\nasset request, or None to ignore\nA function to call when the initialization is finished\nData to be passed to callback\n"});