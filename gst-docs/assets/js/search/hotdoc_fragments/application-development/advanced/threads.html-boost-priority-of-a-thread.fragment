fragment_downloaded_cb({"url":"application-development/advanced/threads.html#boost-priority-of-a-thread","fragment":"Boost priority of a thread\nLet's look at the simple pipeline above. We would like to boost the\npriority of the streaming thread. It will be the fakesrc element that\nstarts the streaming thread for generating the fake data pushing them to\nthe peer fakesink. The flow for changing the priority would go like\nthis:\nWhen going from READY to PAUSED state, fakesrc will require a\nstreaming thread for pushing data into the fakesink. It will post a\nSTREAM_STATUS message indicating its requirement for a streaming\nthread.\nThe application will react to the STREAM_STATUS messages with a\nsync bus handler. It will then configure a custom GstTaskPool on\nthe GstTask inside the message. The custom taskpool is responsible\nfor creating the threads. In this example we will make a thread with\na higher priority.\nAlternatively, since the sync message is called in the thread\ncontext, you can use thread ENTER/LEAVE notifications to change the\npriority or scheduling policy of the current thread.\nIn a first step we need to implement a custom GstTaskPool that we can\nconfigure on the task. Below is the implementation of a GstTaskPool\nsubclass that uses pthreads to create a SCHED_RR real-time thread. Note\nthat creating real-time threads might require extra privileges.\nThe important function to implement when writing an taskpool is the\n“push” function. The implementation should start a thread that calls\nthe given function. More involved implementations might want to keep\nsome threads around in a pool because creating and destroying threads is\nnot always the fastest operation.\nIn a next step we need to actually configure the custom taskpool when\nthe fakesrc needs it. For this we intercept the STREAM_STATUS messages\nwith a sync handler.\nNote that this program likely needs root permissions in order to create\nreal-time threads. When the thread can't be created, the state change\nfunction will fail, which we catch in the application above.\nWhen there are multiple threads in the pipeline, you will receive\nmultiple STREAM_STATUS messages. You should use the owner of the\nmessage, which is likely the pad or the element that starts the thread,\nto figure out what the function of this thread is in the context of the\napplication.\n\n\nWhen going from READY to PAUSED state, fakesrc will require a\nstreaming thread for pushing data into the fakesink. It will post a\nSTREAM_STATUS message indicating its requirement for a streaming\nthread.\n\n\nThe application will react to the STREAM_STATUS messages with a\nsync bus handler. It will then configure a custom GstTaskPool on\nthe GstTask inside the message. The custom taskpool is responsible\nfor creating the threads. In this example we will make a thread with\na higher priority.\n\n\nAlternatively, since the sync message is called in the thread\ncontext, you can use thread ENTER/LEAVE notifications to change the\npriority or scheduling policy of the current thread.\n\n\n"});