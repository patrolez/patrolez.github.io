fragment_downloaded_cb({"url":"application-development/advanced/pipeline-manipulation.html#inserting-data-with-appsrc","fragment":"Inserting data with appsrc\nLet's take a look at appsrc and how to insert application data into the\npipeline.\nappsrc has some configuration options that control the way it operates. You\nshould decide about the following:\nWill appsrc operate in push or pull mode. The stream-type\nproperty can be used to control this. A random-access stream-type\nwill make appsrc activate pull mode scheduling while the other\nstream-types activate push mode.\nThe caps of the buffers that appsrc will push out. This needs to be\nconfigured with the caps property. This property must be set to a fixed\ncaps and will be used to negotiate a format downstream.\nWhether appsrc operates in live mode or not. This is configured\nwith the is-live property. When operating in live-mode it is\nalso important to set the min-latency and max-latency properties.\nmin-latency should be set to the amount of time it takes between\ncapturing a buffer and when it is pushed inside appsrc. In live\nmode, you should timestamp the buffers with the pipeline running-time\nwhen the first byte of the buffer was captured before feeding them to\nappsrc. You can let appsrc do the timestamping with\nthe do-timestamp property, but then the min-latency must be set to 0\nbecause appsrc timestamps based on what was the running-time when it got\na given buffer.\nThe format of the SEGMENT event that appsrc will push. This format\nhas implications for how the buffers' running-time will be calculated,\nso you must be sure you understand this. For live sources\nyou probably want to set the format property to GST_FORMAT_TIME.\nFor non-live sources, it depends on the media type that you are\nhandling. If you plan to timestamp the buffers, you should probably\nuse GST_FORMAT_TIME as format, if you don't, GST_FORMAT_BYTES might\nbe appropriate.\nIf appsrc operates in random-access mode, it is important to\nconfigure the size property with the number of bytes in the stream. This\nwill allow downstream elements to know the size of the media and seek to the\nend of the stream when needed.\nThe main way of handling data to appsrc is by using the\ngst_app_src_push_buffer () function or by emitting the push-buffer action\nsignal. This will put the buffer onto a queue from which appsrc will\nread in its streaming thread. It's important to note that data\ntransport will not happen from the thread that performed the push-buffer\ncall.\nThe max-bytes property controls how much data can be queued in appsrc\nbefore appsrc considers the queue full. A filled internal queue will\nalways signal the enough-data signal, which signals the application\nthat it should stop pushing data into appsrc. The block property will\ncause appsrc to block the push-buffer method until free data becomes\navailable again.\nWhen the internal queue is running out of data, the need-data signal\nis emitted, which signals the application that it should start pushing\nmore data into appsrc.\nIn addition to the need-data and enough-data signals, appsrc can\nemit seek-data when the stream-mode property is set to\nseekable or random-access. The signal argument will contain the\nnew desired position in the stream expressed in the unit set with the\nformat property. After receiving the seek-data signal, the\napplication should push buffers from the new position.\nWhen the last byte is pushed into appsrc, you must call\ngst_app_src_end_of_stream () to make it send an EOS downstream.\nThese signals allow the application to operate appsrc in push and pull\nmode as will be explained next.\n\n\nWill appsrc operate in push or pull mode. The stream-type\nproperty can be used to control this. A random-access stream-type\nwill make appsrc activate pull mode scheduling while the other\nstream-types activate push mode.\n\n\nThe caps of the buffers that appsrc will push out. This needs to be\nconfigured with the caps property. This property must be set to a fixed\ncaps and will be used to negotiate a format downstream.\n\n\nWhether appsrc operates in live mode or not. This is configured\nwith the is-live property. When operating in live-mode it is\nalso important to set the min-latency and max-latency properties.\nmin-latency should be set to the amount of time it takes between\ncapturing a buffer and when it is pushed inside appsrc. In live\nmode, you should timestamp the buffers with the pipeline running-time\nwhen the first byte of the buffer was captured before feeding them to\nappsrc. You can let appsrc do the timestamping with\nthe do-timestamp property, but then the min-latency must be set to 0\nbecause appsrc timestamps based on what was the running-time when it got\na given buffer.\n\n\nThe format of the SEGMENT event that appsrc will push. This format\nhas implications for how the buffers' running-time will be calculated,\nso you must be sure you understand this. For live sources\nyou probably want to set the format property to GST_FORMAT_TIME.\nFor non-live sources, it depends on the media type that you are\nhandling. If you plan to timestamp the buffers, you should probably\nuse GST_FORMAT_TIME as format, if you don't, GST_FORMAT_BYTES might\nbe appropriate.\n\n\nIf appsrc operates in random-access mode, it is important to\nconfigure the size property with the number of bytes in the stream. This\nwill allow downstream elements to know the size of the media and seek to the\nend of the stream when needed.\n\n\n"});