fragment_downloaded_cb({"url":"application-development/advanced/pipeline-manipulation.html#dynamically-changing-the-pipeline","fragment":"Dynamically changing the pipeline\nIn this section we talk about some techniques for dynamically modifying\nthe pipeline. We are talking specifically about changing the pipeline\nwhile in PLAYING state and without interrupting the data flow.\nThere are some important things to consider when building dynamic\npipelines:\nThere are insertbin and switchbin elements, that target some\ncases of dynamical pipeline changes, and might fulfill your needs.\nWhen removing elements from the pipeline, make sure that there is no\ndataflow on unlinked pads because that will cause a fatal pipeline\nerror. Always block source pads (in push mode) or sink pads (in pull\nmode) before unlinking pads. See also Changing elements in a\npipeline.\nWhen adding elements to a pipeline, make sure to put the element\ninto the right state, usually the same state as the parent, before\nallowing dataflow. When an element is newly created, it is in the\nNULL state and will return an error when it receives data.\nSee also Changing elements in a pipeline.\nWhen adding elements to a pipeline, GStreamer will by default set\nthe clock and base-time on the element to the current values of the\npipeline. This means that the element will be able to construct the\nsame pipeline running-time as the other elements in the pipeline.\nThis means that sinks will synchronize buffers like the other sinks\nin the pipeline and that sources produce buffers with a running-time\nthat matches the other sources.\nWhen unlinking elements from an upstream chain, always make sure to\nflush any queued data in the element by sending an EOS event down\nthe element sink pad(s) and by waiting that the EOS leaves the\nelements (with an event probe).\nIf you don't perform a flush, you will lose the data buffered by the\nunlinked element. This can result in a simple frame loss (a few video frames,\nseveral milliseconds of audio, etc) but If you remove a muxer -- and in\nsome cases an encoder or similar elements --, you risk getting a corrupted\nfile which can't be played properly because some relevant metadata (header,\nseek/index tables, internal sync tags) might not be properly stored or updated.\nSee also Changing elements in a pipeline.\nA live source will produce buffers with a running-time equal to the\npipeline's current running-time.\nA pipeline without a live source produces buffers with a\nrunning-time starting from 0. Likewise, after a flushing seek, these\npipelines reset the running-time back to 0.\nThe running-time can be changed with gst_pad_set_offset (). It is\nimportant to know the running-time of the elements in the pipeline\nin order to maintain synchronization.\nAdding elements might change the state of the pipeline. Adding a\nnon-prerolled sink, for example, brings the pipeline back to the\nprerolling state. Removing a non-prerolled sink, for example, might\nchange the pipeline to PAUSED and PLAYING state.\nAdding a live source cancels the preroll stage and puts the pipeline\nin the playing state. Adding any live element might also change the\npipeline's latency.\nAdding or removing pipeline's elements might change the clock\nselection of the pipeline. If the newly added element provides a\nclock, it might be good for the pipeline to use the new clock. If, on\nthe other hand, the element that is providing the clock for the\npipeline is removed, a new clock has to be selected.\nAdding and removing elements might cause upstream or downstream\nelements to renegotiate caps and/or allocators. You don't really\nneed to do anything from the application, plugins largely adapt\nthemselves to the new pipeline topology in order to optimize their\nformats and allocation strategy.\nWhat is important is that when you add, remove or change elements in\na pipeline, it is possible that the pipeline needs to negotiate a\nnew format and this can fail. Usually you can fix this by inserting\nthe right converter elements where needed. See also Changing\nelements in a pipeline.\nGStreamer offers support for doing almost any dynamic pipeline modification but\nyou need to know a few details before you can do this without causing pipeline\nerrors. In the following sections we will demonstrate a few typical modification\nuse-cases.\n\n\nThere are insertbin and switchbin elements, that target some\ncases of dynamical pipeline changes, and might fulfill your needs.\n\n\nWhen removing elements from the pipeline, make sure that there is no\ndataflow on unlinked pads because that will cause a fatal pipeline\nerror. Always block source pads (in push mode) or sink pads (in pull\nmode) before unlinking pads. See also Changing elements in a\npipeline.\n\n\nWhen adding elements to a pipeline, make sure to put the element\ninto the right state, usually the same state as the parent, before\nallowing dataflow. When an element is newly created, it is in the\nNULL state and will return an error when it receives data.\nSee also Changing elements in a pipeline.\n\n\nWhen adding elements to a pipeline, GStreamer will by default set\nthe clock and base-time on the element to the current values of the\npipeline. This means that the element will be able to construct the\nsame pipeline running-time as the other elements in the pipeline.\nThis means that sinks will synchronize buffers like the other sinks\nin the pipeline and that sources produce buffers with a running-time\nthat matches the other sources.\n\n\nWhen unlinking elements from an upstream chain, always make sure to\nflush any queued data in the element by sending an EOS event down\nthe element sink pad(s) and by waiting that the EOS leaves the\nelements (with an event probe).\nIf you don't perform a flush, you will lose the data buffered by the\nunlinked element. This can result in a simple frame loss (a few video frames,\nseveral milliseconds of audio, etc) but If you remove a muxer -- and in\nsome cases an encoder or similar elements --, you risk getting a corrupted\nfile which can't be played properly because some relevant metadata (header,\nseek/index tables, internal sync tags) might not be properly stored or updated.\nSee also Changing elements in a pipeline.\n\n\nA live source will produce buffers with a running-time equal to the\npipeline's current running-time.\nA pipeline without a live source produces buffers with a\nrunning-time starting from 0. Likewise, after a flushing seek, these\npipelines reset the running-time back to 0.\nThe running-time can be changed with gst_pad_set_offset (). It is\nimportant to know the running-time of the elements in the pipeline\nin order to maintain synchronization.\n\n\nAdding elements might change the state of the pipeline. Adding a\nnon-prerolled sink, for example, brings the pipeline back to the\nprerolling state. Removing a non-prerolled sink, for example, might\nchange the pipeline to PAUSED and PLAYING state.\nAdding a live source cancels the preroll stage and puts the pipeline\nin the playing state. Adding any live element might also change the\npipeline's latency.\nAdding or removing pipeline's elements might change the clock\nselection of the pipeline. If the newly added element provides a\nclock, it might be good for the pipeline to use the new clock. If, on\nthe other hand, the element that is providing the clock for the\npipeline is removed, a new clock has to be selected.\n\n\nAdding and removing elements might cause upstream or downstream\nelements to renegotiate caps and/or allocators. You don't really\nneed to do anything from the application, plugins largely adapt\nthemselves to the new pipeline topology in order to optimize their\nformats and allocation strategy.\nWhat is important is that when you add, remove or change elements in\na pipeline, it is possible that the pipeline needs to negotiate a\nnew format and this can fail. Usually you can fix this by inserting\nthe right converter elements where needed. See also Changing\nelements in a pipeline.\n\n\n"});