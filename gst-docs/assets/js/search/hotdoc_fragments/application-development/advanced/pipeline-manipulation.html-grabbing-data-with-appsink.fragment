fragment_downloaded_cb({"url":"application-development/advanced/pipeline-manipulation.html#grabbing-data-with-appsink","fragment":"Grabbing data with appsink\nUnlike appsrc, appsink is a little easier to use. It also supports\npull and push-based modes for getting data from the pipeline.\nThe normal way of retrieving samples from appsink is by using the\ngst_app_sink_pull_sample() and gst_app_sink_pull_preroll() methods\nor by using the pull-sample and pull-preroll signals. These methods\nblock until a sample becomes available in the sink or when the sink is\nshut down or reaches EOS.\nappsink will internally use a queue to collect buffers from the\nstreaming thread. If the application is not pulling samples fast enough,\nthis queue will consume a lot of memory over time. The max-buffers\nproperty can be used to limit the queue size. The drop property\ncontrols whether the streaming thread blocks or if older buffers are\ndropped when the maximum queue size is reached. Note that blocking the\nstreaming thread can negatively affect real-time performance and should\nbe avoided.\nIf a blocking behaviour is not desirable, setting the emit-signals\nproperty to TRUE will make appsink emit the new-sample and\nnew-preroll signals when a sample can be pulled without blocking.\nThe caps property on appsink can be used to control the formats that\nthe latter can receive. This property can contain non-fixed caps, the\nformat of the pulled samples can be obtained by getting the sample caps.\nIf one of the pull-preroll or pull-sample methods return NULL, the\nappsink is stopped or in the EOS state. You can check for the EOS state\nwith the eos property or with the gst_app_sink_is_eos() method.\nThe eos signal can also be used to be informed when the EOS state is\nreached to avoid polling.\nConsider configuring the following properties in the appsink:\nThe sync property if you want to have the sink base class\nsynchronize the buffer against the pipeline clock before handing you\nthe sample.\nEnable Quality-of-Service with the qos property. If you are\ndealing with raw video frames and let the base class synchronize on\nthe clock. It might also be a good idea to let the base class send\nQOS events upstream.\nThe caps property that contains the accepted caps. Upstream elements\nwill try to convert the format so that it matches the configured\ncaps on appsink. You must still check the GstSample to get the\nactual caps of the buffer.\n\n\nThe sync property if you want to have the sink base class\nsynchronize the buffer against the pipeline clock before handing you\nthe sample.\n\n\nEnable Quality-of-Service with the qos property. If you are\ndealing with raw video frames and let the base class synchronize on\nthe clock. It might also be a good idea to let the base class send\nQOS events upstream.\n\n\nThe caps property that contains the accepted caps. Upstream elements\nwill try to convert the format so that it matches the configured\ncaps on appsink. You must still check the GstSample to get the\nactual caps of the buffer.\n\n\n"});