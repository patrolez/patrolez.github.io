fragment_downloaded_cb({"url":"application-development/advanced/buffering.html#stream-buffering","fragment":"Stream buffering\nIn this case we are reading from a slow network source into a buffer\nelement (such as queue2).\nThe buffer element has a low and high watermark expressed in bytes. The\nbuffer uses the watermarks as follows:\nThe buffer element will post BUFFERING messages until the high\nwatermark is hit. This instructs the application to keep the\npipeline PAUSED, which will eventually block the srcpad from pushing\nwhile data is prerolled in the sinks.\nWhen the high watermark is hit, a BUFFERING message with 100% will\nbe posted, which instructs the application to continue playback.\nWhen during playback, the low watermark is hit, the queue will start\nposting BUFFERING messages again, making the application PAUSE the\npipeline again until the high watermark is hit again. This is called\nthe rebuffering stage.\nDuring playback, the queue level will fluctuate between the high and\nthe low watermark as a way to compensate for network irregularities.\nThis buffering method is usable when the demuxer operates in push mode.\nSeeking in the stream requires the seek to happen in the network source.\nIt is mostly desirable when the total duration of the file is not known,\nsuch as in live streaming or when efficient seeking is not\npossible/required.\nThe problem is configuring a good low and high watermark. Here are some\nideas:\nIt is possible to measure the network bandwidth and configure the\nlow/high watermarks in such a way that buffering takes a fixed\namount of time.\nThe queue2 element in GStreamer core has the max-size-time property\nthat, together with the use-rate-estimate property, does exactly\nthat. Also the playbin buffer-duration property uses the rate\nestimate to scale the amount of data that is buffered.\nBased on the codec bitrate, it is also possible to set the\nwatermarks in such a way that a fixed amount of data is buffered\nbefore playback starts. Normally, the buffering element doesn't know\nabout the bitrate of the stream but it can get this with a query.\nStart with a fixed amount of bytes, measure the time between\nrebuffering and increase the queue size until the time between\nrebuffering is within the application's chosen limits.\nThe buffering element can be inserted anywhere in the pipeline. You\ncould, for example, insert the buffering element before a decoder. This\nwould make it possible to set the low/high watermarks based on time.\nThe buffering flag on playbin, performs buffering on the parsed data.\nAnother advantage of doing the buffering at a later stage is that you\ncan let the demuxer operate in pull mode. When reading data from a slow\nnetwork drive (with filesrc) this can be an interesting way to buffer.\n\n\nThe buffer element will post BUFFERING messages until the high\nwatermark is hit. This instructs the application to keep the\npipeline PAUSED, which will eventually block the srcpad from pushing\nwhile data is prerolled in the sinks.\n\n\nWhen the high watermark is hit, a BUFFERING message with 100% will\nbe posted, which instructs the application to continue playback.\n\n\nWhen during playback, the low watermark is hit, the queue will start\nposting BUFFERING messages again, making the application PAUSE the\npipeline again until the high watermark is hit again. This is called\nthe rebuffering stage.\n\n\nDuring playback, the queue level will fluctuate between the high and\nthe low watermark as a way to compensate for network irregularities.\n\n\n\n\nIt is possible to measure the network bandwidth and configure the\nlow/high watermarks in such a way that buffering takes a fixed\namount of time.\nThe queue2 element in GStreamer core has the max-size-time property\nthat, together with the use-rate-estimate property, does exactly\nthat. Also the playbin buffer-duration property uses the rate\nestimate to scale the amount of data that is buffered.\n\n\nBased on the codec bitrate, it is also possible to set the\nwatermarks in such a way that a fixed amount of data is buffered\nbefore playback starts. Normally, the buffering element doesn't know\nabout the bitrate of the stream but it can get this with a query.\n\n\nStart with a fixed amount of bytes, measure the time between\nrebuffering and increase the queue size until the time between\nrebuffering is within the application's chosen limits.\n\n\n"});