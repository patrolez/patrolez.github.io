fragment_downloaded_cb({"url":"application-development/advanced/threads.html#when-would-you-want-to-force-a-thread","fragment":"When would you want to force a thread?\nWe have seen that threads are created by elements but it is also\npossible to insert elements in the pipeline for the sole purpose of\nforcing a new thread in the pipeline.\nThere are several reasons to force the use of threads. However, for\nperformance reasons, you never want to use one thread for every element\nout there, since that will create some overhead. Let's now list some\nsituations where threads can be particularly useful:\nData buffering, for example when dealing with network streams or\nwhen recording data from a live stream such as a video or audio\ncard. Short hickups elsewhere in the pipeline will not cause data\nloss. See also Stream buffering about network\nbuffering with queue2.\n\nSynchronizing output devices, e.g. when playing a stream containing\nboth video and audio data. By using threads for both outputs, they\nwill run independently and their synchronization will be better.\n\nAbove, we've mentioned the “queue” element several times now. A queue is\nthe thread boundary element through which you can force the use of\nthreads. It does so by using a classic provider/consumer model as\nlearned in threading classes at universities all around the world. By\ndoing this, it acts both as a means to make data throughput between\nthreads threadsafe, and it can also act as a buffer. Queues have several\nGObject properties to be configured for specific uses. For example,\nyou can set lower and upper thresholds for the element. If there's less\ndata than the lower threshold (default: disabled), it will block output.\nIf there's more data than the upper threshold, it will block input or\n(if configured to do so) drop data.\nTo use a queue (and therefore force the use of two distinct threads in\nthe pipeline), one can simply create a “queue” element and put this in\nas part of the pipeline. GStreamer will take care of all threading\ndetails internally.\n\n\nData buffering, for example when dealing with network streams or\nwhen recording data from a live stream such as a video or audio\ncard. Short hickups elsewhere in the pipeline will not cause data\nloss. See also Stream buffering about network\nbuffering with queue2.\n\n\n\nSynchronizing output devices, e.g. when playing a stream containing\nboth video and audio data. By using threads for both outputs, they\nwill run independently and their synchronization will be better.\n\n\n\n"});