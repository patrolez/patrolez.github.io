fragment_downloaded_cb({"url":"application-development/advanced/queryevents.html#events-seeking-and-more","fragment":"Events: seeking (and more)\nEvents work in a very similar way as queries. Dispatching, for example,\nworks exactly the same for events (and also has the same limitations),\nand they can similarly be sent to the toplevel pipeline and it will\nfigure out everything for you. Although there are more ways in which\napplications and elements can interact using events, we will only focus\non seeking here. This is done using the seek-event. A seek-event\ncontains a playback rate, a seek offset format (which is the unit of the\noffsets to follow, e.g. time, audio samples, video frames or bytes),\noptionally a set of seeking-related flags (e.g. whether internal buffers\nshould be flushed), a seek method (which indicates relative to what the\noffset was given), and seek offsets.\nThe first offset (start) is the new position to seek to, while the second\noffset (stop) is optional and specifies a position where streaming is\nsupposed to stop. Usually it is fine to just specify GST_SEEK_TYPE_NONE\nas stop_type and GST_CLOCK_TIME_NONE as stop offset.\nIn case of reverse playback (rate < 0) the meaning of start and stop is\nreversed and stop is the position to seek to.\nThe behaviour of a seek is also wrapped in the gst_element_seek() and\ngst_element_seek_simple() and you would usually use those functions to\ninitiate a seek on a pipeline.\nSeeks with the GST_SEEK_FLAG_FLUSH should be done when the pipeline\nis in PAUSED or PLAYING state. The pipeline will automatically go to\npreroll state until the new data after the seek will cause the pipeline\nto preroll again. After the pipeline is prerolled, it will go back to\nthe state (PAUSED or PLAYING) it was in when the seek was executed. You\ncan wait (blocking) for the seek to complete with\ngst_element_get_state() or by waiting for the ASYNC_DONE message to\nappear on the bus.\nSeeks without the GST_SEEK_FLAG_FLUSH should only be done when the\npipeline is in the PLAYING state. Executing a non-flushing seek in the\nPAUSED state might deadlock because the pipeline streaming threads might\nbe blocked in the sinks.\nIt is important to realise that seeks will not happen instantly in the\nsense that they are finished when the function gst_element_seek ()\nreturns. Depending on the specific elements involved, the actual seeking\nmight be done later in another thread (the streaming thread), and it\nmight take a short time until buffers from the new seek position will\nreach downstream elements such as sinks (if the seek was non-flushing\nthen it might take a bit longer).\nIt is possible to do multiple seeks in short time-intervals, such as a\ndirect response to slider movement. After a seek, internally, the\npipeline will be paused (if it was playing), the position will be re-set\ninternally, the demuxers and decoders will decode from the new position\nonwards and this will continue until all sinks have data again. If it\nwas playing originally, it will be set to playing again, too. Since the\nnew position is immediately available in a video output, you will see\nthe new frame, even if your pipeline is not in the playing state.\n"});