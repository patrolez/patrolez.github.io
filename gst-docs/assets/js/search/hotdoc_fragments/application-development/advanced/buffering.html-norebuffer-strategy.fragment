fragment_downloaded_cb({"url":"application-development/advanced/buffering.html#norebuffer-strategy","fragment":"No-rebuffer strategy\nWe would like to buffer enough data in the pipeline so that playback\ncontinues without interruptions. What we need to know to implement this\nis know the total remaining playback time in the file and the total\nremaining download time. If the buffering time is less than the playback\ntime, we can start playback without interruptions.\nWe have all this information available with the DURATION, POSITION and\nBUFFERING queries. We need to periodically execute the buffering query\nto get the current buffering status. We also need to have a large enough\nbuffer to hold the complete file, worst case. It is best to use this\nbuffering strategy with download buffering (see Download\nbuffering).\nThis is what the code would look like:\nSee how we set the pipeline to the PAUSED state first. We will receive\nbuffering messages during the preroll state when buffering is needed.\nWhen we are prerolled (on_message_async_done) we see if buffering is\ngoing on, if not, we start playback. If buffering was going on, we start\na timeout to poll the buffering state. If the estimated time to download\nis less than the remaining playback time, we start playback.\n"});