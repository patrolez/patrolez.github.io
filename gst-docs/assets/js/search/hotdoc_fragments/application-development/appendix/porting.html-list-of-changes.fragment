fragment_downloaded_cb({"url":"application-development/appendix/porting.html#list-of-changes","fragment":"List of changes\nMost functions returning an object or an object property have been\nchanged to return its own reference rather than a constant reference\nof the one owned by the object itself. The reason for this change is\nprimarily thread safety. This means, effectively, that return values\nof functions such as gst_element_get_pad (), gst_pad_get_name ()\nand many more like these have to be free'ed or unreferenced after\nuse. Check the API references of each function to know for sure\nwhether return values should be free'ed or not. It is important that\nall objects derived from GstObject are ref'ed/unref'ed using\ngst_object_ref() and gst_object_unref() respectively (instead of\ng_object_ref/unref).\nApplications should no longer use signal handlers to be notified of\nerrors, end-of-stream and other similar pipeline events. Instead,\nthey should use the GstBus, which has been discussed in\nBus. The bus will take care that the messages will\nbe delivered in the context of a main loop, which is almost\ncertainly the application's main thread. The big advantage of this\nis that applications no longer need to be thread-aware; they don't\nneed to use g_idle_add () in the signal handler and do the actual\nreal work in the idle-callback. GStreamer now does all that internally.\nRelated to this, gst_bin_iterate () has been removed. Pipelines\nwill iterate in their own thread, and applications can simply run a\nGMainLoop (or call the mainloop of their UI toolkit, such as\ngtk_main ()).\nState changes can be delayed (ASYNC). Due to the new fully threaded\nnature of GStreamer-0.10, state changes are not always immediate, in\nparticular changes including the transition from READY to PAUSED\nstate. This means two things in the context of porting applications:\nfirst of all, it is no longer always possible to do\ngst_element_set_state () and check for a return value of\nGST_STATE_CHANGE_SUCCESS, as the state change might be delayed\n(ASYNC) and the result will not be known until later. You should\nstill check for GST_STATE_CHANGE_FAILURE right away, it is just\nno longer possible to assume that everything that is not SUCCESS\nmeans failure. Secondly, state changes might not be immediate, so\nyour code needs to take that into account. You can wait for a state\nchange to complete if you use GST_CLOCK_TIME_NONE as timeout\ninterval with gst_element_get_state ().\nIn 0.8, events and queries had to manually be sent to sinks in\npipelines (unless you were using playbin). This is no longer the\ncase in 0.10. In 0.10, queries and events can be sent to toplevel\npipelines, and the pipeline will do the dispatching internally for\nyou. This means less bookkeeping in your application. For a short\ncode example, see [Position tracking and seeking][queries-and-events].\nRelated, seeking is now threadsafe, and your video output will show the new\nvideo position's frame while seeking, providing a better user experience.\nThe GstThread object has been removed. Applications can now simply\nput elements in a pipeline with optionally some “queue” elements in\nbetween for buffering, and GStreamer will take care of creating\nthreads internally. It is still possible to have parts of a pipeline\nrun in different threads than others, by using the “queue” element.\nSee Threads for details.\nFiltered caps -> capsfilter element (the pipeline syntax for\ngst-launch has not changed though).\nlibgstgconf-0.10.la does not exist. Use the “gconfvideosink” and\n“gconfaudiosink” elements instead, which will do live-updates and\nrequire no library linking.\nThe “new-pad” and “state-change” signals on GstElement were\nrenamed to “pad-added” and “state-changed”.\ngst_init_get_popt_table () has been removed in favour of the new\nGOption command line option API that was added to GLib 2.6.\ngst_init_get_option_group () is the new GOption-based equivalent\nto gst_init_get_ptop_table ().\n\n\nMost functions returning an object or an object property have been\nchanged to return its own reference rather than a constant reference\nof the one owned by the object itself. The reason for this change is\nprimarily thread safety. This means, effectively, that return values\nof functions such as gst_element_get_pad (), gst_pad_get_name ()\nand many more like these have to be free'ed or unreferenced after\nuse. Check the API references of each function to know for sure\nwhether return values should be free'ed or not. It is important that\nall objects derived from GstObject are ref'ed/unref'ed using\ngst_object_ref() and gst_object_unref() respectively (instead of\ng_object_ref/unref).\n\n\nApplications should no longer use signal handlers to be notified of\nerrors, end-of-stream and other similar pipeline events. Instead,\nthey should use the GstBus, which has been discussed in\nBus. The bus will take care that the messages will\nbe delivered in the context of a main loop, which is almost\ncertainly the application's main thread. The big advantage of this\nis that applications no longer need to be thread-aware; they don't\nneed to use g_idle_add () in the signal handler and do the actual\nreal work in the idle-callback. GStreamer now does all that internally.\n\n\nRelated to this, gst_bin_iterate () has been removed. Pipelines\nwill iterate in their own thread, and applications can simply run a\nGMainLoop (or call the mainloop of their UI toolkit, such as\ngtk_main ()).\n\n\nState changes can be delayed (ASYNC). Due to the new fully threaded\nnature of GStreamer-0.10, state changes are not always immediate, in\nparticular changes including the transition from READY to PAUSED\nstate. This means two things in the context of porting applications:\nfirst of all, it is no longer always possible to do\ngst_element_set_state () and check for a return value of\nGST_STATE_CHANGE_SUCCESS, as the state change might be delayed\n(ASYNC) and the result will not be known until later. You should\nstill check for GST_STATE_CHANGE_FAILURE right away, it is just\nno longer possible to assume that everything that is not SUCCESS\nmeans failure. Secondly, state changes might not be immediate, so\nyour code needs to take that into account. You can wait for a state\nchange to complete if you use GST_CLOCK_TIME_NONE as timeout\ninterval with gst_element_get_state ().\n\n\nIn 0.8, events and queries had to manually be sent to sinks in\npipelines (unless you were using playbin). This is no longer the\ncase in 0.10. In 0.10, queries and events can be sent to toplevel\npipelines, and the pipeline will do the dispatching internally for\nyou. This means less bookkeeping in your application. For a short\ncode example, see [Position tracking and seeking][queries-and-events].\nRelated, seeking is now threadsafe, and your video output will show the new\nvideo position's frame while seeking, providing a better user experience.\n\n\nThe GstThread object has been removed. Applications can now simply\nput elements in a pipeline with optionally some “queue” elements in\nbetween for buffering, and GStreamer will take care of creating\nthreads internally. It is still possible to have parts of a pipeline\nrun in different threads than others, by using the “queue” element.\nSee Threads for details.\n\n\nFiltered caps -> capsfilter element (the pipeline syntax for\ngst-launch has not changed though).\n\n\nlibgstgconf-0.10.la does not exist. Use the “gconfvideosink” and\n“gconfaudiosink” elements instead, which will do live-updates and\nrequire no library linking.\n\n\nThe “new-pad” and “state-change” signals on GstElement were\nrenamed to “pad-added” and “state-changed”.\n\n\ngst_init_get_popt_table () has been removed in favour of the new\nGOption command line option API that was added to GLib 2.6.\ngst_init_get_option_group () is the new GOption-based equivalent\nto gst_init_get_ptop_table ().\n\n\n"});