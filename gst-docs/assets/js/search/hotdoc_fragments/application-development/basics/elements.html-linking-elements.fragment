fragment_downloaded_cb({"url":"application-development/basics/elements.html#linking-elements","fragment":"Linking elements\nBy linking a source element with zero or more filter-like elements and\nfinally a sink element, you set up a media pipeline. Data will flow\nthrough the elements. This is the basic concept of media handling in\nGStreamer.\n\nBy linking these three elements, we have created a very simple chain of\nelements. The effect of this will be that the output of the source\nelement will be used as input for the filter-like element. The filter-like\nelement will do something with the data and send the result to the final\nsink element.\nImagine the above graph as a simple Ogg/Vorbis audio decoder. The source\nis a disk source which reads the file from disc. The second element is a\nOgg/Vorbis audio decoder. The sink element is your soundcard, playing\nback the decoded audio data. We will use this simple graph to construct\nan Ogg/Vorbis player later in this manual.\nIn code, the above graph is written like this:\nFor more specific behaviour, there are also the functions\ngst_element_link () and gst_element_link_pads (). You can also\nobtain references to individual pads and link those using various\ngst_pad_link_* () functions. See the API references for more details.\nImportant: you must add elements to a bin or pipeline before linking\nthem, since adding an element to a bin will disconnect any already\nexisting links. Also, you cannot directly link elements that are not in\nthe same bin or pipeline; if you want to link elements or pads at\ndifferent hierarchy levels, you will need to use ghost pads (more about\nghost pads later).\n"});