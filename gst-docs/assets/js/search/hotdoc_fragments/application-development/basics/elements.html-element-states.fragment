fragment_downloaded_cb({"url":"application-development/basics/elements.html#element-states","fragment":"Element States\nAfter being created, an element will not actually perform any actions\nyet. You need to change elements state to make it do something.\nGStreamer knows four element states, each with a very specific meaning.\nThose four states are:\nGST_STATE_NULL: this is the default state. No resources are\nallocated in this state, so, transitioning to it will free all\nresources. The element must be in this state when its refcount\nreaches 0 and it is freed.\nGST_STATE_READY: in the ready state, an element has allocated all\nof its global resources, that is, resources that can be kept within\nstreams. You can think about opening devices, allocating buffers and\nso on. However, the stream is not opened in this state, so the\nstream positions is automatically zero. If a stream was previously\nopened, it should be closed in this state, and position, properties\nand such should be reset.\nGST_STATE_PAUSED: in this state, an element has opened the stream,\nbut is not actively processing it. An element is allowed to modify a\nstream's position, read and process data and such to prepare for\nplayback as soon as state is changed to PAUSED, but it is not\nallowed to play the data which would make the clock run. In summary,\nPAUSED is the same as PLAYING but without a running clock.\nElements going into the PAUSED state should prepare themselves for\nmoving over to the PLAYING state as soon as possible. Video or audio\noutputs would, for example, wait for data to arrive and queue it so\nthey can play it right after the state change. Also, video sinks can\nalready play the first frame (since this does not affect the clock\nyet). Autopluggers could use this same state transition to already\nplug together a pipeline. Most other elements, such as codecs or\nfilters, do not need to explicitly do anything in this state,\nhowever.\nGST_STATE_PLAYING: in the PLAYING state, an element does exactly\nthe same as in the PAUSED state, except that the clock now runs.\nYou can change the state of an element using the function\ngst_element_set_state (). If you set an element to another state,\nGStreamer will internally traverse all intermediate states. So if you\nset an element from NULL to PLAYING, GStreamer will internally set the\nelement to READY and PAUSED in between.\nWhen moved to GST_STATE_PLAYING, pipelines will process data\nautomatically. They do not need to be iterated in any form. Internally,\nGStreamer will start threads that take on this task for them. GStreamer\nwill also take care of switching messages from the pipeline's thread\ninto the application's own thread, by using a\nGstBus.\nSee Bus for details.\nWhen you set a bin or pipeline to a certain target state, it will\nusually propagate the state change to all elements within the bin or\npipeline automatically, so it's usually only necessary to set the state\nof the top-level pipeline to start up the pipeline or shut it down.\nHowever, when adding elements dynamically to an already-running\npipeline, e.g. from within a \"pad-added\" signal callback, you need to\nset it to the desired target state yourself using gst_element_set_state () or gst_element_sync_state_with_parent ().\n\n\nGST_STATE_NULL: this is the default state. No resources are\nallocated in this state, so, transitioning to it will free all\nresources. The element must be in this state when its refcount\nreaches 0 and it is freed.\n\n\nGST_STATE_READY: in the ready state, an element has allocated all\nof its global resources, that is, resources that can be kept within\nstreams. You can think about opening devices, allocating buffers and\nso on. However, the stream is not opened in this state, so the\nstream positions is automatically zero. If a stream was previously\nopened, it should be closed in this state, and position, properties\nand such should be reset.\n\n\nGST_STATE_PAUSED: in this state, an element has opened the stream,\nbut is not actively processing it. An element is allowed to modify a\nstream's position, read and process data and such to prepare for\nplayback as soon as state is changed to PAUSED, but it is not\nallowed to play the data which would make the clock run. In summary,\nPAUSED is the same as PLAYING but without a running clock.\nElements going into the PAUSED state should prepare themselves for\nmoving over to the PLAYING state as soon as possible. Video or audio\noutputs would, for example, wait for data to arrive and queue it so\nthey can play it right after the state change. Also, video sinks can\nalready play the first frame (since this does not affect the clock\nyet). Autopluggers could use this same state transition to already\nplug together a pipeline. Most other elements, such as codecs or\nfilters, do not need to explicitly do anything in this state,\nhowever.\n\n\nGST_STATE_PLAYING: in the PLAYING state, an element does exactly\nthe same as in the PAUSED state, except that the clock now runs.\n\n\n"});