fragment_downloaded_cb({"url":"application-development/basics/bus.html#message-types","fragment":"Message types\nGStreamer has a few pre-defined message types that can be passed over\nthe bus. The messages are extensible, however. Plug-ins can define\nadditional messages, and applications can decide to either have specific\ncode for those or ignore them. All applications are strongly recommended\nto at least handle error messages by providing visual feedback to the\nuser.\nAll messages have a message source, type and timestamp. The message\nsource can be used to see which element emitted the message. For some\nmessages, for example, only the ones emitted by the top-level pipeline\nwill be interesting to most applications (e.g. for state-change\nnotifications). Below is a list of all messages and a short explanation\nof what they do and how to parse message-specific content.\nError, warning and information notifications: those are used by\nelements if a message should be shown to the user about the state of\nthe pipeline. Error messages are fatal and terminate the\ndata-passing. The error should be repaired to resume pipeline\nactivity. Warnings are not fatal, but imply a problem nevertheless.\nInformation messages are for non-problem notifications. All those\nmessages contain a GError with the main error type and message,\nand optionally a debug string. Both can be extracted using\ngst_message_parse_error(), _parse_warning () and _parse_info ().\nBoth error and debug strings should be freed after use.\nEnd-of-stream notification: this is emitted when the stream has\nended. The state of the pipeline will not change, but further media\nhandling will stall. Applications can use this to skip to the next\nsong in their playlist. After end-of-stream, it is also possible to\nseek back in the stream. Playback will then continue automatically.\nThis message has no specific arguments.\nTags: emitted when metadata was found in the stream. This can be\nemitted multiple times for a pipeline (e.g. once for descriptive\nmetadata such as artist name or song title, and another one for\nstream-information, such as samplerate and bitrate). Applications\nshould cache metadata internally. gst_message_parse_tag() should be\nused to parse the taglist, which should be gst_tag_list_unref ()'ed\nwhen no longer needed.\nState-changes: emitted after a successful state change.\ngst_message_parse_state_changed () can be used to parse the old\nand new state of this transition.\nBuffering: emitted during caching of network-streams. One can\nmanually extract the progress (in percent) from the message by\nextracting the “buffer-percent” property from the structure returned\nby gst_message_get_structure(). See also Buffering\nElement messages: these are special messages that are unique to\ncertain elements and usually represent additional features. The\nelement's documentation should mention in detail which element\nmessages a particular element may send. As an example, the 'qtdemux'\nQuickTime demuxer element may send a 'redirect' element message on\ncertain occasions if the stream contains a redirect instruction.\nApplication-specific messages: any information on those can be\nextracted by getting the message structure (see above) and reading\nits fields. Usually these messages can safely be ignored.\nApplication messages are primarily meant for internal use in\napplications in case the application needs to marshal information\nfrom some thread into the main thread. This is particularly useful\nwhen the application is making use of element signals (as those\nsignals will be emitted in the context of the streaming thread).\n\n\nError, warning and information notifications: those are used by\nelements if a message should be shown to the user about the state of\nthe pipeline. Error messages are fatal and terminate the\ndata-passing. The error should be repaired to resume pipeline\nactivity. Warnings are not fatal, but imply a problem nevertheless.\nInformation messages are for non-problem notifications. All those\nmessages contain a GError with the main error type and message,\nand optionally a debug string. Both can be extracted using\ngst_message_parse_error(), _parse_warning () and _parse_info ().\nBoth error and debug strings should be freed after use.\n\n\nEnd-of-stream notification: this is emitted when the stream has\nended. The state of the pipeline will not change, but further media\nhandling will stall. Applications can use this to skip to the next\nsong in their playlist. After end-of-stream, it is also possible to\nseek back in the stream. Playback will then continue automatically.\nThis message has no specific arguments.\n\n\nTags: emitted when metadata was found in the stream. This can be\nemitted multiple times for a pipeline (e.g. once for descriptive\nmetadata such as artist name or song title, and another one for\nstream-information, such as samplerate and bitrate). Applications\nshould cache metadata internally. gst_message_parse_tag() should be\nused to parse the taglist, which should be gst_tag_list_unref ()'ed\nwhen no longer needed.\n\n\nState-changes: emitted after a successful state change.\ngst_message_parse_state_changed () can be used to parse the old\nand new state of this transition.\n\n\nBuffering: emitted during caching of network-streams. One can\nmanually extract the progress (in percent) from the message by\nextracting the “buffer-percent” property from the structure returned\nby gst_message_get_structure(). See also Buffering\n\n\nElement messages: these are special messages that are unique to\ncertain elements and usually represent additional features. The\nelement's documentation should mention in detail which element\nmessages a particular element may send. As an example, the 'qtdemux'\nQuickTime demuxer element may send a 'redirect' element message on\ncertain occasions if the stream contains a redirect instruction.\n\n\nApplication-specific messages: any information on those can be\nextracted by getting the message structure (see above) and reading\nits fields. Usually these messages can safely be ignored.\nApplication messages are primarily meant for internal use in\napplications in case the application needs to marshal information\nfrom some thread into the main thread. This is particularly useful\nwhen the application is making use of element signals (as those\nsignals will be emitted in the context of the streaming thread).\n\n\n"});