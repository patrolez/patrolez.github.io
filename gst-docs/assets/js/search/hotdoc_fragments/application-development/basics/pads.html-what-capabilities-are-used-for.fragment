fragment_downloaded_cb({"url":"application-development/basics/pads.html#what-capabilities-are-used-for","fragment":"What capabilities are used for\nCapabilities (short: caps) describe the type of data that is streamed\nbetween two pads, or that one pad (template) supports. This makes them\nvery useful for various purposes:\nAutoplugging: automatically finding elements to link to a pad based\non its capabilities. All autopluggers use this method.\nCompatibility detection: when two pads are linked, GStreamer can\nverify if the two pads are talking about the same media type. The\nprocess of linking two pads and checking if they are compatible is\ncalled “caps negotiation”.\nMetadata: by reading the capabilities from a pad, applications can\nprovide information about the type of media that is being streamed\nover the pad, which is information about the stream that is\ncurrently being played back.\nFiltering: an application can use capabilities to limit the possible\nmedia types that can stream between two pads to a specific subset of\ntheir supported stream types. An application can, for example, use\n“filtered caps” to set a specific (fixed or non-fixed) video size\nthat should stream between two pads. You will see an example of\nfiltered caps later in this manual, in Manually adding or removing\ndata from/to a pipeline.\nYou can do caps filtering by inserting a capsfilter element into\nyour pipeline and setting its “caps” property. Caps filters are\noften placed after converter elements like audioconvert,\naudioresample, videoconvert or videoscale to force those converters\nto convert data to a specific output format at a certain point in a\nstream.\n\n\nAutoplugging: automatically finding elements to link to a pad based\non its capabilities. All autopluggers use this method.\n\n\nCompatibility detection: when two pads are linked, GStreamer can\nverify if the two pads are talking about the same media type. The\nprocess of linking two pads and checking if they are compatible is\ncalled “caps negotiation”.\n\n\nMetadata: by reading the capabilities from a pad, applications can\nprovide information about the type of media that is being streamed\nover the pad, which is information about the stream that is\ncurrently being played back.\n\n\nFiltering: an application can use capabilities to limit the possible\nmedia types that can stream between two pads to a specific subset of\ntheir supported stream types. An application can, for example, use\n“filtered caps” to set a specific (fixed or non-fixed) video size\nthat should stream between two pads. You will see an example of\nfiltered caps later in this manual, in Manually adding or removing\ndata from/to a pipeline.\nYou can do caps filtering by inserting a capsfilter element into\nyour pipeline and setting its “caps” property. Caps filters are\noften placed after converter elements like audioconvert,\naudioresample, videoconvert or videoscale to force those converters\nto convert data to a specific output format at a certain point in a\nstream.\n\n\n"});