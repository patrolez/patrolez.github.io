fragment_downloaded_cb({"url":"application-development/basics/bus.html#how-to-use-a-bus","fragment":"How to use a bus\nThere are two different ways to use a bus:\nRun a GLib/Gtk+ main loop (or iterate the default GLib main context\nyourself regularly) and attach some kind of watch to the bus. This\nway the GLib main loop will check the bus for new messages and\nnotify you whenever there are messages.\nTypically you would use gst_bus_add_watch () or\ngst_bus_add_signal_watch () in this case.\nTo use a bus, attach a message handler to the bus of a pipeline\nusing gst_bus_add_watch (). This handler will be called whenever\nthe pipeline emits a message to the bus. In this handler, check the\nsignal type (see next section) and do something accordingly. The\nreturn value of the handler should be TRUE to keep the handler\nattached to the bus, return FALSE to remove it.\nCheck for messages on the bus yourself. This can be done using\ngst_bus_peek () and/or gst_bus_poll ().\nIt is important to know that the handler will be called in the thread\ncontext of the mainloop. This means that the interaction between the\npipeline and application over the bus is asynchronous, and thus not\nsuited for some real-time purposes, such as cross-fading between audio\ntracks, doing (theoretically) gapless playback or video effects. All\nsuch things should be done in the pipeline context, which is easiest by\nwriting a GStreamer plug-in. It is very useful for its primary purpose,\nthough: passing messages from pipeline to application. The advantage of\nthis approach is that all the threading that GStreamer does internally\nis hidden from the application and the application developer does not\nhave to worry about thread issues at all.\nNote that if you're using the default GLib mainloop integration, you\ncan, instead of attaching a watch, connect to the “message” signal on\nthe bus. This way you don't have to switch() on all possible message\ntypes; just connect to the interesting signals in form of\nmessage::<type>, where <type> is a specific message type (see\nthe next section for an explanation of message types).\nThe above snippet could then also be written as:\nIf you aren't using GLib mainloop, the asynchronous message signals\nwon't be available by default. You can however install a custom sync\nhandler that wakes up the custom mainloop and that uses\ngst_bus_async_signal_func () to emit the signals. (see also\ndocumentation\nfor details)\n\n\nRun a GLib/Gtk+ main loop (or iterate the default GLib main context\nyourself regularly) and attach some kind of watch to the bus. This\nway the GLib main loop will check the bus for new messages and\nnotify you whenever there are messages.\nTypically you would use gst_bus_add_watch () or\ngst_bus_add_signal_watch () in this case.\nTo use a bus, attach a message handler to the bus of a pipeline\nusing gst_bus_add_watch (). This handler will be called whenever\nthe pipeline emits a message to the bus. In this handler, check the\nsignal type (see next section) and do something accordingly. The\nreturn value of the handler should be TRUE to keep the handler\nattached to the bus, return FALSE to remove it.\n\n\nCheck for messages on the bus yourself. This can be done using\ngst_bus_peek () and/or gst_bus_poll ().\n\n\n"});