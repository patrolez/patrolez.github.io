fragment_downloaded_cb({"url":"application-development/introduction/motivation.html#high-performance","fragment":"High performance\nHigh performance is obtained by:\nusing GLib's GSlice allocator\nextremely light-weight links between plugins. Data can travel the\npipeline with minimal overhead. Data passing between plugins only\ninvolves a pointer dereference in a typical pipeline.\nproviding a mechanism to directly work on the target memory. A\nplugin can for example directly write to the X server's shared\nmemory space. Buffers can also point to arbitrary memory, such as a\nsound card's internal hardware buffer.\nrefcounting and copy on write minimize usage of memcpy. Sub-buffers\nefficiently split buffers into manageable pieces.\ndedicated streaming threads, with scheduling handled by the kernel.\nallowing hardware acceleration by using specialized plugins.\nusing a plugin registry with the specifications of the plugins so\nthat the plugin loading can be delayed until the plugin is actually\nused.\n\n\nusing GLib's GSlice allocator\n\n\nextremely light-weight links between plugins. Data can travel the\npipeline with minimal overhead. Data passing between plugins only\ninvolves a pointer dereference in a typical pipeline.\n\n\nproviding a mechanism to directly work on the target memory. A\nplugin can for example directly write to the X server's shared\nmemory space. Buffers can also point to arbitrary memory, such as a\nsound card's internal hardware buffer.\n\n\nrefcounting and copy on write minimize usage of memcpy. Sub-buffers\nefficiently split buffers into manageable pieces.\n\n\ndedicated streaming threads, with scheduling handled by the kernel.\n\n\nallowing hardware acceleration by using specialized plugins.\n\n\nusing a plugin registry with the specifications of the plugins so\nthat the plugin loading can be delayed until the plugin is actually\nused.\n\n\n"});