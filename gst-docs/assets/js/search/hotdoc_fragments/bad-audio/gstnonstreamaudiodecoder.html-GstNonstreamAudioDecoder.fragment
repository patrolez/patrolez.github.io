fragment_downloaded_cb({"url":"bad-audio/gstnonstreamaudiodecoder.html#GstNonstreamAudioDecoder","fragment":"\n\tGstNonstreamAudioDecoder\n\nMembers\nClass structure\n\n\tGstNonstreamAudioDecoderClass\n\nFields\n\n\tGstBadAudio.NonstreamAudioDecoderClass\n\nAttributes\n\n\tGstBadAudio.NonstreamAudioDecoderClass\n\nAttributes\n\n\tGstBadAudio.NonstreamAudioDecoder\n\nMembers\n\n\tGstBadAudio.NonstreamAudioDecoder\n\nMembers\nThe opaque GstNonstreamAudioDecoder data structure.\nSubclasses can override any of the available optional virtual methods or not, as\nneeded. At minimum, load_from_buffer (or load_from_custom), get_supported_output_modes,\nand decode need to be overridden.\nAll functions are called with a locked decoder mutex.\nIf GST_ELEMENT_ERROR, GST_ELEMENT_WARNING, or GST_ELEMENT_INFO are called from\ninside one of these functions, it is strongly recommended to unlock the decoder mutex\nbefore and re-lock it after these macros to prevent potential deadlocks in case the\napplication does something with the element when it receives an ERROR/WARNING/INFO\nmessage. Same goes for gst_element_post_message calls and non-serialized events.\nBy default, this class works by reading media data from the sinkpad, and then commencing\nplayback. Some decoders cannot be given data from a memory block, so the usual way of\nreading all upstream data and passing it to load_from_buffer doesn't work then. In this case,\nset the value of loads_from_sinkpad to FALSE. This changes the way this class operates;\nit does not require a sinkpad to exist anymore, and will call load_from_custom instead.\nOne example of a decoder where this makes sense is UADE (Unix Amiga Delitracker Emulator).\nFor some formats (such as TFMX), it needs to do the file loading by itself.\nSince most decoders can read input data from a memory block, the default value of\nloads_from_sinkpad is TRUE.\nThe parent class structure\nSubclasses can override any of the available optional virtual methods or not, as\nneeded. At minimum, load_from_buffer (or load_from_custom), get_supported_output_modes,\nand decode need to be overridden.\nAll functions are called with a locked decoder mutex.\nIf GST_ELEMENT_ERROR, GST_ELEMENT_WARNING, or GST_ELEMENT_INFO are called from\ninside one of these functions, it is strongly recommended to unlock the decoder mutex\nbefore and re-lock it after these macros to prevent potential deadlocks in case the\napplication does something with the element when it receives an ERROR/WARNING/INFO\nmessage. Same goes for Gst.Element.prototype.post_message calls and non-serialized events.\nBy default, this class works by reading media data from the sinkpad, and then commencing\nplayback. Some decoders cannot be given data from a memory block, so the usual way of\nreading all upstream data and passing it to load_from_buffer doesn't work then. In this case,\nset the value of loads_from_sinkpad to FALSE. This changes the way this class operates;\nit does not require a sinkpad to exist anymore, and will call load_from_custom instead.\nOne example of a decoder where this makes sense is UADE (Unix Amiga Delitracker Emulator).\nFor some formats (such as TFMX), it needs to do the file loading by itself.\nSince most decoders can read input data from a memory block, the default value of\nloads_from_sinkpad is TRUE.\nThe parent class structure\nSubclasses can override any of the available optional virtual methods or not, as\nneeded. At minimum, load_from_buffer (or load_from_custom), get_supported_output_modes,\nand decode need to be overridden.\nAll functions are called with a locked decoder mutex.\nIf GST_ELEMENT_ERROR, GST_ELEMENT_WARNING, or GST_ELEMENT_INFO are called from\ninside one of these functions, it is strongly recommended to unlock the decoder mutex\nbefore and re-lock it after these macros to prevent potential deadlocks in case the\napplication does something with the element when it receives an ERROR/WARNING/INFO\nmessage. Same goes for Gst.Element.post_message calls and non-serialized events.\nBy default, this class works by reading media data from the sinkpad, and then commencing\nplayback. Some decoders cannot be given data from a memory block, so the usual way of\nreading all upstream data and passing it to load_from_buffer doesn't work then. In this case,\nset the value of loads_from_sinkpad to FALSE. This changes the way this class operates;\nit does not require a sinkpad to exist anymore, and will call load_from_custom instead.\nOne example of a decoder where this makes sense is UADE (Unix Amiga Delitracker Emulator).\nFor some formats (such as TFMX), it needs to do the file loading by itself.\nSince most decoders can read input data from a memory block, the default value of\nloads_from_sinkpad is TRUE.\nThe parent class structure\nThe opaque GstBadAudio.NonstreamAudioDecoder data structure.\nThe opaque GstBadAudio.NonstreamAudioDecoder data structure.\n"});