fragment_downloaded_cb({"url":"bad-audio/gstnonstreamaudiodecoder.html#gstnonstreamaudiodecoder-page","fragment":"gstnonstreamaudiodecoder\nThis base class is for decoders which do not operate on a streaming model.\nThat is: they load the encoded media at once, as part of an initialization,\nand afterwards can decode samples (sometimes referred to as \"rendering the\nsamples\").\nThis sets it apart from GstAudioDecoder, which is a base class for\nstreaming audio decoders.\nThe base class is conceptually a mix between decoder and parser. This is\nunavoidable, since virtually no format that isn't streaming based has a\nclear distinction between parsing and decoding. As a result, this class\nalso handles seeking.\nNon-streaming audio formats tend to have some characteristics unknown to\nmore \"regular\" bitstreams. These include subsongs and looping.\nSubsongs are a set of songs-within-a-song. An analogy would be a multitrack\nrecording, where each track is its own song. The first subsong is typically\nthe \"main\" one. Subsongs were popular for video games to enable context-\naware music; for example, subsong #0 would be the \"main\" song, #1 would be\nan alternate song playing when a fight started, #2 would be heard during\nconversations etc. The base class is designed to always have at least one\nsubsong. If the subclass doesn't provide any, the base class creates a\n\"pseudo\" subsong, which is actually the whole song.\nDownstream is informed about the subsong using a table of contents (TOC),\nbut only if there are at least 2 subsongs.\nLooping refers to jumps within the song, typically backwards to the loop\nstart (although bi-directional looping is possible). The loop is defined\nby a chronological start and end; once the playback position reaches the\nloop end, it jumps back to the loop start.\nDepending on the subclass, looping may not be possible at all, or it\nmay only be possible to enable/disable it (that is, either no looping, or\nan infinite amount of loops), or it may allow for defining a finite number\nof times the loop is repeated.\nLooping can affect output in two ways. Either, the playback position is\nreset to the start of the loop, similar to what happens after a seek event.\nOr, it is not reset, so the pipeline sees playback steadily moving forwards,\nthe playback position monotonically increasing. However, seeking must\nalways happen within the confines of the defined subsong duration; for\nexample, if a subsong is 2 minutes long, steady playback is at 5 minutes\n(because infinite looping is enabled), then seeking will still place the\nposition within the 2 minute period.\nLoop count 0 means no looping. Loop count -1 means infinite looping.\nNonzero positive values indicate how often a loop shall occur.\nIf the initial subsong and loop count are set to values the subclass does\nnot support, the subclass has a chance to correct these values.\nget_property then reports the corrected versions.\nThe base class operates as follows:\nUnloaded mode\nLoaded mode\nThe relationship between (sub)song duration, output mode, and number of loops\nis defined this way (this is all done by the base class automatically):\nSegments have their duration and stop values set to GST_CLOCK_TIME_NONE in\nSTEADY mode, and to the duration of the (sub)song in LOOPING mode.\nThe duration that is returned to a DURATION query is always the duration\nof the (sub)song, regardless of number of loops or output mode. The same\ngoes for DURATION messages and tags.\nIf the number of loops is >0 or -1, durations of TOC entries are set to\nthe duration of the respective subsong in LOOPING mode and to G_MAXINT64 in\nSTEADY mode. If the number of loops is 0, entry durations are set to the\nsubsong duration regardless of the output mode.\n\n\nUnloaded mode\n\nInitial values are set. If a current subsong has already been\ndefined (for example over the command line with gst-launch), then\nthe subsong index is copied over to current_subsong .\nSame goes for the num-loops and output-mode properties.\nMedia is NOT loaded yet.\nOnce the sinkpad is activated, the process continues. The sinkpad is\nactivated in push mode, and the class accumulates the incoming media\ndata in an adapter inside the sinkpad's chain function until either an\nEOS event is received from upstream, or the number of bytes reported\nby upstream is reached. Then it loads the media, and starts the decoder\noutput task.\nIf upstream cannot respond to the size query (in bytes) of load_from_buffer\nfails, an error is reported, and the pipeline stops.\nIf there are no errors, load_from_buffer is called to load the media. The\nsubclass must at least call gst_nonstream_audio_decoder_set_output_format\nthere, and is free to make use of the initial subsong, output mode, and\nposition. If the actual output mode or position differs from the initial\nvalue,it must set the initial value to the actual one (for example, if\nthe actual starting position is always 0, set *initial_position to 0).\nIf loading is unsuccessful, an error is reported, and the pipeline\nstops. Otherwise, the base class calls get_current_subsong to retrieve\nthe actual current subsong, get_subsong_duration to report the current\nsubsong's duration in a duration event and message, and get_subsong_tags\nto send tags downstream in an event (these functions are optional; if\nset to NULL, the associated operation is skipped). Afterwards, the base\nclass switches to loaded mode, and starts the decoder output task.\n\n\n\nLoaded mode\n\nInside the decoder output task, the base class repeatedly calls decode,\nwhich returns a buffer with decoded, ready-to-play samples. If the\nsubclass reached the end of playback, decode returns FALSE, otherwise\nTRUE.\nUpon reaching a loop end, subclass either ignores that, or loops back\nto the beginning of the loop. In the latter case, if the output mode is set\nto LOOPING, the subclass must call gst_nonstream_audio_decoder_handle_loop\n*after* the playback position moved to the start of the loop. In\nSTEADY mode, the subclass must *not* call this function.\nSince many decoders only provide a callback for when the looping occurs,\nand that looping occurs inside the decoding operation itself, the following\nmechanism for subclass is suggested: set a flag inside such a callback.\nThen, in the next decode call, before doing the decoding, check this flag.\nIf it is set, gst_nonstream_audio_decoder_handle_loop is called, and the\nflag is cleared.\n(This function call is necessary in LOOPING mode because it updates the\ncurrent segment and makes sure the next buffer that is sent downstream\nhas its DISCONT flag set.)\nWhen the current subsong is switched, set_current_subsong is called.\nIf it fails, a warning is reported, and nothing else is done. Otherwise,\nit calls get_subsong_duration to get the new current subsongs's\nduration, get_subsong_tags to get its tags, reports a new duration\n(i.e. it sends a duration event downstream and generates a duration\nmessage), updates the current segment, and sends the subsong's tags in\nan event downstream. (If set_current_subsong has been set to NULL by\nthe subclass, attempts to set a current subsong are ignored; likewise,\nif get_subsong_duration is NULL, no duration is reported, and if\nget_subsong_tags is NULL, no tags are sent downstream.)\nWhen an attempt is made to switch the output mode, it is checked against\nthe bitmask returned by get_supported_output_modes. If the proposed\nnew output mode is supported, the current segment is updated\n(it is open-ended in STEADY mode, and covers the (sub)song length in\nLOOPING mode), and the subclass' set_output_mode function is called\nunless it is set to NULL. Subclasses should reset internal loop counters\nin this function.\n\n\n\n\nInitial values are set. If a current subsong has already been\ndefined (for example over the command line with gst-launch), then\nthe subsong index is copied over to current_subsong .\nSame goes for the num-loops and output-mode properties.\nMedia is NOT loaded yet.\nOnce the sinkpad is activated, the process continues. The sinkpad is\nactivated in push mode, and the class accumulates the incoming media\ndata in an adapter inside the sinkpad's chain function until either an\nEOS event is received from upstream, or the number of bytes reported\nby upstream is reached. Then it loads the media, and starts the decoder\noutput task.\nIf upstream cannot respond to the size query (in bytes) of load_from_buffer\nfails, an error is reported, and the pipeline stops.\nIf there are no errors, load_from_buffer is called to load the media. The\nsubclass must at least call gst_nonstream_audio_decoder_set_output_format\nthere, and is free to make use of the initial subsong, output mode, and\nposition. If the actual output mode or position differs from the initial\nvalue,it must set the initial value to the actual one (for example, if\nthe actual starting position is always 0, set *initial_position to 0).\nIf loading is unsuccessful, an error is reported, and the pipeline\nstops. Otherwise, the base class calls get_current_subsong to retrieve\nthe actual current subsong, get_subsong_duration to report the current\nsubsong's duration in a duration event and message, and get_subsong_tags\nto send tags downstream in an event (these functions are optional; if\nset to NULL, the associated operation is skipped). Afterwards, the base\nclass switches to loaded mode, and starts the decoder output task.\n\n\nInside the decoder output task, the base class repeatedly calls decode,\nwhich returns a buffer with decoded, ready-to-play samples. If the\nsubclass reached the end of playback, decode returns FALSE, otherwise\nTRUE.\nUpon reaching a loop end, subclass either ignores that, or loops back\nto the beginning of the loop. In the latter case, if the output mode is set\nto LOOPING, the subclass must call gst_nonstream_audio_decoder_handle_loop\n*after* the playback position moved to the start of the loop. In\nSTEADY mode, the subclass must *not* call this function.\nSince many decoders only provide a callback for when the looping occurs,\nand that looping occurs inside the decoding operation itself, the following\nmechanism for subclass is suggested: set a flag inside such a callback.\nThen, in the next decode call, before doing the decoding, check this flag.\nIf it is set, gst_nonstream_audio_decoder_handle_loop is called, and the\nflag is cleared.\n(This function call is necessary in LOOPING mode because it updates the\ncurrent segment and makes sure the next buffer that is sent downstream\nhas its DISCONT flag set.)\nWhen the current subsong is switched, set_current_subsong is called.\nIf it fails, a warning is reported, and nothing else is done. Otherwise,\nit calls get_subsong_duration to get the new current subsongs's\nduration, get_subsong_tags to get its tags, reports a new duration\n(i.e. it sends a duration event downstream and generates a duration\nmessage), updates the current segment, and sends the subsong's tags in\nan event downstream. (If set_current_subsong has been set to NULL by\nthe subclass, attempts to set a current subsong are ignored; likewise,\nif get_subsong_duration is NULL, no duration is reported, and if\nget_subsong_tags is NULL, no tags are sent downstream.)\nWhen an attempt is made to switch the output mode, it is checked against\nthe bitmask returned by get_supported_output_modes. If the proposed\nnew output mode is supported, the current segment is updated\n(it is open-ended in STEADY mode, and covers the (sub)song length in\nLOOPING mode), and the subclass' set_output_mode function is called\nunless it is set to NULL. Subclasses should reset internal loop counters\nin this function.\n\n\n\nSegments have their duration and stop values set to GST_CLOCK_TIME_NONE in\nSTEADY mode, and to the duration of the (sub)song in LOOPING mode.\n\n\nThe duration that is returned to a DURATION query is always the duration\nof the (sub)song, regardless of number of loops or output mode. The same\ngoes for DURATION messages and tags.\n\n\nIf the number of loops is >0 or -1, durations of TOC entries are set to\nthe duration of the respective subsong in LOOPING mode and to G_MAXINT64 in\nSTEADY mode. If the number of loops is 0, entry durations are set to the\nsubsong duration regardless of the output mode.\n\n\n"});