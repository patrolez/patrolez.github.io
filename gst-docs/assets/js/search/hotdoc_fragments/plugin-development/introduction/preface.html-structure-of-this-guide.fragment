fragment_downloaded_cb({"url":"plugin-development/introduction/preface.html#structure-of-this-guide","fragment":"Structure of This Guide\nTo help you navigate through this guide, it is divided into several\nlarge parts. Each part addresses a particular broad topic concerning\nGStreamer plugin development. The parts of this guide are laid out in\nthe following order:\nBuilding a Plugin - Introduction to the\nstructure of a plugin, using an example audio filter for\nillustration.\nThis part covers all the basic steps you generally need to perform\nto build a plugin, such as registering the element with GStreamer\nand setting up the basics so it can receive data from and send data\nto neighbour elements. The discussion begins by giving examples of\ngenerating the basic structures and registering an element in\nConstructing the Boilerplate. Then,\nyou will learn how to write the code to get a basic filter plugin\nworking in Specifying the pads, The chain function\nand What are states?.\nAfter that, we will show some of the GObject concepts on how to make\nan element configurable for applications and how to do\napplication-element interaction in Adding\nProperties and Signals. Next, you will learn to\nbuild a quick test application to test all that you've just learned\nin Building a Test Application. We\nwill just touch upon basics here. For full-blown application\ndevelopment, you should look at the Application Development\nManual.\nAdvanced Filter Concepts - Information on\nadvanced features of GStreamer plugin development.\nAfter learning about the basic steps, you should be able to create a\nfunctional audio or video filter plugin with some nice features.\nHowever, GStreamer offers more for plugin writers. This part of the\nguide includes chapters on more advanced topics, such as scheduling,\nmedia type definitions in GStreamer, clocks, interfaces and tagging.\nSince these features are purpose-specific, you can read them in any\norder, most of them don't require knowledge from other sections.\nThe first chapter, named Different scheduling\nmodes, will explain some of the basics of\nelement scheduling. It is not very in-depth, but is mostly some sort\nof an introduction on why other things work as they do. Read this\nchapter if you're interested in GStreamer internals. Next, we will\napply this knowledge and discuss another type of data transmission\nthan what you learned in The chain function: Different\nscheduling modes. Loop-based elements will give you\nmore control over input rate. This is useful when writing, for\nexample, muxers or demuxers.\nNext, we will discuss media identification in GStreamer in Media Types\nand Properties. You will learn how to\ndefine new media types and get to know a list of standard media\ntypes defined in GStreamer.\nIn the next chapter, you will learn the concept of request- and\nsometimes-pads, which are pads that are created dynamically, either\nbecause the application asked for it (request) or because the media\nstream requires it (sometimes). This will be in Request and\nSometimes pads.\nThe next chapter, Clocking, will\nexplain the concept of clocks in GStreamer. You need this\ninformation when you want to know how elements should achieve\naudio/video synchronization.\nThe next few chapters will discuss advanced ways of doing\napplication-element interaction. Previously, we learned on the\nGObject-ways of doing this in Adding Properties and\nSignals. We will discuss dynamic\nparameters, which are a way of defining element behaviour over time\nin advance, in Supporting Dynamic Parameters.\nNext, you will learn about interfaces in Interfaces.\nInterfaces are very target- specific ways of application-element\ninteraction, based on GObject's GInterface. Lastly, you will learn about\nhow metadata is handled in GStreamer in Tagging (Metadata and\nStreaminfo).\nThe last chapter, Events: Seeking, Navigation and More, will\ndiscuss the concept of events in GStreamer. Events are another way of\ndoing application-element interaction. They take care of seeking, for\nexample. They are also yet another way in which elements\ninteract with each other, such as letting each other know about\nmedia stream discontinuities, forwarding tags inside a pipeline and\nso on.\nCreating special element types - Explanation of\nwriting other plugin types.\nBecause the first two parts of the guide use an audio filter as an\nexample, the concepts introduced apply to filter plugins. But many\nof the concepts apply equally to other plugin types, including\nsources, sinks, and autopluggers. This part of the guide presents\nthe issues that arise when working on these more specialized plugin\ntypes. The chapter starts with a special focus on elements that can\nbe written using a base-class (Pre-made base classes),\nand later also goes into writing special types of elements in Writing a\nDemuxer or Parser, Writing a N-to-1 Element or Muxer\nand Writing a Manager.\nAppendices - Further information for plugin developers.\nThe appendices contain some information that stubbornly refuses to\nfit cleanly in other sections of the guide. Most of this section is\nnot yet finished.\nThe remainder of this introductory part of the guide presents a short\noverview of the basic concepts involved in GStreamer plugin development.\nTopics covered include Elements and Plugins,\nPads, GstMiniObject, Buffers and Events\nand Media types and Properties. If you are already\nfamiliar with this information, you can use this short overview to\nrefresh your memory, or you can skip to Building a Plugin.\nAs you can see, there's a lot to learn, so let's get started!\nCreating compound and complex elements by extending from a GstBin.\nThis will allow you to create plugins that have other plugins\nembedded in them.\nAdding new media types to the registry along with typedetect\nfunctions. This will allow your plugin to operate on a completely\nnew media type.\n\n\nBuilding a Plugin - Introduction to the\nstructure of a plugin, using an example audio filter for\nillustration.\nThis part covers all the basic steps you generally need to perform\nto build a plugin, such as registering the element with GStreamer\nand setting up the basics so it can receive data from and send data\nto neighbour elements. The discussion begins by giving examples of\ngenerating the basic structures and registering an element in\nConstructing the Boilerplate. Then,\nyou will learn how to write the code to get a basic filter plugin\nworking in Specifying the pads, The chain function\nand What are states?.\nAfter that, we will show some of the GObject concepts on how to make\nan element configurable for applications and how to do\napplication-element interaction in Adding\nProperties and Signals. Next, you will learn to\nbuild a quick test application to test all that you've just learned\nin Building a Test Application. We\nwill just touch upon basics here. For full-blown application\ndevelopment, you should look at the Application Development\nManual.\n\n\nAdvanced Filter Concepts - Information on\nadvanced features of GStreamer plugin development.\nAfter learning about the basic steps, you should be able to create a\nfunctional audio or video filter plugin with some nice features.\nHowever, GStreamer offers more for plugin writers. This part of the\nguide includes chapters on more advanced topics, such as scheduling,\nmedia type definitions in GStreamer, clocks, interfaces and tagging.\nSince these features are purpose-specific, you can read them in any\norder, most of them don't require knowledge from other sections.\nThe first chapter, named Different scheduling\nmodes, will explain some of the basics of\nelement scheduling. It is not very in-depth, but is mostly some sort\nof an introduction on why other things work as they do. Read this\nchapter if you're interested in GStreamer internals. Next, we will\napply this knowledge and discuss another type of data transmission\nthan what you learned in The chain function: Different\nscheduling modes. Loop-based elements will give you\nmore control over input rate. This is useful when writing, for\nexample, muxers or demuxers.\nNext, we will discuss media identification in GStreamer in Media Types\nand Properties. You will learn how to\ndefine new media types and get to know a list of standard media\ntypes defined in GStreamer.\nIn the next chapter, you will learn the concept of request- and\nsometimes-pads, which are pads that are created dynamically, either\nbecause the application asked for it (request) or because the media\nstream requires it (sometimes). This will be in Request and\nSometimes pads.\nThe next chapter, Clocking, will\nexplain the concept of clocks in GStreamer. You need this\ninformation when you want to know how elements should achieve\naudio/video synchronization.\nThe next few chapters will discuss advanced ways of doing\napplication-element interaction. Previously, we learned on the\nGObject-ways of doing this in Adding Properties and\nSignals. We will discuss dynamic\nparameters, which are a way of defining element behaviour over time\nin advance, in Supporting Dynamic Parameters.\nNext, you will learn about interfaces in Interfaces.\nInterfaces are very target- specific ways of application-element\ninteraction, based on GObject's GInterface. Lastly, you will learn about\nhow metadata is handled in GStreamer in Tagging (Metadata and\nStreaminfo).\nThe last chapter, Events: Seeking, Navigation and More, will\ndiscuss the concept of events in GStreamer. Events are another way of\ndoing application-element interaction. They take care of seeking, for\nexample. They are also yet another way in which elements\ninteract with each other, such as letting each other know about\nmedia stream discontinuities, forwarding tags inside a pipeline and\nso on.\n\n\nCreating special element types - Explanation of\nwriting other plugin types.\nBecause the first two parts of the guide use an audio filter as an\nexample, the concepts introduced apply to filter plugins. But many\nof the concepts apply equally to other plugin types, including\nsources, sinks, and autopluggers. This part of the guide presents\nthe issues that arise when working on these more specialized plugin\ntypes. The chapter starts with a special focus on elements that can\nbe written using a base-class (Pre-made base classes),\nand later also goes into writing special types of elements in Writing a\nDemuxer or Parser, Writing a N-to-1 Element or Muxer\nand Writing a Manager.\n\n\nAppendices - Further information for plugin developers.\nThe appendices contain some information that stubbornly refuses to\nfit cleanly in other sections of the guide. Most of this section is\nnot yet finished.\n\n\n\n\nCreating compound and complex elements by extending from a GstBin.\nThis will allow you to create plugins that have other plugins\nembedded in them.\n\n\nAdding new media types to the registry along with typedetect\nfunctions. This will allow your plugin to operate on a completely\nnew media type.\n\n\n"});