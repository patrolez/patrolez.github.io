fragment_downloaded_cb({"url":"plugin-development/introduction/basics.html#buffer-allocation","fragment":"Buffer Allocation\nBuffers are able to store chunks of memory of several different types.\nThe most generic type of buffer contains memory allocated by malloc().\nSuch buffers, although convenient, are not always very fast, since data\noften needs to be specifically copied into the buffer.\nMany specialized elements create buffers that point to special memory.\nFor example, the filesrc element usually maps a file into the address\nspace of the application (using mmap()), and creates buffers that point\ninto that address range. These buffers created by filesrc act exactly\nlike generic buffers, except that they are read-only. The buffer freeing\ncode automatically determines the correct method of freeing the\nunderlying memory. Downstream elements that receive these kinds of\nbuffers do not need to do anything special to handle or unreference it.\nAnother way an element might get specialized buffers is to request them\nfrom a downstream peer through a GstBufferPool or GstAllocator. Elements\ncan ask a GstBufferPool or GstAllocator from the downstream peer\nelement. If downstream is able to provide these objects, upstream can\nuse them to allocate buffers. See more in Memory\nallocation.\nMany sink elements have accelerated methods for copying data to\nhardware, or have direct access to hardware. It is common for these\nelements to be able to create a GstBufferPool or GstAllocator for their\nupstream peers. One such example is ximagesink. It creates buffers that\ncontain XImages. Thus, when an upstream peer copies data into the\nbuffer, it is copying directly into the XImage, enabling ximagesink to\ndraw the image directly to the screen instead of having to copy data\ninto an XImage first.\nFilter elements often have the opportunity to either work on a buffer\nin-place, or work while copying from a source buffer to a destination\nbuffer. It is optimal to implement both algorithms, since the GStreamer\nframework can choose the fastest algorithm as appropriate. Naturally,\nthis only makes sense for strict filters -- elements that have exactly\nthe same format on source and sink pads.\n"});