fragment_downloaded_cb({"url":"plugin-development/basics/testapp.html#building-a-test-application","fragment":"Building a Test Application\nOften, you will want to test your newly written plugin in an as small\nsetting as possible. Usually, gst-launch-1.0 is a good first step at\ntesting a plugin. If you have not installed your plugin in a directory\nthat GStreamer searches, then you will need to set the plugin path.\nEither set GST_PLUGIN_PATH to the directory containing your plugin, or\nuse the command-line option --gst-plugin-path. If you based your plugin\noff of the gst-plugin template, then this will look something like gst-launch-1.0 --gst-plugin-path=$HOME/gst-template/gst-plugin/src/.libs TESTPIPELINE However, you will often need more testing features than gst-launch-1.0\ncan provide, such as seeking, events, interactivity and more. Writing\nyour own small testing program is the easiest way to accomplish this.\nThis section explains - in a few words - how to do that. For a complete\napplication development guide, see the Application Development\nManual.\nAt the start, you need to initialize the GStreamer core library by\ncalling gst_init (). You can alternatively call\ngst_init_get_option_group (), which will return a pointer to\nGOptionGroup. You can then use GOption to handle the initialization, and\nthis will finish the GStreamer initialization.\nYou can create elements using gst_element_factory_make (), where the\nfirst argument is the element type that you want to create, and the\nsecond argument is a free-form name. The example at the end uses a\nsimple filesource - decoder - soundcard output pipeline, but you can use\nspecific debugging elements if that's necessary. For example, an\nidentity element can be used in the middle of the pipeline to act as a\ndata-to-application transmitter. This can be used to check the data for\nmisbehaviours or correctness in your test application. Also, you can use\na fakesink element at the end of the pipeline to dump your data to the\nstdout (in order to do this, set the dump property to TRUE). Lastly,\nyou can use valgrind to check for memory errors.\nDuring linking, your test application can use filtered caps as a way to\ndrive a specific type of data to or from your element. This is a very\nsimple and effective way of checking multiple types of input and output\nin your element.\nNote that during running, you should listen for at least the “error” and\n“eos” messages on the bus and/or your plugin/element to check for\ncorrect handling of this. Also, you should add events into the pipeline\nand make sure your plugin handles these correctly (with respect to\nclocking, internal caching, etc.).\nNever forget to clean up memory in your plugin or your test application.\nWhen going to the NULL state, your element should clean up allocated\nmemory and caches. Also, it should close down any references held to\npossible support libraries. Your application should unref () the\npipeline and make sure it doesn't crash.\n"});