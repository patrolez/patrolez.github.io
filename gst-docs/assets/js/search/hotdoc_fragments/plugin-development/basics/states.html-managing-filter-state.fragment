fragment_downloaded_cb({"url":"plugin-development/basics/states.html#managing-filter-state","fragment":"Managing filter state\nIf at all possible, your element should derive from one of the new base\nclasses (Pre-made base classes). There are\nready-made general purpose base classes for different types of sources,\nsinks and filter/transformation elements. In addition to those,\nspecialised base classes exist for audio and video elements and others.\nIf you use a base class, you will rarely have to handle state changes\nyourself. All you have to do is override the base class's start() and\nstop() virtual functions (might be called differently depending on the\nbase class) and the base class will take care of everything for you.\nIf, however, you do not derive from a ready-made base class, but from\nGstElement or some other class not built on top of a base class, you\nwill most likely have to implement your own state change function to be\nnotified of state changes. This is definitively necessary if your plugin\nis a demuxer or a muxer, as there are no base classes for muxers or\ndemuxers yet.\nAn element can be notified of state changes through a virtual function\npointer. Inside this function, the element can initialize any sort of\nspecific data needed by the element, and it can optionally fail to go\nfrom one state to another.\nDo not g_assert for unhandled state changes; this is taken care of by\nthe GstElement base class.\nNote that upwards (NULL=>READY, READY=>PAUSED, PAUSED=>PLAYING) and\ndownwards (PLAYING=>PAUSED, PAUSED=>READY, READY=>NULL) state changes\nare handled in two separate blocks with the downwards state change\nhandled only after we have chained up to the parent class's state change\nfunction. This is necessary in order to safely handle concurrent access\nby multiple threads.\nThe reason for this is that in the case of downwards state changes you\ndon't want to destroy allocated resources while your plugin's chain\nfunction (for example) is still accessing those resources in another\nthread. Whether your chain function might be running or not depends on\nthe state of your plugin's pads, and the state of those pads is closely\nlinked to the state of the element. Pad states are handled in the\nGstElement class's state change function, including proper locking,\nthat's why it is essential to chain up before destroying allocated\nresources.\n"});