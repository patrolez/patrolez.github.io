fragment_downloaded_cb({"url":"plugin-development/element-types/one-to-n.html#writing-a-demuxer-or-parser","fragment":"Writing a Demuxer or Parser\nDemuxers are the 1-to-N elements that need very special care. They are\nresponsible for timestamping raw, unparsed data into elementary video or\naudio streams, and there are many things that you can optimize or do\nwrong. Here, several culprits will be mentioned and common solutions\nwill be offered. Parsers are demuxers with only one source pad. Also,\nthey only cut the stream into buffers, they don't touch the data\notherwise.\nAs mentioned previously in Caps negotiation,\ndemuxers should use fixed caps, since their data type will not change.\nAs discussed in Different scheduling modes,\ndemuxer elements can be written in multiple ways:\nThey can be the driving force of the pipeline, by running their own\ntask. This works particularly well for elements that need random\naccess, for example an AVI demuxer.\nThey can also run in push-based mode, which means that an upstream\nelement drives the pipeline. This works particularly well for\nstreams that may come from network, such as Ogg.\nIn addition, audio parsers with one output can, in theory, also be\nwritten in random access mode. Although simple playback will mostly work\nif your element only accepts one mode, it may be required to implement\nmultiple modes to work in combination with all sorts of applications,\nsuch as editing. Also, performance may become better if you implement\nmultiple modes. See Different scheduling modes\nto see how an element can accept multiple scheduling modes.\n\n\nThey can be the driving force of the pipeline, by running their own\ntask. This works particularly well for elements that need random\naccess, for example an AVI demuxer.\n\n\nThey can also run in push-based mode, which means that an upstream\nelement drives the pipeline. This works particularly well for\nstreams that may come from network, such as Ogg.\n\n\n"});