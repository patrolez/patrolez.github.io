fragment_downloaded_cb({"url":"plugin-development/advanced/interfaces.html#video-overlay-interface","fragment":"Video Overlay Interface\nThe GstVideoOverlay interface is used for 2 main purposes:\nTo get a grab on the Window where the video sink element is going to\nrender. This is achieved by either being informed about the Window\nidentifier that the video sink element generated, or by forcing the\nvideo sink element to use a specific Window identifier for\nrendering.\nTo force a redrawing of the latest video frame the video sink\nelement displayed on the Window. Indeed if the GstPipeline is in\nGST\\_STATE\\_PAUSED state, moving the Window around will damage its\ncontent. Application developers will want to handle the Expose\nevents themselves and force the video sink element to refresh the\nWindow's content.\nA plugin drawing video output in a video window will need to have that\nwindow at one stage or another. Passive mode simply means that no window\nhas been given to the plugin before that stage, so the plugin created\nthe window by itself. In that case the plugin is responsible of\ndestroying that window when it's not needed any more and it has to tell\nthe applications that a window has been created so that the application\ncan use it. This is done using the have-window-handle message that can\nbe posted from the plugin with the gst_video_overlay_got_window_handle\nmethod.\nAs you probably guessed already active mode just means sending a video\nwindow to the plugin so that video output goes there. This is done using\nthe gst_video_overlay_set_window_handle method.\nIt is possible to switch from one mode to another at any moment, so the\nplugin implementing this interface has to handle all cases. There are\nonly 2 methods that plugins writers have to implement and they most\nprobably look like that :\nYou will also need to use the interface methods to post messages when\nneeded such as when receiving a CAPS event where you will know the video\ngeometry and maybe create the window.\n\n\nTo get a grab on the Window where the video sink element is going to\nrender. This is achieved by either being informed about the Window\nidentifier that the video sink element generated, or by forcing the\nvideo sink element to use a specific Window identifier for\nrendering.\n\n\nTo force a redrawing of the latest video frame the video sink\nelement displayed on the Window. Indeed if the GstPipeline is in\nGST\\_STATE\\_PAUSED state, moving the Window around will damage its\ncontent. Application developers will want to handle the Expose\nevents themselves and force the video sink element to refresh the\nWindow's content.\n\n\n"});