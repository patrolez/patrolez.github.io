fragment_downloaded_cb({"url":"plugin-development/advanced/events.html#segment","fragment":"Segment\nA segment event is sent downstream to announce the range of valid\ntimestamps in the stream and how they should be transformed into\nrunning-time and stream-time. A segment event must always be sent before\nthe first buffer of data and after a flush (see above).\nThe first segment event is created by the element driving the pipeline,\nlike a source operating in push-mode or a demuxer/decoder operating\npull-based. This segment event then travels down the pipeline and may be\ntransformed on the way (a decoder, for example, might receive a segment\nevent in BYTES format and might transform this into a segment event in\nTIMES format based on the average bitrate).\nDepending on the element type, the event can simply be forwarded using\ngst_pad_event_default (), or it should be parsed and a modified event\nshould be sent on. The last is true for demuxers, which generally have a\nbyte-to-time conversion concept. Their input is usually byte-based, so\nthe incoming event will have an offset in byte units\n(GST_FORMAT_BYTES), too. Elements downstream, however, expect segment\nevents in time units, so that they can be used to synchronize against the\npipeline clock. Therefore, demuxers and similar elements should not\nforward the event, but parse it, free it and send a segment event (in\ntime units, GST_FORMAT_TIME) further downstream.\nThe segment event is created using the function gst_event_new_segment (). See the API reference and design document for details about its\nparameters.\nElements parsing this event can use gst_event_parse_segment() to\nextract the event details. Elements may find the GstSegment API useful\nto keep track of the current segment (if they want to use it for output\nclipping, for example).\n"});