fragment_downloaded_cb({"url":"plugin-development/advanced/scheduling.html#pads-driving-the-pipeline","fragment":"Pads driving the pipeline\nSinkpads operating in pull-mode, with the sourcepads operating in\npush-mode (or it has no sourcepads when it is a sink), can start a task\nthat will drive the pipeline data flow. Within this task function, you\nhave random access over all of the sinkpads, and push data over the\nsourcepads. This can come in useful for several different kinds of\nelements:\nDemuxers, parsers and certain kinds of decoders where data comes in\nunparsed (such as MPEG-audio or video streams), since those will\nprefer byte-exact (random) access from their input. If possible,\nhowever, such elements should be prepared to operate in push-mode\nmode, too.\nCertain kind of audio outputs, which require control over their\ninput data flow, such as the Jack sound server.\nFirst you need to perform a SCHEDULING query to check if the upstream\nelement(s) support pull-mode scheduling. If that is possible, you can\nactivate the sinkpad in pull-mode. Inside the activate_mode function\nyou can then start the task.\nOnce started, your task has full control over input and output. The most\nsimple case of a task function is one that reads input and pushes that\nover its source pad. It's not all that useful, but provides some more\nflexibility than the old push-mode case that we've been looking at so\nfar.\n\n\nDemuxers, parsers and certain kinds of decoders where data comes in\nunparsed (such as MPEG-audio or video streams), since those will\nprefer byte-exact (random) access from their input. If possible,\nhowever, such elements should be prepared to operate in push-mode\nmode, too.\n\n\nCertain kind of audio outputs, which require control over their\ninput data flow, such as the Jack sound server.\n\n\n"});