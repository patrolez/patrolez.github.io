fragment_downloaded_cb({"url":"plugin-development/advanced/scheduling.html#the-pad-activation-stage","fragment":"The pad activation stage\nDuring the element state change of READY->PAUSED, the pads of an\nelement will be activated. This happens first on the source pads and\nthen on the sink pads of the element. GStreamer calls the _activate ()\nof a pad. By default this function will activate the pad in push-mode by\ncalling gst_pad_activate_mode () with the GST_PAD_MODE_PUSH\nscheduling mode. It is possible to override the _activate () of a pad\nand decide on a different scheduling mode. You can know in what\nscheduling mode a pad is activated by overriding the _activate_mode ()-function.\nGStreamer allows the different pads of an element to operate in\ndifferent scheduling modes. This allows for many different possible\nuse-cases. What follows is an overview of some typical use-cases.\nIf all pads of an element are activated in push-mode scheduling, the\nelement as a whole is operating in push-mode. For source elements\nthis means that they will have to start a task that pushes out\nbuffers on the source pad to the downstream elements. Downstream\nelements will have data pushed to them by upstream elements using\nthe sinkpads _chain ()-function which will push out buffers on the\nsource pads. Prerequisites for this scheduling mode are that a\nchain-function was set for each sinkpad using\ngst_pad_set_chain_function () and that all downstream elements\noperate in the same mode.\nAlternatively, sinkpads can be the driving force behind a pipeline\nby operating in pull-mode, while the sourcepads of the element still\noperate in push-mode. In order to be the driving force, those pads\nstart a GstTask when they are activated. This task is a thread,\nwhich will call a function specified by the element. When called,\nthis function will have random data access (through\ngst_pad_pull_range ()) over all sinkpads, and can push data over\nthe sourcepads, which effectively means that this element controls\ndata flow in the pipeline. Prerequisites for this mode are that all\ndownstream elements can act in push mode, and that all upstream\nelements operate in pull-mode (see below).\nSource pads can be activated in PULL mode by a downstream element\nwhen they return GST_PAD_MODE_PULL from the\nGST_QUERY_SCHEDULING query. Prerequisites for this scheduling mode\nare that a getrange-function was set for the source pad using\ngst_pad_set_getrange_function ().\nLastly, all pads in an element can be activated in PULL-mode.\nHowever, contrary to the above, this does not mean that they start a\ntask on their own. Rather, it means that they are pull slave for the\ndownstream element, and have to provide random data access to it\nfrom their _get_range ()-function. Requirements are that the a\n_get_range ()-function was set on this pad using the function\ngst_pad_set_getrange_function (). Also, if the element has any\nsinkpads, all those pads (and thereby their peers) need to operate\nin PULL access mode, too.\nWhen a sink element is activated in PULL mode, it should start a\ntask that calls gst_pad_pull_range () on its sinkpad. It can only\ndo this when the upstream SCHEDULING query returns support for the\nGST_PAD_MODE_PULL scheduling mode.\nIn the next two sections, we will go closer into pull-mode scheduling\n(elements/pads driving the pipeline, and elements/pads providing random\naccess), and some specific use cases will be given.\n\n\nIf all pads of an element are activated in push-mode scheduling, the\nelement as a whole is operating in push-mode. For source elements\nthis means that they will have to start a task that pushes out\nbuffers on the source pad to the downstream elements. Downstream\nelements will have data pushed to them by upstream elements using\nthe sinkpads _chain ()-function which will push out buffers on the\nsource pads. Prerequisites for this scheduling mode are that a\nchain-function was set for each sinkpad using\ngst_pad_set_chain_function () and that all downstream elements\noperate in the same mode.\n\n\nAlternatively, sinkpads can be the driving force behind a pipeline\nby operating in pull-mode, while the sourcepads of the element still\noperate in push-mode. In order to be the driving force, those pads\nstart a GstTask when they are activated. This task is a thread,\nwhich will call a function specified by the element. When called,\nthis function will have random data access (through\ngst_pad_pull_range ()) over all sinkpads, and can push data over\nthe sourcepads, which effectively means that this element controls\ndata flow in the pipeline. Prerequisites for this mode are that all\ndownstream elements can act in push mode, and that all upstream\nelements operate in pull-mode (see below).\nSource pads can be activated in PULL mode by a downstream element\nwhen they return GST_PAD_MODE_PULL from the\nGST_QUERY_SCHEDULING query. Prerequisites for this scheduling mode\nare that a getrange-function was set for the source pad using\ngst_pad_set_getrange_function ().\n\n\nLastly, all pads in an element can be activated in PULL-mode.\nHowever, contrary to the above, this does not mean that they start a\ntask on their own. Rather, it means that they are pull slave for the\ndownstream element, and have to provide random data access to it\nfrom their _get_range ()-function. Requirements are that the a\n_get_range ()-function was set on this pad using the function\ngst_pad_set_getrange_function (). Also, if the element has any\nsinkpads, all those pads (and thereby their peers) need to operate\nin PULL access mode, too.\nWhen a sink element is activated in PULL mode, it should start a\ntask that calls gst_pad_pull_range () on its sinkpad. It can only\ndo this when the upstream SCHEDULING query returns support for the\nGST_PAD_MODE_PULL scheduling mode.\n\n\n"});