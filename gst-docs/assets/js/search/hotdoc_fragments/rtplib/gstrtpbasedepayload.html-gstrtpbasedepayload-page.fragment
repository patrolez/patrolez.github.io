fragment_downloaded_cb({"url":"rtplib/gstrtpbasedepayload.html#gstrtpbasedepayload-page","fragment":"GstRTPBaseDepayload\nProvides a base class for RTP depayloaders\nIn order to handle RTP header extensions correctly if the\ndepayloader aggregates multiple RTP packet payloads into one output\nbuffer this class provides the function\ngst_rtp_base_depayload_set_aggregate_hdrext_enabled. If the\naggregation is enabled the virtual functions\nGstRTPBaseDepayload.process or\nGstRTPBaseDepayload.process_rtp_packet must tell the base class\nwhat happens to the current RTP packet. By default the base class\nassumes that the packet payload is used with the next output\nbuffer.\nIf the RTP packet will not be used with an output buffer\ngst_rtp_base_depayload_dropped must be called. A typical\nsituation would be if we are waiting for a keyframe.\nIf the RTP packet will be used but not with the current output\nbuffer but with the next one gst_rtp_base_depayload_delayed must\nbe called. This may happen if the current RTP packet signals the\nstart of a new output buffer and the currently processed output\nbuffer will be pushed first. The undelay happens implicitly once\nthe current buffer has been pushed or\ngst_rtp_base_depayload_flush has been called.\nIf gst_rtp_base_depayload_flush is called all RTP packets that\nhave not been dropped since the last output buffer are dropped,\ne.g. if an output buffer is discarded due to malformed data. This\nmay or may not include the current RTP packet depending on the 2nd\nparameter keep_current.\nBe aware that in case gst_rtp_base_depayload_push_list is used\neach buffer will see the same list of RTP header extensions.\n"});