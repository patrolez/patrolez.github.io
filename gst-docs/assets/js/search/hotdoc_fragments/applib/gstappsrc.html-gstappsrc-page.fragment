fragment_downloaded_cb({"url":"applib/gstappsrc.html#gstappsrc-page","fragment":"GstAppSrc\nThe appsrc element can be used by applications to insert data into a\nGStreamer pipeline. Unlike most GStreamer elements, appsrc provides\nexternal API functions.\nappsrc can be used by linking with the libgstapp library to access the\nmethods directly or by using the appsrc action signals.\nBefore operating appsrc, the caps property must be set to fixed caps\ndescribing the format of the data that will be pushed with appsrc. An\nexception to this is when pushing buffers with unknown caps, in which case no\ncaps should be set. This is typically true of file-like sources that push raw\nbyte buffers. If you don't want to explicitly set the caps, you can use\ngst_app_src_push_sample. This method gets the caps associated with the\nsample and sets them on the appsrc replacing any previously set caps (if\ndifferent from sample's caps).\nThe main way of handing data to the appsrc element is by calling the\ngst_app_src_push_buffer method or by emitting the push-buffer action signal.\nThis will put the buffer onto a queue from which appsrc will read from in its\nstreaming thread. It is important to note that data transport will not happen\nfrom the thread that performed the push-buffer call.\nThe \"max-bytes\", \"max-buffers\" and \"max-time\" properties control how much\ndata can be queued in appsrc before appsrc considers the queue full. A\nfilled internal queue will always signal the \"enough-data\" signal, which\nsignals the application that it should stop pushing data into appsrc. The\n\"block\" property will cause appsrc to block the push-buffer method until\nfree data becomes available again.\nWhen the internal queue is running out of data, the \"need-data\" signal is\nemitted, which signals the application that it should start pushing more data\ninto appsrc.\nIn addition to the \"need-data\" and \"enough-data\" signals, appsrc can emit the\n\"seek-data\" signal when the \"stream-mode\" property is set to \"seekable\" or\n\"random-access\". The signal argument will contain the new desired position in\nthe stream expressed in the unit set with the \"format\" property. After\nreceiving the seek-data signal, the application should push-buffers from the\nnew position.\nThese signals allow the application to operate the appsrc in two different\nways:\nThe push mode, in which the application repeatedly calls the push-buffer/push-sample\nmethod with a new buffer/sample. Optionally, the queue size in the appsrc\ncan be controlled with the enough-data and need-data signals by respectively\nstopping/starting the push-buffer/push-sample calls. This is a typical\nmode of operation for the stream-type \"stream\" and \"seekable\". Use this\nmode when implementing various network protocols or hardware devices.\nThe pull mode, in which the need-data signal triggers the next push-buffer call.\nThis mode is typically used in the \"random-access\" stream-type. Use this\nmode for file access or other randomly accessible sources. In this mode, a\nbuffer of exactly the amount of bytes given by the need-data signal should be\npushed into appsrc.\nIn all modes, the size property on appsrc should contain the total stream\nsize in bytes. Setting this property is mandatory in the random-access mode.\nFor the stream and seekable modes, setting this property is optional but\nrecommended.\nWhen the application has finished pushing data into appsrc, it should call\ngst_app_src_end_of_stream or emit the end-of-stream action signal. After\nthis call, no more buffers can be pushed into appsrc until a flushing seek\noccurs or the state of the appsrc has gone through READY.\n"});