fragment_downloaded_cb({"url":"rswebrtc/index.html#features","fragment":"Features\nwebrtcsink implements the following features:\nBuilt-in signaller: when using the default signalling server, this element\nwill perform signalling without requiring application interaction.\nThis makes it usable directly from gst-launch.\nApplication-provided signalling: webrtcsink can be instantiated by an\napplication with a custom signaller. That signaller must be a GObject, and\nmust implement the Signallable interface as defined\nhere. The default signaller\ncan be used as an example.\nAn example is also available to use as a boilerplate for\nimplementing and using a custom signaller.\nSandboxed consumers: when a consumer is added, its encoder / payloader /\nwebrtcbin elements run in a separately managed pipeline. This provides a\ncertain level of sandboxing, as opposed to having those elements running\ninside the element itself.\nIt is important to note that at this moment, encoding is not shared between\nconsumers. While this is not on the roadmap at the moment, nothing in the\ndesign prevents implementing this optimization.\nCongestion control: the element leverages transport-wide congestion control\nfeedback messages in order to adapt the bitrate of individual consumers' video\nencoders to the available bandwidth.\nConfiguration: the level of user control over the element is slowly expanding,\nconsult gst-inspect-1.0 for more information on the available properties and\nsignals.\nPacket loss mitigation: webrtcsink now supports sending protection packets for\nForward Error Correction, modulating the amount as a function of the available\nbandwidth, and can honor retransmission requests. Both features can be\ndisabled via properties.\nIt is important to note that full control over the individual elements used by\nwebrtcsink is not on the roadmap, as it will act as a black box in that\nrespect, for example webrtcsink wants to reserve control over the bitrate for\ncongestion control.\nA signal is now available however for the application to provide the initial\nconfiguration for the encoders webrtcsink instantiates.\nIf more granular control is required, applications should use webrtcbin\ndirectly, webrtcsink will focus on trying to just do the right thing, although\nit might expose more interfaces to guide and tune the heuristics it employs.\n\n\nBuilt-in signaller: when using the default signalling server, this element\nwill perform signalling without requiring application interaction.\nThis makes it usable directly from gst-launch.\n\n\nApplication-provided signalling: webrtcsink can be instantiated by an\napplication with a custom signaller. That signaller must be a GObject, and\nmust implement the Signallable interface as defined\nhere. The default signaller\ncan be used as an example.\nAn example is also available to use as a boilerplate for\nimplementing and using a custom signaller.\n\n\nSandboxed consumers: when a consumer is added, its encoder / payloader /\nwebrtcbin elements run in a separately managed pipeline. This provides a\ncertain level of sandboxing, as opposed to having those elements running\ninside the element itself.\nIt is important to note that at this moment, encoding is not shared between\nconsumers. While this is not on the roadmap at the moment, nothing in the\ndesign prevents implementing this optimization.\n\n\nCongestion control: the element leverages transport-wide congestion control\nfeedback messages in order to adapt the bitrate of individual consumers' video\nencoders to the available bandwidth.\n\n\nConfiguration: the level of user control over the element is slowly expanding,\nconsult gst-inspect-1.0 for more information on the available properties and\nsignals.\n\n\nPacket loss mitigation: webrtcsink now supports sending protection packets for\nForward Error Correction, modulating the amount as a function of the available\nbandwidth, and can honor retransmission requests. Both features can be\ndisabled via properties.\n\n\n"});