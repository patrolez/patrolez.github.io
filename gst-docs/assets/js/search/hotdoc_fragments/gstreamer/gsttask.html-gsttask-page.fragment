fragment_downloaded_cb({"url":"gstreamer/gsttask.html#gsttask-page","fragment":"GstTask\nGstTask is used by GstElement and GstPad to provide the data passing\nthreads in a GstPipeline.\nA GstPad will typically start a GstTask to push or pull data to/from the\npeer pads. Most source elements start a GstTask to push data. In some cases\na demuxer element can start a GstTask to pull data from a peer element. This\nis typically done when the demuxer can perform random access on the upstream\npeer element for improved performance.\nAlthough convenience functions exist on GstPad to start/pause/stop tasks, it\nmight sometimes be needed to create a GstTask manually if it is not related to\na GstPad.\nBefore the GstTask can be run, it needs a GRecMutex that can be set with\ngst_task_set_lock.\nThe task can be started, paused and stopped with gst_task_start, gst_task_pause\nand gst_task_stop respectively or with the gst_task_set_state function.\nA GstTask will repeatedly call the GstTaskFunction with the user data\nthat was provided when creating the task with gst_task_new. While calling\nthe function it will acquire the provided lock. The provided lock is released\nwhen the task pauses or stops.\nStopping a task with gst_task_stop will not immediately make sure the task is\nnot running anymore. Use gst_task_join to make sure the task is completely\nstopped and the thread is stopped.\nAfter creating a GstTask, use gst_object_unref to free its resources. This can\nonly be done when the task is not running anymore.\nTask functions can send a GstMessage to send out-of-band data to the\napplication. The application can receive messages from the GstBus in its\nmainloop.\nFor debugging purposes, the task will configure its object name as the thread\nname on Linux. Please note that the object name should be configured before the\ntask is started; changing the object name after the task has been started, has\nno effect on the thread name.\n"});