fragment_downloaded_cb({"url":"gstreamer/gstbus.html#gst_bus_poll","fragment":"\n\tgst_bus_poll\n\n\n\tGst.Bus.prototype.poll\n\n\n\tGst.Bus.poll\n\nPolls the bus for messages. Will block while waiting for messages to come.\nYou can specify a maximum time to poll with the timeout parameter. If\ntimeout is negative, this function will block indefinitely.\nAll messages not in events will be popped off the bus and will be ignored.\nIt is not possible to use message enums beyond GST_MESSAGE_EXTENDED in the\nevents mask\nBecause poll is implemented using the \"message\" signal enabled by\ngst_bus_add_signal_watch, calling gst_bus_poll will cause the \"message\"\nsignal to be emitted for every message that poll sees. Thus a \"message\"\nsignal handler will see the same messages that this function sees -- neither\nwill steal messages from the other.\nThis function will run a GMainLoop from the default main context when\npolling.\nYou should never use this function, since it is pure evil. This is\nespecially true for GUI applications based on Gtk+ or Qt, but also for any\nother non-trivial application that uses the GLib main loop. As this function\nruns a GLib main loop, any callback attached to the default GLib main\ncontext may be invoked. This could be timeouts, GUI events, I/O events etc.;\neven if gst_bus_poll is called with a 0 timeout. Any of these callbacks\nmay do things you do not expect, e.g. destroy the main application window or\nsome other resource; change other application state; display a dialog and\nrun another main loop until the user clicks it away. In short, using this\nfunction may add a lot of complexity to your code through unexpected\nre-entrancy and unexpected changes to your application's state.\nFor 0 timeouts use gst_bus_pop_filtered instead of this function; for\nother short timeouts use gst_bus_timed_pop_filtered; everything else is\nbetter handled by setting up an asynchronous bus watch and doing things\nfrom there.\nParameters:\na GstBus\na mask of GstMessageType, representing the set of message types to\npoll for (note special handling of extended message types below)\nthe poll timeout, as a GstClockTime, or GST_CLOCK_TIME_NONE to poll\nindefinitely.\nthe message that was received,\nor NULL if the poll timed out.\nPolls the bus for messages. Will block while waiting for messages to come.\nYou can specify a maximum time to poll with the timeout parameter. If\ntimeout is negative, this function will block indefinitely.\nAll messages not in events will be popped off the bus and will be ignored.\nIt is not possible to use message enums beyond Gst.MessageType.EXTENDED in the\nevents mask\nBecause poll is implemented using the \"message\" signal enabled by\nGst.Bus.prototype.add_signal_watch, calling Gst.Bus.prototype.poll will cause the \"message\"\nsignal to be emitted for every message that poll sees. Thus a \"message\"\nsignal handler will see the same messages that this function sees -- neither\nwill steal messages from the other.\nThis function will run a GLib.MainLoop from the default main context when\npolling.\nYou should never use this function, since it is pure evil. This is\nespecially true for GUI applications based on Gtk+ or Qt, but also for any\nother non-trivial application that uses the GLib main loop. As this function\nruns a GLib main loop, any callback attached to the default GLib main\ncontext may be invoked. This could be timeouts, GUI events, I/O events etc.;\neven if Gst.Bus.prototype.poll is called with a 0 timeout. Any of these callbacks\nmay do things you do not expect, e.g. destroy the main application window or\nsome other resource; change other application state; display a dialog and\nrun another main loop until the user clicks it away. In short, using this\nfunction may add a lot of complexity to your code through unexpected\nre-entrancy and unexpected changes to your application's state.\nFor 0 timeouts use Gst.Bus.prototype.pop_filtered instead of this function; for\nother short timeouts use Gst.Bus.prototype.timed_pop_filtered; everything else is\nbetter handled by setting up an asynchronous bus watch and doing things\nfrom there.\nParameters:\na Gst.Bus\na mask of Gst.MessageType, representing the set of message types to\npoll for (note special handling of extended message types below)\nthe poll timeout, as a Number, or Gst.CLOCK_TIME_NONE to poll\nindefinitely.\nthe message that was received,\nor null if the poll timed out.\nPolls the bus for messages. Will block while waiting for messages to come.\nYou can specify a maximum time to poll with the timeout parameter. If\ntimeout is negative, this function will block indefinitely.\nAll messages not in events will be popped off the bus and will be ignored.\nIt is not possible to use message enums beyond Gst.MessageType.EXTENDED in the\nevents mask\nBecause poll is implemented using the \"message\" signal enabled by\nGst.Bus.add_signal_watch, calling Gst.Bus.poll will cause the \"message\"\nsignal to be emitted for every message that poll sees. Thus a \"message\"\nsignal handler will see the same messages that this function sees -- neither\nwill steal messages from the other.\nThis function will run a GLib.MainLoop from the default main context when\npolling.\nYou should never use this function, since it is pure evil. This is\nespecially true for GUI applications based on Gtk+ or Qt, but also for any\nother non-trivial application that uses the GLib main loop. As this function\nruns a GLib main loop, any callback attached to the default GLib main\ncontext may be invoked. This could be timeouts, GUI events, I/O events etc.;\neven if Gst.Bus.poll is called with a 0 timeout. Any of these callbacks\nmay do things you do not expect, e.g. destroy the main application window or\nsome other resource; change other application state; display a dialog and\nrun another main loop until the user clicks it away. In short, using this\nfunction may add a lot of complexity to your code through unexpected\nre-entrancy and unexpected changes to your application's state.\nFor 0 timeouts use Gst.Bus.pop_filtered instead of this function; for\nother short timeouts use Gst.Bus.timed_pop_filtered; everything else is\nbetter handled by setting up an asynchronous bus watch and doing things\nfrom there.\nParameters:\na Gst.Bus\na mask of Gst.MessageType, representing the set of message types to\npoll for (note special handling of extended message types below)\nthe poll timeout, as a int, or Gst.CLOCK_TIME_NONE to poll\nindefinitely.\nthe message that was received,\nor None if the poll timed out.\n"});