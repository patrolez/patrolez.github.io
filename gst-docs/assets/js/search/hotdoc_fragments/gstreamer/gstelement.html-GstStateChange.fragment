fragment_downloaded_cb({"url":"gstreamer/gstelement.html#GstStateChange","fragment":"\n\tGstStateChange\n\nMembers\n\n\tGst.StateChange\n\nMembers\n\n\tGst.StateChange\n\nMembers\nThese are the different state changes an element goes through.\nGST_STATE_NULL ⇒ GST_STATE_PLAYING is called an upwards state change\nand GST_STATE_PLAYING ⇒ GST_STATE_NULL a downwards state change.\nstate change from NULL to READY.\nstate change from READY to PAUSED.\nstate change from PAUSED to PLAYING.\nstate change from PLAYING to PAUSED.\nstate change from PAUSED to READY.\nstate change from READY to NULL.\nstate change from NULL to NULL. (Since: 1.14)\nstate change from READY to READY,\nThis might happen when going to PAUSED asynchronously failed, in that case\nelements should make sure they are in a proper, coherent READY state. (Since: 1.14)\nstate change from PAUSED to PAUSED.\nThis might happen when elements were in PLAYING state and 'lost state',\nthey should make sure to go back to real 'PAUSED' state (prerolling for example). (Since: 1.14)\nstate change from PLAYING to PLAYING. (Since: 1.14)\nThese are the different state changes an element goes through.\nGst.State.NULL ⇒ Gst.State.PLAYING is called an upwards state change\nand Gst.State.PLAYING ⇒ Gst.State.NULL a downwards state change.\nstate change from NULL to READY.\nstate change from READY to PAUSED.\nstate change from PAUSED to PLAYING.\nstate change from PLAYING to PAUSED.\nstate change from PAUSED to READY.\nstate change from READY to NULL.\nstate change from NULL to NULL. (Since: 1.14)\nstate change from READY to READY,\nThis might happen when going to PAUSED asynchronously failed, in that case\nelements should make sure they are in a proper, coherent READY state. (Since: 1.14)\nstate change from PAUSED to PAUSED.\nThis might happen when elements were in PLAYING state and 'lost state',\nthey should make sure to go back to real 'PAUSED' state (prerolling for example). (Since: 1.14)\nstate change from PLAYING to PLAYING. (Since: 1.14)\nThese are the different state changes an element goes through.\nGst.State.NULL ⇒ Gst.State.PLAYING is called an upwards state change\nand Gst.State.PLAYING ⇒ Gst.State.NULL a downwards state change.\nstate change from NULL to READY.\nstate change from READY to PAUSED.\nstate change from PAUSED to PLAYING.\nstate change from PLAYING to PAUSED.\nstate change from PAUSED to READY.\nstate change from READY to NULL.\nstate change from NULL to NULL. (Since: 1.14)\nstate change from READY to READY,\nThis might happen when going to PAUSED asynchronously failed, in that case\nelements should make sure they are in a proper, coherent READY state. (Since: 1.14)\nstate change from PAUSED to PAUSED.\nThis might happen when elements were in PLAYING state and 'lost state',\nthey should make sure to go back to real 'PAUSED' state (prerolling for example). (Since: 1.14)\nstate change from PLAYING to PLAYING. (Since: 1.14)\n\nThe element must check if the resources it needs are available. Device\nsinks and -sources typically try to probe the device to constrain their\ncaps.\nThe element opens the device (in case feature need to be probed).\n\n\nThe element pads are activated in order to receive data in PAUSED.\nStreaming threads are started.\nSome elements might need to return GST_STATE_CHANGE_ASYNC and complete\nthe state change when they have enough information. It is a requirement\nfor sinks to return GST_STATE_CHANGE_ASYNC and complete the state change\nwhen they receive the first buffer or GST_EVENT_EOS (preroll).\nSinks also block the dataflow when in PAUSED.\nA pipeline resets the running_time to 0.\nLive sources return GST_STATE_CHANGE_NO_PREROLL and don't generate data.\n\n\nMost elements ignore this state change.\nThe pipeline selects a GstClock and distributes this to all the children\nbefore setting them to PLAYING. This means that it is only allowed to\nsynchronize on the GstClock in the PLAYING state.\nThe pipeline uses the GstClock and the running_time to calculate the\nbase_time. The base_time is distributed to all children when performing\nthe state change.\nSink elements stop blocking on the preroll buffer or event and start\nrendering the data.\nSinks can post GST_MESSAGE_EOS in the PLAYING state. It is not allowed\nto post GST_MESSAGE_EOS when not in the PLAYING state.\nWhile streaming in PAUSED or PLAYING elements can create and remove\nsometimes pads.\nLive sources start generating data and return GST_STATE_CHANGE_SUCCESS.\n\n\nMost elements ignore this state change.\nThe pipeline calculates the running_time based on the last selected\nGstClock and the base_time. It stores this information to continue\nplayback when going back to the PLAYING state.\nSinks unblock any GstClock wait calls.\nWhen a sink does not have a pending buffer to play, it returns\nGST_STATE_CHANGE_ASYNC from this state change and completes the state\nchange when it receives a new buffer or an GST_EVENT_EOS.\nAny queued GST_MESSAGE_EOS items are removed since they will be reposted\nwhen going back to the PLAYING state. The EOS messages are queued in\nGstBin containers.\nLive sources stop generating data and return GST_STATE_CHANGE_NO_PREROLL.\n\n\nSinks unblock any waits in the preroll.\nElements unblock any waits on devices\nChain or get_range functions return GST_FLOW_FLUSHING.\nThe element pads are deactivated so that streaming becomes impossible and\nall streaming threads are stopped.\nThe sink forgets all negotiated formats\nElements remove all sometimes pads\n\n\nElements close devices\nElements reset any internal state.\n\n\nThe element must check if the resources it needs are available. Device\nsinks and -sources typically try to probe the device to constrain their\ncaps.\nThe element opens the device (in case feature need to be probed).\n\n\nThe element pads are activated in order to receive data in PAUSED.\nStreaming threads are started.\nSome elements might need to return Gst.StateChangeReturn.ASYNC and complete\nthe state change when they have enough information. It is a requirement\nfor sinks to return Gst.StateChangeReturn.ASYNC and complete the state change\nwhen they receive the first buffer or Gst.EventType.EOS (preroll).\nSinks also block the dataflow when in PAUSED.\nA pipeline resets the running_time to 0.\nLive sources return Gst.StateChangeReturn.NO_PREROLL and don't generate data.\n\n\nMost elements ignore this state change.\nThe pipeline selects a Gst.Clock and distributes this to all the children\nbefore setting them to PLAYING. This means that it is only allowed to\nsynchronize on the Gst.Clock in the PLAYING state.\nThe pipeline uses the Gst.Clock and the running_time to calculate the\nbase_time. The base_time is distributed to all children when performing\nthe state change.\nSink elements stop blocking on the preroll buffer or event and start\nrendering the data.\nSinks can post Gst.MessageType.EOS in the PLAYING state. It is not allowed\nto post Gst.MessageType.EOS when not in the PLAYING state.\nWhile streaming in PAUSED or PLAYING elements can create and remove\nsometimes pads.\nLive sources start generating data and return Gst.StateChangeReturn.SUCCESS.\n\n\nMost elements ignore this state change.\nThe pipeline calculates the running_time based on the last selected\nGst.Clock and the base_time. It stores this information to continue\nplayback when going back to the PLAYING state.\nSinks unblock any Gst.Clock wait calls.\nWhen a sink does not have a pending buffer to play, it returns\nGst.StateChangeReturn.ASYNC from this state change and completes the state\nchange when it receives a new buffer or an Gst.EventType.EOS.\nAny queued Gst.MessageType.EOS items are removed since they will be reposted\nwhen going back to the PLAYING state. The EOS messages are queued in\nGst.Bin containers.\nLive sources stop generating data and return Gst.StateChangeReturn.NO_PREROLL.\n\n\nSinks unblock any waits in the preroll.\nElements unblock any waits on devices\nChain or get_range functions return Gst.FlowReturn.FLUSHING.\nThe element pads are deactivated so that streaming becomes impossible and\nall streaming threads are stopped.\nThe sink forgets all negotiated formats\nElements remove all sometimes pads\n\n\nElements close devices\nElements reset any internal state.\n\n\nThe element must check if the resources it needs are available. Device\nsinks and -sources typically try to probe the device to constrain their\ncaps.\nThe element opens the device (in case feature need to be probed).\n\n\nThe element pads are activated in order to receive data in PAUSED.\nStreaming threads are started.\nSome elements might need to return Gst.StateChangeReturn.ASYNC and complete\nthe state change when they have enough information. It is a requirement\nfor sinks to return Gst.StateChangeReturn.ASYNC and complete the state change\nwhen they receive the first buffer or Gst.EventType.EOS (preroll).\nSinks also block the dataflow when in PAUSED.\nA pipeline resets the running_time to 0.\nLive sources return Gst.StateChangeReturn.NO_PREROLL and don't generate data.\n\n\nMost elements ignore this state change.\nThe pipeline selects a Gst.Clock and distributes this to all the children\nbefore setting them to PLAYING. This means that it is only allowed to\nsynchronize on the Gst.Clock in the PLAYING state.\nThe pipeline uses the Gst.Clock and the running_time to calculate the\nbase_time. The base_time is distributed to all children when performing\nthe state change.\nSink elements stop blocking on the preroll buffer or event and start\nrendering the data.\nSinks can post Gst.MessageType.EOS in the PLAYING state. It is not allowed\nto post Gst.MessageType.EOS when not in the PLAYING state.\nWhile streaming in PAUSED or PLAYING elements can create and remove\nsometimes pads.\nLive sources start generating data and return Gst.StateChangeReturn.SUCCESS.\n\n\nMost elements ignore this state change.\nThe pipeline calculates the running_time based on the last selected\nGst.Clock and the base_time. It stores this information to continue\nplayback when going back to the PLAYING state.\nSinks unblock any Gst.Clock wait calls.\nWhen a sink does not have a pending buffer to play, it returns\nGst.StateChangeReturn.ASYNC from this state change and completes the state\nchange when it receives a new buffer or an Gst.EventType.EOS.\nAny queued Gst.MessageType.EOS items are removed since they will be reposted\nwhen going back to the PLAYING state. The EOS messages are queued in\nGst.Bin containers.\nLive sources stop generating data and return Gst.StateChangeReturn.NO_PREROLL.\n\n\nSinks unblock any waits in the preroll.\nElements unblock any waits on devices\nChain or get_range functions return Gst.FlowReturn.FLUSHING.\nThe element pads are deactivated so that streaming becomes impossible and\nall streaming threads are stopped.\nThe sink forgets all negotiated formats\nElements remove all sometimes pads\n\n\nElements close devices\nElements reset any internal state.\n\n"});