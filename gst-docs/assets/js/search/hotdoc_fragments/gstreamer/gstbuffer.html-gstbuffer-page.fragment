fragment_downloaded_cb({"url":"gstreamer/gstbuffer.html#gstbuffer-page","fragment":"GstBuffer\nBuffers are the basic unit of data transfer in GStreamer. They contain the\ntiming and offset along with other arbitrary metadata that is associated\nwith the GstMemory blocks that the buffer contains.\nBuffers are usually created with gst_buffer_new. After a buffer has been\ncreated one will typically allocate memory for it and add it to the buffer.\nThe following example creates a buffer that can hold a given video frame\nwith a given width, height and bits per plane.\nAlternatively, use gst_buffer_new_allocate to create a buffer with\npreallocated data of a given size.\nBuffers can contain a list of GstMemory objects. You can retrieve how many\nmemory objects with gst_buffer_n_memory and you can get a pointer\nto memory with gst_buffer_peek_memory\nA buffer will usually have timestamps, and a duration, but neither of these\nare guaranteed (they may be set to GST_CLOCK_TIME_NONE). Whenever a\nmeaningful value can be given for these, they should be set. The timestamps\nand duration are measured in nanoseconds (they are GstClockTime values).\nThe buffer DTS refers to the timestamp when the buffer should be decoded and\nis usually monotonically increasing. The buffer PTS refers to the timestamp when\nthe buffer content should be presented to the user and is not always\nmonotonically increasing.\nA buffer can also have one or both of a start and an end offset. These are\nmedia-type specific. For video buffers, the start offset will generally be\nthe frame number. For audio buffers, it will be the number of samples\nproduced so far. For compressed data, it could be the byte offset in a\nsource or destination file. Likewise, the end offset will be the offset of\nthe end of the buffer. These can only be meaningfully interpreted if you\nknow the media type of the buffer (the preceding CAPS event). Either or both\ncan be set to GST_BUFFER_OFFSET_NONE.\ngst_buffer_ref is used to increase the refcount of a buffer. This must be\ndone when you want to keep a handle to the buffer after pushing it to the\nnext element. The buffer refcount determines the writability of the buffer, a\nbuffer is only writable when the refcount is exactly 1, i.e. when the caller\nhas the only reference to the buffer.\nTo efficiently create a smaller buffer out of an existing one, you can\nuse gst_buffer_copy_region. This method tries to share the memory objects\nbetween the two buffers.\nIf a plug-in wants to modify the buffer data or metadata in-place, it should\nfirst obtain a buffer that is safe to modify by using\ngst_buffer_make_writable. This function is optimized so that a copy will\nonly be made when it is necessary.\nSeveral flags of the buffer can be set and unset with the\nGST_BUFFER_FLAG_SET and GST_BUFFER_FLAG_UNSET macros. Use\nGST_BUFFER_FLAG_IS_SET to test if a certain GstBufferFlags flag is set.\nBuffers can be efficiently merged into a larger buffer with\ngst_buffer_append. Copying of memory will only be done when absolutely\nneeded.\nArbitrary extra metadata can be set on a buffer with gst_buffer_add_meta.\nMetadata can be retrieved with gst_buffer_get_meta. See also GstMeta.\nAn element should either unref the buffer or push it out on a src pad\nusing gst_pad_push (see GstPad).\nBuffers are usually freed by unreffing them with gst_buffer_unref. When\nthe refcount drops to 0, any memory and metadata pointed to by the buffer is\nunreffed as well. Buffers allocated from a GstBufferPool will be returned to\nthe pool when the refcount drops to 0.\nThe GstParentBufferMeta is a meta which can be attached to a GstBuffer\nto hold a reference to another buffer that is only released when the child\nGstBuffer is released.\nTypically, GstParentBufferMeta is used when the child buffer is directly\nusing the GstMemory of the parent buffer, and wants to prevent the parent\nbuffer from being returned to a buffer pool until the GstMemory is available\nfor re-use. (Since: 1.6)\n"});