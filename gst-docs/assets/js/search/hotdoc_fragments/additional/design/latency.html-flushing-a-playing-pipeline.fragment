fragment_downloaded_cb({"url":"additional/design/latency.html#flushing-a-playing-pipeline","fragment":"Flushing a playing pipeline\nWe can implement resynchronisation after an uncontrolled FLUSH in (part\nof) a pipeline in the same way. Indeed, when a flush is performed on a\nPLAYING live element, a new base time must be distributed to this\nelement.\nA flush in a pipeline can happen in the following cases:\nflushing seek in the pipeline\nperformed by the application on the pipeline\nperformed by the application on an element\nflush preformed by an element\nafter receiving a navigation event (DVD, …)\nWhen a playing sink is flushed by a FLUSH_START event, an ASYNC_START\nmessage is posted by the element. As part of the message, the fact that\nthe element got flushed is included. The element also goes to a pending\nPAUSED state and has to be set to the PLAYING state again later.\nThe ASYNC_START message is kept by the parent bin. When the element\nprerolls, it posts an ASYNC_DONE message.\nWhen all ASYNC_START messages are matched with an ASYNC_DONE message,\nthe bin will capture a new base_time from the clock and will bring all\nthe sinks back to PLAYING after setting the new base time on them. It’s\nalso possible to perform additional latency calculations and adjustments\nbefore doing this.\n\n\nflushing seek in the pipeline\n\n\nperformed by the application on the pipeline\n\n\nperformed by the application on an element\n\n\nflush preformed by an element\n\n\nafter receiving a navigation event (DVD, …)\n\n\n"});