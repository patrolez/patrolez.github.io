fragment_downloaded_cb({"url":"additional/design/miniobject.html#locking","fragment":"locking\nAll read and write access must be performed between a gst_mini_object_lock()\nand gst_mini_object_unlock() pair with the requested access method.\nA gst_mini_object_lock() can fail when a WRITE lock is requested and the\nexclusive counter is > 1. Indeed a GstMiniObject object with an exclusive\ncounter > 1 is locked EXCLUSIVELY by at least 2 objects and is therefore not\nwritable.\nOnce the GstMiniObject is locked with a certain access mode, it can be\nrecursively locked with the same or narrower access mode. For example, first\nlocking the GstMiniObject in READWRITE mode allows you to recusively lock\nthe GstMiniObject in READWRITE, READ and WRITE mode. Memory locked in\nREAD mode cannot be locked recursively in WRITE or READWRITE mode.\nNote that multiple threads can READ-lock the GstMiniObject concurrently but\ncannot lock the object in WRITE mode because the exclusive counter must\nbe > 1.\nAll calls to gst_mini_object_lock() need to be paired with one\ngst_mini_object_unlock() call with the same access mode. When the last\nrefcount of the object is removed, there should be no more outstanding locks.\nNote that a shared counter of both 0 and 1 leaves the GstMiniObject writable.\nThe reason is to make it easy to create and pass ownership of the\nGstMiniObject to another object while keeping it writable. When the\nGstMiniObject is created with a shared count of 0, it is writable. When the\nGstMiniObject is then added to another object, the shared count is incremented\nto 1 and the GstMiniObject remains writable. The 0 share counter has a similar\npurpose as the floating reference in GObject.\n"});