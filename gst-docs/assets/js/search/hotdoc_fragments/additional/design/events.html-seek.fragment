fragment_downloaded_cb({"url":"additional/design/events.html#seek","fragment":"SEEK\nA seek event is issued by the application to configure the playback\nrange of a stream. It is called from the application thread and travels\nupstream.\nThe seek event contains the new start and stop position of playback\nafter the seek is performed. Optionally the stop position can be left at\n-1 to continue playback to the end of the stream. The seek event also\ncontains the new playback rate of the stream, 1.0 is normal playback,\n2.0 double speed and negative values mean backwards playback.\nA seek usually flushes the graph to minimize latency after the seek.\nThis behaviour is triggered by using the SEEK_FLUSH flag on the seek\nevent.\nThe seek event usually starts from the sink elements and travels\nupstream from element to element until it reaches an element that can\nperform the seek. No intermediate element is allowed to assume that a\nseek to this location will happen. It is allowed to modify the start and\nstop times if it needs to do so. this is typically the case if a seek is\nrequested for a non-time position.\nThe actual seek is performed in the application thread so that success\nor failure can be reported as a return value of the seek event. It is\ntherefore important that before executing the seek, the element acquires\nthe STREAM_LOCK so that the streaming thread and the seek get\nserialized.\nThe general flow of executing the seek with FLUSH is as follows:\nunblock the streaming threads, they could be blocked in a chain\nfunction. This is done by sending a FLUSH_START on all srcpads or by pausing\nthe streaming task, depending on the seek FLUSH flag.\nThe flush will make sure that all downstream elements unlock and\nthat control will return to this element chain/loop function.\nWe cannot lock the STREAM_LOCK before doing this since it might\ncause a deadlock.\nacquire the STREAM_LOCK. This will work since the chain/loop function\nwas unlocked/paused in step 1).\nperform the seek. since the STREAM_LOCK is held, the streaming thread\nwill wait for the seek to complete. Most likely, the stream thread\nwill pause because the peer elements are flushing.\nsend a FLUSH_STOP event to all peer elements to allow streaming again.\ncreate a SEGMENT event to signal the new buffer timestamp base time.\nThis event must be queued to be sent by the streaming thread.\nstart stopped tasks and unlock the STREAM_LOCK, dataflow will continue\nnow from the new position.\nMore information about the different seek types can be found in\nseeking.\n"});