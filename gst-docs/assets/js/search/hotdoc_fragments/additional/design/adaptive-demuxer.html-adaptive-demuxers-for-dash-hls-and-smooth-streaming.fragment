fragment_downloaded_cb({"url":"additional/design/adaptive-demuxer.html#adaptive-demuxers-for-dash-hls-and-smooth-streaming","fragment":"Adaptive Demuxers for DASH, HLS and Smooth Streaming\nThere are two sets of elements implementing client-side adaptive streaming\n(HLS, DASH, Microsoft Smooth Streaming) in GStreamer:\nThe old legacy elements dashdemux, hlsdemux, mssdemux in the\ngst-plugins-bad module.\nNew dashdemux2, hlsdemux2, mssdemux2 elements in gst-plugins-good\n(added in GStreamer 1.22).\nThe legacy adaptive streaming support in gst-plugins-bad had several pitfalls\nthat prevented improving it easily. The legacy design used a model where an\nadaptive streaming element (dashdemux, hlsdemux) downloaded multiplexed\nfragments of media, but then relied on other components in the pipeline to\nprovide download buffering, demuxing, elementary stream handling and decoding.\nThe problems with the old design included:\nAn assumption that fragment streams (to download) are equal to output\n(elementary) streams.\nBy performing download buffering outside the adaptive streaming elements,\nthe download scheduling had no visibility into the presentation timeline.\nSeveral issues with establishing accurate timing/duration of fragments due to\nnot dealing with parsed data\nAging design that grew organically since the initial adaptive demuxer\nimplementation with a much more limited feature set, and misses a better\nunderstanding of how a feature-rich implementation should work nowadays.\nUse of GStreamer pipeline sources for downloading.\n\n\nThe old legacy elements dashdemux, hlsdemux, mssdemux in the\ngst-plugins-bad module.\n\n\nNew dashdemux2, hlsdemux2, mssdemux2 elements in gst-plugins-good\n(added in GStreamer 1.22).\n\n\n\nThis made it hard to expose GstStream and GstStreamCollection\ndescribing the available media streams, and by extension made it\ndifficult to provide efficient stream selection support\n\n\nThis made it impossible to handle more efficient variant selection and\ndownload strategy\n\n\nEspecially with HLS, which does not provide detailed timing information\nabout the underlying media streams to the same extent that DASH does.\n\n\nThe code was complicated and interwoven in ways that were hard to follow\nand reason about.\n\n\nAn internal download pipeline that contained a httpsrc -> queue2 -> src\nchain made download management, bandwidth estimation and stream parsing\nmore difficult, and used a new thread for each download.\n\n"});