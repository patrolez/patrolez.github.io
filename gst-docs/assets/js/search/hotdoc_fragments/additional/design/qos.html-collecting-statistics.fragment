fragment_downloaded_cb({"url":"additional/design/qos.html#collecting-statistics","fragment":"Collecting statistics\nA buffer with timestamp B1 arrives in the sink at time T1. The buffer\ntimestamp is then synchronized against the clock which yields a jitter\nJ1 return value from the clock. The jitter J1 is simply calculated as\nWhere CT is the clock time when the entry arrives in the sink. This\nvalue is calculated inside the clock when we perform\ngst_clock_id_wait().\nIf the jitter is negative, the entry arrived in time and can be rendered\nafter waiting for the clock to reach time B1 (which is also CT - J1).\nIf the jitter is positive however, the entry arrived too late in the\nsink and should therefore be dropped. J1 is the amount of time the entry\nwas late.\nAny buffer that arrives in the sink should generate a QoS event\nupstream.\nUsing the jitter we can calculate the time when the buffer arrived in\nthe sink:\nThe time the buffer leaves the sink after synchronisation is measured\nas:\nFor buffers that arrive in time (J1 < 0) the buffer leaves after\nsynchronisation which is exactly B1. Late buffers (J1 >= 0) leave the\nsink when they arrive, whithout any synchronisation, which is T2 = T1 = B1 + J1.\nUsing a previous T0 and a new T1, we can calculate the time it took for\nupstream to generate a buffer with timestamp B1.\nWe call PT1 the processing time needed to generate buffer with timestamp\nB1.\nMoreover, given the duration of the buffer D1, the current data rate\n(DR1) of the upstream element is given as:\nFor values 0.0 < DR1 ⇐ 1.0 the upstream element is producing faster\nthan real-time. If DR1 is exactly 1.0, the element is running at a\nperfect speed.\nValues DR1 > 1.0 mean that the upstream element cannot produce buffers\nof duration D1 in real-time. It is exactly DR1 that tells the amount of\nspeedup we require from upstream to regain real-time performance.\nAn element that is not receiving enough data is said to be underflowed.\n"});