fragment_downloaded_cb({"url":"additional/design/playback-gapless.html#limitationissue","fragment":"Limitation/Issue\nTwo limitations existed though, which are both related:\nChanging URI required bringing playbin3 (and all contained elements) down to\nGST_STATE_READY, setting the uri, and then bringing all elements back to\nGST_STATE_PAUSED.\nGapless playback (i.e. automatically switching from one source to another, and\nremoving any potential gap in the data arriving to the sinks) was implemented by\npre-rolling a full uridecodebin3 for the next item to play and switching the\ninputs to playsink when the original uridecodebin3 was EOS.\nThose two use-cases are the same thing: We want to change the URI\n(i.e. urisourcebin) but re-use as much as possible of existing elements\n(i.e. decodebin3 and playsink). The only difference between the two\nuse-cases is that changing URI should happen instantaneously in the first case,\nwhereas in the second case it happens when the initial source is done (EOS).\nFixing this will allow:\nReducing memory and cpu usage (no duplicate elements)\nLowering latency (no longer re-instantiate/reconfigure elements and re-use\ncompatible ones as fast as possible).\nAnother issue which is related, is figuring out the optimal time at which the\nnext item should be prepared so that it has enough data to playback immediately:\n\n\nChanging URI required bringing playbin3 (and all contained elements) down to\nGST_STATE_READY, setting the uri, and then bringing all elements back to\nGST_STATE_PAUSED.\n\nThis meant that all elements contained within were either discarded\n(decoders, demuxers, parsers, sources, ...) or reset (sinks)... despite\npotentially being 100% compatible (ex: going from h264/aac to h264/aac).\n\n\n\nGapless playback (i.e. automatically switching from one source to another, and\nremoving any potential gap in the data arriving to the sinks) was implemented by\npre-rolling a full uridecodebin3 for the next item to play and switching the\ninputs to playsink when the original uridecodebin3 was EOS.\n\nThis meant that none of the existing elements (demuxers, parsers, decoders,\n..) contained in the original uridecodebin3 were re-used.\n\n\n\n\nThis meant that all elements contained within were either discarded\n(decoders, demuxers, parsers, sources, ...) or reset (sinks)... despite\npotentially being 100% compatible (ex: going from h264/aac to h264/aac).\n\n\nThis meant that none of the existing elements (demuxers, parsers, decoders,\n..) contained in the original uridecodebin3 were re-used.\n\n\n\nReducing memory and cpu usage (no duplicate elements)\n\n\nLowering latency (no longer re-instantiate/reconfigure elements and re-use\ncompatible ones as fast as possible).\n\n\n\nThis shouldn't be too early, some URIs expire after a given time, or the user\nmight change their mind in between\nThis shouldn't be too late, otherwise we risk not having enough data to\nplayback seamlessly.\n\n"});