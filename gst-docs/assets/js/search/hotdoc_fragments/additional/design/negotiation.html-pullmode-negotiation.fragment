fragment_downloaded_cb({"url":"additional/design/negotiation.html#pullmode-negotiation","fragment":"Pull-mode negotiation\nA pipeline in pull mode has different negotiation needs than one\nactivated in push mode. Push mode is optimized for two use cases:\nPlayback of media files, in which the demuxers and the decoders are\nthe points from which format information should disseminate to the\nrest of the pipeline; and\nRecording from live sources, in which users are accustomed to\nputting a capsfilter directly after the source element; thus the\ncaps information flow proceeds from the user, through the potential\ncaps of the source, to the sinks of the pipeline.\nIn contrast, pull mode has other typical use cases:\nPlayback from a lossy source, such as RTP, in which more knowledge\nabout the latency of the pipeline can increase quality; or\nAudio synthesis, in which audio APIs are tuned to produce only the\nnecessary number of samples, typically driven by a hardware\ninterrupt to fill a DMA buffer or a Jack[0] port buffer.\nLow-latency effects processing, whereby filters should be applied as\ndata is transferred from a ring buffer to a sink instead of\nbeforehand. For example, instead of using the internal alsasink\nringbuffer thread in push-mode wavsrc ! volume ! alsasink, placing\nthe volume inside the sound card writer thread via wavsrc !\naudioringbuffer ! volume ! alsasink.\n[0] http://jackit.sf.net\nThe problem with pull mode is that the sink has to know the format in\norder to know how many bytes to pull via gst_pad_pull_range(). This\nmeans that before pulling, the sink must initiate negotation to decide\non a format.\nRecalling the principles of capsnego, whereby information must flow from\nthose that have it to those that do not, we see that the three named use\ncases have different negotiation requirements:\nRTP and low-latency playback are both like the normal playback case,\nin which information flows downstream.\nIn audio synthesis, the part of the pipeline that has the most\ninformation is the sink, constrained by the capabilities of the\ngraph that feeds it. However the caps are not completely specified;\nat some point the user has to intervene to choose the sample rate,\nat least. This can be done externally to gstreamer, as in the jack\nelements, or internally via a capsfilter, as is customary with live\nsources.\nGiven that sinks potentially need the input of sources, as in the RTP\ncase and at least as a filter in the synthesis case, there must be a\nnegotiation phase before the pull thread is activated. Also, given the\nlow latency offered by pull mode, we want to avoid capsnego from within\nthe pulling thread, in case it causes us to miss our scheduling\ndeadlines.\nThe pull thread is usually started in the PAUSEDâ†’PLAYING state change.\nWe must be able to complete the negotiation before this state change\nhappens.\nThe time to do capsnego, then, is after the SCHEDULING query has\nsucceeded, but before the sink has spawned the pulling thread.\n\n\nPlayback of media files, in which the demuxers and the decoders are\nthe points from which format information should disseminate to the\nrest of the pipeline; and\n\n\nRecording from live sources, in which users are accustomed to\nputting a capsfilter directly after the source element; thus the\ncaps information flow proceeds from the user, through the potential\ncaps of the source, to the sinks of the pipeline.\n\n\n\n\nPlayback from a lossy source, such as RTP, in which more knowledge\nabout the latency of the pipeline can increase quality; or\n\n\nAudio synthesis, in which audio APIs are tuned to produce only the\nnecessary number of samples, typically driven by a hardware\ninterrupt to fill a DMA buffer or a Jack[0] port buffer.\n\n\nLow-latency effects processing, whereby filters should be applied as\ndata is transferred from a ring buffer to a sink instead of\nbeforehand. For example, instead of using the internal alsasink\nringbuffer thread in push-mode wavsrc ! volume ! alsasink, placing\nthe volume inside the sound card writer thread via wavsrc !\naudioringbuffer ! volume ! alsasink.\n\n\n\n\nRTP and low-latency playback are both like the normal playback case,\nin which information flows downstream.\n\n\nIn audio synthesis, the part of the pipeline that has the most\ninformation is the sink, constrained by the capabilities of the\ngraph that feeds it. However the caps are not completely specified;\nat some point the user has to intervene to choose the sample rate,\nat least. This can be done externally to gstreamer, as in the jack\nelements, or internally via a capsfilter, as is customary with live\nsources.\n\n\n"});