fragment_downloaded_cb({"url":"additional/design/rtp.html#requesting-the-rtpbins-pads-on-the-pipeline-receiver-side","fragment":"Requesting the rtpbin's pads on the pipeline receiver side\nIf rtpauxreceive is set for session, i, j, k then it has to call\nrtpbin::\"set-aux-receive\" 3 times giving those ids and this aux element.\nIt has to be done before requesting the recv_rtp_sink_i,\nrecv_rtp_sink_j, recv_rtp_sink_k. For a concrete case\nrtprtxreceive, if the user wants it for session i, then it has to call\nrtpbin::\"set-aux-receive\" one time giving i and this aux element. Then\nthe user can request recv_rtp_sink_i pad.\nCalling rtpbin::\"set-aux-receive\" does not create the session. It add\nthe given session id and aux element to a hashtable(key:session id,\nvalue: aux element). Then when the user ask for\nrtpbin.recv_rtp_sink_i, rtpbin lookup if there is an aux element for\nthis i session id. If yes it requests a sink pad to this aux element and\nlinks it with the recv_rtp_src pad of the new gstrtpsession. rtpbin\nalso checks that this aux element is connected only one time to\nssrcdemux. Because rtpauxreceive has only one source pad. Each call to\nrequest rtpbin.recv_rtp_sink_k will also creates\nrtpbin.recv_rtp_src_k_ssrc_pt as usual. So that the user have it\nwhen then it requests rtpbin. (from gst-launch) or using\non_rtpbinreceive_pad_added callback from an application.\n"});