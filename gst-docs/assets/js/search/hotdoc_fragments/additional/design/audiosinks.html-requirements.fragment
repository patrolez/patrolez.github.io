fragment_downloaded_cb({"url":"additional/design/audiosinks.html#requirements","fragment":"Requirements\nmust operate chain based. Most simple playback pipelines will push\naudio from the decoders into the audio sink.\nmust operate getrange based Most professional audio applications\nwill operate in a mode where the audio sink pulls samples from the\npipeline. This is typically done in a callback from the audiosink\nrequesting N samples. The callback is either scheduled from a thread\nor from an interrupt from the audio hardware device.\nExact sample accurate clocks. the audiosink must be able to provide\na clock that is sample accurate even if samples are dropped or when\ndiscontinuities are found in the stream.\nExact timing of playback. The audiosink must be able to play samples\nat their exact times.\nuse DMA access when possible. When the hardware can do DMA we should\nuse it. This should also work over bufferpools to avoid data copying\nto/from kernel space.\n\n\nmust operate chain based. Most simple playback pipelines will push\naudio from the decoders into the audio sink.\n\n\nmust operate getrange based Most professional audio applications\nwill operate in a mode where the audio sink pulls samples from the\npipeline. This is typically done in a callback from the audiosink\nrequesting N samples. The callback is either scheduled from a thread\nor from an interrupt from the audio hardware device.\n\n\nExact sample accurate clocks. the audiosink must be able to provide\na clock that is sample accurate even if samples are dropped or when\ndiscontinuities are found in the stream.\n\n\nExact timing of playback. The audiosink must be able to play samples\nat their exact times.\n\n\nuse DMA access when possible. When the hardware can do DMA we should\nuse it. This should also work over bufferpools to avoid data copying\nto/from kernel space.\n\n\n"});