fragment_downloaded_cb({"url":"additional/design/opengl.html#opengl-and-threads","fragment":"OpenGL and Threads\nA major design decision of OpenGL has an OpenGL context only being available\n(or current) for use in a single thread.  This is directly at odds with\nGStreamer's multi-threaded design and requires guidance and/or restrictions on\nhow GStreamer and the application will interact with OpenGL.  There are two\nmain models for using OpenGL from multiple threads.\nThe first involves creating an OpenGL context for each thread that will use\nOpenGL in such a way that all the OpenGL contexts can share OpenGL resources.\nWhile this does ensure that each thread can execute and use OpenGL resources\nconcurrently, it has a high resources cost for two main reasons.\nThe second involves making the OpenGL context current whenever it is\nneeded. On some platforms this is possible to perform lazily as the context\nwill be uncurrented in the previous thread automatically.  Regrettably this\nbehaviour is not guaranteed for all platforms and means that transfering an\nOpenGL context between threads requires explicitly uncurrenting from the\nprevious thread.  The other issue with this is performance related where on\nsome platforms, making an OpenGL current could could consume a large amount of\nCPU time.\nGStreamer takes a different approach to this by marshalling all the OpenGL\nfunctionality to a dedicated OpenGL thread that is created and destroyed with\nthe GstGLContext.  This removes the synchronisation requirements between\nmultiple GStreamer OpenGL contexts, removes the need for multiple OpenGL\ncontexts inside GStreamer reducing the memory requirements, and avoids the\npossibly expensive currenting and uncurrenting of the OpenGL context multiple\ntimes per frame.  The marshalling is performed in the GstGLWindow\nimplementation by gst_gl_window_send_message() /\ngst_gl_window_send_message_async() and is required to be re-entrant by\nensuring that marshalling from the OpenGL thread must execute the marshalled\noperation immediately. The only downside of marshalling everything to a\ndedicated thread has is that OpenGL in GStreamer requires two\nthread switches for calling a block of OpenGL commands from outside the\nOpenGL thread.  Given the possibly high cost of the other approaches\nthis is an acceptable trade-off.\n"});