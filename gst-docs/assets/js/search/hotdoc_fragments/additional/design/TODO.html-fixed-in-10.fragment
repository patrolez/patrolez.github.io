fragment_downloaded_cb({"url":"additional/design/TODO.html#fixed-in-10","fragment":"Fixed in 1.0\nOptimize negotiation. We currently do a get_caps() call when we\nlink pads, which could potentially generate a huge list of caps and\nall their combinations, we need to avoid generating these huge lists\nby generating them We also need to incrementally return\nintersections etc, for this. somewhat incrementally when needed. We\ncan do this with a gst_pad_iterate_caps() call. We also need to\nincrementally return intersections etc, for this. FIXED in 1.0 with\na filter on getcaps functions.\nrethink how we handle dynamic replugging wrt segments and other\nevents that already got pushed and need to be pushed again. Might\nneed GstFlowReturn from gst_pad_push_event(). FIXED in 1.0 with\nsticky events.\npad block has several issues (all Fixed in 1.0 with unified pad probes):\ncan’t block on selected things, like push, pull, pad_alloc,\nevents, …\ncan’t check why the block happened. We should also be able to\nget the item/ reason that blocked the pad.\nit only blocks on datapassing. When EOS, the block never happens\nbut ideally should because pad block should inform the app when\nthere is no dataflow.\nthe same goes for segment seeks that don’t push in-band EOS\nevents. Maybe segment seeks should also send an EOS event when\nthey’re done.\nblocking should only happen from one thread. If one thread does\npad_alloc and another a push, the push might be busy while the\nblock callback is done.\nmaybe this name is overloaded. We need to look at some more use\ncases before trying to fix this.\nrethink the way we do upstream renegotiation. Currently it’s done\nwith pad_alloc but this has many issues such as only being able to\nsuggest 1 format and the need to allocate a buffer of this suggested\nformat (some elements such as capsfilter only know about the format,\nnot the size). We would ideally like to let upstream renegotiate a\nnew format just like it did when it started. This could, for\nexample, easily be triggered with a RENEGOTIATE event. FIXED in 1.0\nwith RECONFIGURE events.\nRemove the result format value in queries. FIXED in 1.0\nTry to minimize the amount of acceptcaps calls when pushing buffers\naround. The element pushing the buffer usually negotiated already\nand decided on the format. The element receiving the buffer usually\nhas to accept the caps anyway. FIXED in 1.0, caps are no longer on\nbuffers.\n\n\nOptimize negotiation. We currently do a get_caps() call when we\nlink pads, which could potentially generate a huge list of caps and\nall their combinations, we need to avoid generating these huge lists\nby generating them We also need to incrementally return\nintersections etc, for this. somewhat incrementally when needed. We\ncan do this with a gst_pad_iterate_caps() call. We also need to\nincrementally return intersections etc, for this. FIXED in 1.0 with\na filter on getcaps functions.\n\n\nrethink how we handle dynamic replugging wrt segments and other\nevents that already got pushed and need to be pushed again. Might\nneed GstFlowReturn from gst_pad_push_event(). FIXED in 1.0 with\nsticky events.\n\n\npad block has several issues (all Fixed in 1.0 with unified pad probes):\n\n\ncan’t block on selected things, like push, pull, pad_alloc,\nevents, …\n\n\ncan’t check why the block happened. We should also be able to\nget the item/ reason that blocked the pad.\n\n\nit only blocks on datapassing. When EOS, the block never happens\nbut ideally should because pad block should inform the app when\nthere is no dataflow.\n\n\nthe same goes for segment seeks that don’t push in-band EOS\nevents. Maybe segment seeks should also send an EOS event when\nthey’re done.\n\n\nblocking should only happen from one thread. If one thread does\npad_alloc and another a push, the push might be busy while the\nblock callback is done.\n\n\nmaybe this name is overloaded. We need to look at some more use\ncases before trying to fix this.\n\n\n\n\nrethink the way we do upstream renegotiation. Currently it’s done\nwith pad_alloc but this has many issues such as only being able to\nsuggest 1 format and the need to allocate a buffer of this suggested\nformat (some elements such as capsfilter only know about the format,\nnot the size). We would ideally like to let upstream renegotiate a\nnew format just like it did when it started. This could, for\nexample, easily be triggered with a RENEGOTIATE event. FIXED in 1.0\nwith RECONFIGURE events.\n\n\nRemove the result format value in queries. FIXED in 1.0\n\n\nTry to minimize the amount of acceptcaps calls when pushing buffers\naround. The element pushing the buffer usually negotiated already\nand decided on the format. The element receiving the buffer usually\nhas to accept the caps anyway. FIXED in 1.0, caps are no longer on\nbuffers.\n\n\n\n\ncan’t block on selected things, like push, pull, pad_alloc,\nevents, …\n\n\ncan’t check why the block happened. We should also be able to\nget the item/ reason that blocked the pad.\n\n\nit only blocks on datapassing. When EOS, the block never happens\nbut ideally should because pad block should inform the app when\nthere is no dataflow.\n\n\nthe same goes for segment seeks that don’t push in-band EOS\nevents. Maybe segment seeks should also send an EOS event when\nthey’re done.\n\n\nblocking should only happen from one thread. If one thread does\npad_alloc and another a push, the push might be busy while the\nblock callback is done.\n\n\nmaybe this name is overloaded. We need to look at some more use\ncases before trying to fix this.\n\n\n"});