fragment_downloaded_cb({"url":"additional/design/stream-selection.html#generating-gststreamcollection","fragment":"Generating GstStreamCollection\nWhen parsing the initial PAT/PMT, the demuxer will:\ncreate the various GstStream objects for each stream.\ncreate the GstStreamCollection for that initial PMT\npost the GST_MESSAGE_STREAM_COLLECTION. Decodebin will intercept that\nmessage and know what the demuxer will be exposing.\nThe demuxer creates the various pads and sends the corresponding\nSTREAM_START event (with the same stream-id as the corresponding\nGstStream objects), CAPS event, and TAGS event.\nparsebin will add all relevant parsers and expose those streams.\ndecodebin3 will be able to correlate, based on STREAM_START event\nstream-id, what pad corresponds to which stream. It links each stream from\nparsebin to multiqueue.\ndecodebin3 knows all the streams that will be available. Since by default\nit is configured to only expose a stream of each type, it will pick a stream\nof each for which it will complete the auto-plugging (finding a decoder and\nthen exposing that stream as a source ghostpad.\nNote: If the demuxer doesn't create/post the GstStreamCollection, parsebin\nwill create it on itself, as explained in the previous sections above.\n\n\nparsebin will add all relevant parsers and expose those streams.\n\n\ndecodebin3 will be able to correlate, based on STREAM_START event\nstream-id, what pad corresponds to which stream. It links each stream from\nparsebin to multiqueue.\n\n\ndecodebin3 knows all the streams that will be available. Since by default\nit is configured to only expose a stream of each type, it will pick a stream\nof each for which it will complete the auto-plugging (finding a decoder and\nthen exposing that stream as a source ghostpad.\n\n\n"});