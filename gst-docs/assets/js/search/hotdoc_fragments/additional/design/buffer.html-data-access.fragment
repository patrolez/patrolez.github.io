fragment_downloaded_cb({"url":"additional/design/buffer.html#data-access","fragment":"Data access\nAccessing the data of the buffer can happen by retrieving the individual\nGstMemory objects in the GstBuffer or by using the gst_buffer_map() and\ngst_buffer_unmap() functions.\nThe _map() and _unmap() functions will always return the memory of all\nblocks as one large contiguous region. Using these functions might be more\nconvenient than accessing the individual memory blocks at the expense of\nbeing more expensive because it might perform memcpy operations.\nFor buffers with only one GstMemory object (the most common case), _map()\nand _unmap() have no performance penalty at all.\nRead access with 1 memory block: The memory block is accessed and mapped\nfor read access. The memory block is unmapped after usage\nwrite access with 1 memory block: The buffer should be writable or this\noperation will fail. The memory block is accessed. If the memory block is\nreadonly, a copy is made and the original memory block is replaced with this\ncopy. Then the memory block is mapped in write mode and unmapped after usage.\nRead access with multiple memory blocks: The memory blocks are combined\ninto one large memory block. If the buffer is writable, the memory blocks are\nreplaced with this new combined block. If the buffer is not writable, the\nmemory is returned as is. The memory block is then mapped in read mode.\nWhen the memory is unmapped after usage and the buffer has multiple memory\nblocks, this means that the map operation was not able to store the combined\nbuffer and it thus returned memory that should be freed. Otherwise, the memory\nis unmapped.\nWrite access with multiple memory blocks: The buffer should be writable\nor the operation fails. The memory blocks are combined into one large memory\nblock and the existing blocks are replaced with this new block. The memory is\nthen mapped in write mode and unmapped after usage.\n\n\nRead access with 1 memory block: The memory block is accessed and mapped\nfor read access. The memory block is unmapped after usage\n\n\nwrite access with 1 memory block: The buffer should be writable or this\noperation will fail. The memory block is accessed. If the memory block is\nreadonly, a copy is made and the original memory block is replaced with this\ncopy. Then the memory block is mapped in write mode and unmapped after usage.\n\n\nRead access with multiple memory blocks: The memory blocks are combined\ninto one large memory block. If the buffer is writable, the memory blocks are\nreplaced with this new combined block. If the buffer is not writable, the\nmemory is returned as is. The memory block is then mapped in read mode.\nWhen the memory is unmapped after usage and the buffer has multiple memory\nblocks, this means that the map operation was not able to store the combined\nbuffer and it thus returned memory that should be freed. Otherwise, the memory\nis unmapped.\n\n\nWrite access with multiple memory blocks: The buffer should be writable\nor the operation fails. The memory blocks are combined into one large memory\nblock and the existing blocks are replaced with this new block. The memory is\nthen mapped in write mode and unmapped after usage.\n\n\n"});