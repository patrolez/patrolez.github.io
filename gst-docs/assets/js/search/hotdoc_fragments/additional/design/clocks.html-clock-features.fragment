fragment_downloaded_cb({"url":"additional/design/clocks.html#clock-features","fragment":"Clock features\nThe clock supports periodic and single shot clock notifications both\nsynchronous and asynchronous.\nOne first needs to create a GstClockID for the periodic or single shot\nnotification using _clock_new_single_shot_id() or\n_clock_new_periodic_id().\nTo perform a blocking wait for the specific time of the GstClockID use\nthe gst_clock_id_wait(). To receive a callback when the specific time\nis reached in the clock use gstclock_id_wait_async(). Both these\ncalls can be interrupted with the gst_clock_id_unschedule() call. If\nthe blocking wait is unscheduled a value of GST_CLOCK_UNSCHEDULED is\nreturned.\nThe async callbacks can happen from any thread, either provided by the\ncore or from a streaming thread. The application should be prepared for\nthis.\nA GstClockID that has been unscheduled cannot be used again for any wait\noperation.\nIt is possible to perform a blocking wait on the same ID from multiple\nthreads. However, registering the same ID for multiple async\nnotifications is not possible, the callback will only be called once.\nNone of the wait operations unref the GstClockID, the owner is\nresponsible for unreffing the ids itself. This holds true for both\nperiodic and single shot notifications. The reason being that the owner\nof the ClockID has to keep a handle to the ID to unblock the wait on\nFLUSHING events or state changes and if we unref it automatically, the\nhandle might be invalid.\nThese clock operations do not operate on the stream time, so the\ncallbacks will also occur when not in PLAYING state as if the clock just\nkeeps on running. Some clocks however do not progress when the element\nthat provided the clock is not PLAYING.\n"});