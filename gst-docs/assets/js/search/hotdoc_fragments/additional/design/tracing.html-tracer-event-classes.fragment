fragment_downloaded_cb({"url":"additional/design/tracing.html#tracer-event-classes","fragment":"tracer event classes\nMost tracers will log some kind of events : a data transfer, an event,\na message, a query or a measurement. Every tracer should describe the\ndata format. This way tools that process tracer logs can show the data\nin a meaningful way without having to know about the tracer plugin.\nTracers can use gst_tracer_record_new in their tracer_class_init()\nto describe their format:\nLater tracers can use the GstTracerRecord instance to log values efficiently:\nBelow a few more examples for parts of tracer classes:\nAn optional value. Since the PTS can be GST_CLOCK_TIME_NONE and that is (-1),\nwe don't want to log this.\nIn the tracer code an optional value is logged using a boolean + the value,\nwhere the boolean indicated the presence:\nA few ideas that are not yet in the above spec:\nit would be nice to describe the unit of values\nwe’d like to have some metadata on scopes\nunique instance ids\nRight now we log the classes as structures, this is important so that the log\nis self contained. It would be nice to add them to the registry, so that\ngst-inspect can show them. We could also consider to add each value as a\nREADONLY gobject property. The property has name/description. We could use\nqdata for scope and flags (or have some new property flags). We would also\nneed a new \"notify\" signal, so that value-change notifications would include a\ntime-stamp. This way the tracers would not needs to be aware of the\nlogging. The core tracer would register the notify handlers and emit the\nlog. Or we just add a gst_tracer_class_install_event() and that\nmimics the g_object_class_install_property().\nFrontends can:\n\n\nit would be nice to describe the unit of values\n\nputting it into the description is not flexible though, e.g. time\nwould be a guint64 but a ui would reformat it to e.g. h:m:s.ms\nother units are e.g.: percent, per-mille, or kbit/s\n\n\n\nwe’d like to have some metadata on scopes\n\ne.g. we’d like to log the thread-names, so that a UI can show\nthat instead of thread-ids\nordering: e.g. in the latency tracer we'd like to order by 'sink'\nand then by 'src'\n\n\n\nunique instance ids\n\nthe stats tracer logs new-element and new-pad messages\nthey add a unique ix to each instance as the memory ptr or the object\nname can be reused for new instances, the data is attached to the\nobjects as qdata\nthe latency tracer would like to also reference this metadata\n(right now, it relies on unique element names)\nthe relationship between a scope 'element-ix' ('related-to'=_ELEMENT)\nand an earlier message 'new-element' that has scope 'ix'\n('related-to'=_ELEMENT) and value 'name' is not obvious\n\n\n\n\nputting it into the description is not flexible though, e.g. time\nwould be a guint64 but a ui would reformat it to e.g. h:m:s.ms\nother units are e.g.: percent, per-mille, or kbit/s\n\n\ne.g. we’d like to log the thread-names, so that a UI can show\nthat instead of thread-ids\nordering: e.g. in the latency tracer we'd like to order by 'sink'\nand then by 'src'\n\n\nthe stats tracer logs new-element and new-pad messages\nthey add a unique ix to each instance as the memory ptr or the object\nname can be reused for new instances, the data is attached to the\nobjects as qdata\nthe latency tracer would like to also reference this metadata\n(right now, it relies on unique element names)\nthe relationship between a scope 'element-ix' ('related-to'=_ELEMENT)\nand an earlier message 'new-element' that has scope 'ix'\n('related-to'=_ELEMENT) and value 'name' is not obvious\n\n\ndo an events over time histogram\nplot curves of values over time or deltas\nshow gauges\ncollect statistics (min, max, avg, …)\n\n"});