fragment_downloaded_cb({"url":"additional/design/MT-refcounting.html#shared-data-structures-and-writability","fragment":"Shared data structures and writability:\nAll objects have a refcount associated with them. Each reference obtained to\nthe object should increase the refcount and each reference lost should\ndecrease the refcount.\nEach thread having a refcount to the object can safely read from the object.\nbut modifications made to the object should be preceded with a\n_get_writable() function call. This function will check the refcount of the\nobject and if the object is referenced by more than one instance, a copy is\nmade of the object that is then by definition only referenced from the calling\nthread. This new copy is then modifiable without being visible to other\nrefcount holders.\nThis technique is used for information objects that, once created, never\nchange their values. The lifetime of these objects is generally short, the\nobjects are usually simple and cheap to copy/create.\nThe advantage of this method is that no reader/writers locks are needed. all\nthreads can concurrently read but writes happen locally on a new copy. In most\ncases _get_writable() can avoid a real copy because the calling method is the\nonly one holding a reference, which makes read/write very cheap.\nThe drawback is that sometimes 1 needless copy can be done. This would happen\nwhen N threads call _get_writable() at the same time, all seeing that N\nreferences are held on the object. In this case 1 copy too many will be done.\nThis is not a problem in any practical situation because the copy operation is\nfast.\n"});