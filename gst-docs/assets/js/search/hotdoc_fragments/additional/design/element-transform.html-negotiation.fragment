fragment_downloaded_cb({"url":"additional/design/element-transform.html#negotiation","fragment":"Negotiation\nTypical (re)negotiation of the transform element in push mode always\ngoes from sink to src, this means triggers the following sequence:\nthe sinkpad receives a new caps event.\nthe transform function figures out what it can convert these caps\nto.\ntry to see if we can configure the caps unmodified on the peer. We\nneed to do this because we prefer to not do anything.\nthe transform configures itself to transform from the new sink caps\nto the target src caps\nthe transform processes and sets the output caps on the src pad\nWe call this downstream negotiation (DN) and it goes roughly like this:\nThese steps configure the element for a transformation from the input\ncaps to the output caps.\nThe transform has 3 function to perform the negotiation:\ntransform_caps(): Transform the caps on a certain pad to all the\npossible supported caps on the other pad. The input caps are guaranteed to be\na simple caps with just one structure. The caps do not have to be fixed.\nfixate_caps(): Given a caps on one pad, fixate the caps on the other\npad. The target caps are writable.\nset_caps(): Configure the transform for a transformation between src\ncaps and dest caps. Both caps are guaranteed to be fixed caps.\nIf no transform_caps() is defined, we can only perform the identity\ntransform, by default.\nIf no set_caps() is defined, we don’t care about caps. In that case we\nalso assume nothing is going to write to the buffer and we don’t enforce\na writable buffer for the transform_ip() function, when present.\nOne common function that we need for the transform element is to find\nthe best transform from one format (src) to another (dest). Some\nrequirements of this function are:\nhas a fixed src caps\nfinds a fixed dest caps that the transform element can transform to\nthe dest caps are compatible and can be accepted by peer elements\nthe transform function prefers to make src caps == dest caps\nthe transform function can optionally fixate dest caps.\nThe find_transform() function goes like this:\nstart from src aps, these caps are fixed.\ncheck if the caps are acceptable for us as src caps. This is usually\nenforced by the padtemplate of the element.\ncalculate all caps we can transform too with transform_caps()\nif the original caps are a subset of the transforms, try to see if\nthe the caps are acceptable for the peer. If this is possible, we\ncan perform passthrough and make src == dest. This is performed by\nsimply calling gst_pad_peer_query_accept_caps().\nif the caps are not fixed, we need to fixate it, start by taking the\npeer caps and intersect with them.\nfor each of the transformed caps retrieved with transform_caps():\ntry to fixate the caps with fixate_caps()\nif the caps are fixated, check if the peer accepts them with\n_peer_query_accept_caps(), if the peer accepts, we have found a dest caps.\nif we run out of caps, we fail to find a transform.\nif we found a destination caps, configure the transform with\nset_caps().\nAfter this negotiation process, the transform element is usually in a\nsteady state. We can identify these steady states:\nsrc and sink pads both have the same caps. Note that when the caps\nare equal on both pads, the input and output buffers automatically\nhave the same size. The element can operate on the buffers in the\nfollowing ways: (Same caps, SC)\npassthrough: buffers are inspected but no metadata or buffer data is\nchanged. The input buffers don’t need to be writable. The input\nbuffer is simply pushed out again without modifications. (SCP)\nin-place: buffers are modified in-place, this means that the input\nbuffer is modified to produce a new output buffer. This requires the\ninput buffer to be writable. If the input buffer is not writable, a\nnew buffer has to be allocated from the bufferpool. (SCI)\ncopy transform: a new output buffer is allocate from the bufferpool\nand data from the input buffer is transformed into the output\nbuffer. (SCC)\nsrc and sink pads have different caps. The element can operate on\nthe buffers in the following way: (Different Caps, DC)\nin-place: input buffers are modified in-place. This means that the\ninput buffer has a size that is larger or equal to the output size.\nThe input buffer will be resized to the size of the output buffer.\nIf the input buffer is not writable or the output size is bigger\nthan the input size, we need to pad-alloc a new buffer. (DCI)\ncopy transform: a new output buffer is allocated and the data from\nthe input buffer is transformed into the output buffer. The flow is\nexactly the same as the case with the same-caps negotiation. (DCC)\nWe can immediately observe that the copy transform states will need to\nallocate a new buffer from the bufferpool. When the transform element is\nreceiving a non-writable buffer in the in-place state, it will also need\nto perform an allocation. There is no reason why the passthrough state\nwould perform an allocation.\nThis steady state changes when one of the following actions occur:\nthe sink pad receives new caps, this triggers the above downstream\nrenegotation process, see above for the flow.\nthe transform element wants to renegotiate (because of changed\nproperties, for example). This essentially clears the current steady\nstate and triggers the downstream and upstream renegotiation\nprocess. This situation also happens when a RECONFIGURE event was\nreceived on the transform srcpad.\n\n\nthe sinkpad receives a new caps event.\n\n\nthe transform function figures out what it can convert these caps\nto.\n\n\ntry to see if we can configure the caps unmodified on the peer. We\nneed to do this because we prefer to not do anything.\n\n\nthe transform configures itself to transform from the new sink caps\nto the target src caps\n\n\nthe transform processes and sets the output caps on the src pad\n\n\n\n\ntransform_caps(): Transform the caps on a certain pad to all the\npossible supported caps on the other pad. The input caps are guaranteed to be\na simple caps with just one structure. The caps do not have to be fixed.\n\n\nfixate_caps(): Given a caps on one pad, fixate the caps on the other\npad. The target caps are writable.\n\n\nset_caps(): Configure the transform for a transformation between src\ncaps and dest caps. Both caps are guaranteed to be fixed caps.\n\n\n\n\nhas a fixed src caps\n\n\nfinds a fixed dest caps that the transform element can transform to\n\n\nthe dest caps are compatible and can be accepted by peer elements\n\n\nthe transform function prefers to make src caps == dest caps\n\n\nthe transform function can optionally fixate dest caps.\n\n\n\n\nstart from src aps, these caps are fixed.\n\n\ncheck if the caps are acceptable for us as src caps. This is usually\nenforced by the padtemplate of the element.\n\n\ncalculate all caps we can transform too with transform_caps()\n\n\nif the original caps are a subset of the transforms, try to see if\nthe the caps are acceptable for the peer. If this is possible, we\ncan perform passthrough and make src == dest. This is performed by\nsimply calling gst_pad_peer_query_accept_caps().\n\n\nif the caps are not fixed, we need to fixate it, start by taking the\npeer caps and intersect with them.\n\n\nfor each of the transformed caps retrieved with transform_caps():\n\n\ntry to fixate the caps with fixate_caps()\n\n\nif the caps are fixated, check if the peer accepts them with\n_peer_query_accept_caps(), if the peer accepts, we have found a dest caps.\n\n\nif we run out of caps, we fail to find a transform.\n\n\nif we found a destination caps, configure the transform with\nset_caps().\n\n\n\n\nsrc and sink pads both have the same caps. Note that when the caps\nare equal on both pads, the input and output buffers automatically\nhave the same size. The element can operate on the buffers in the\nfollowing ways: (Same caps, SC)\n\n\npassthrough: buffers are inspected but no metadata or buffer data is\nchanged. The input buffers don’t need to be writable. The input\nbuffer is simply pushed out again without modifications. (SCP)\n          sinkpad              transform               srcpad\n  chain()    |                    |                      |\n------------>|   handle_buffer()  |                      |\n             |------------------->|      pad_push()      |\n             |                    |--------------------->|\n             |                    |                      |\n\n\n\nin-place: buffers are modified in-place, this means that the input\nbuffer is modified to produce a new output buffer. This requires the\ninput buffer to be writable. If the input buffer is not writable, a\nnew buffer has to be allocated from the bufferpool. (SCI)\n          sinkpad              transform               srcpad\n  chain()    |                    |                      |\n------------>|   handle_buffer()  |                      |\n             |------------------->|                      |\n             |                    |   [!writable]        |\n             |                    |   alloc buffer       |\n             |                  .-|                      |\n             |  <transform_ip>  | |                      |\n             |                  '>|                      |\n             |                    |      pad_push()      |\n             |                    |--------------------->|\n             |                    |                      |\n\n\n\ncopy transform: a new output buffer is allocate from the bufferpool\nand data from the input buffer is transformed into the output\nbuffer. (SCC)\n          sinkpad              transform               srcpad\n  chain()    |                    |                      |\n------------>|   handle_buffer()  |                      |\n             |------------------->|                      |\n             |                    |     alloc buffer     |\n             |                  .-|                      |\n             |     <transform>  | |                      |\n             |                  '>|                      |\n             |                    |      pad_push()      |\n             |                    |--------------------->|\n             |                    |                      |\n\n\n\nsrc and sink pads have different caps. The element can operate on\nthe buffers in the following way: (Different Caps, DC)\n\n\nin-place: input buffers are modified in-place. This means that the\ninput buffer has a size that is larger or equal to the output size.\nThe input buffer will be resized to the size of the output buffer.\nIf the input buffer is not writable or the output size is bigger\nthan the input size, we need to pad-alloc a new buffer. (DCI)\n          sinkpad              transform               srcpad\n  chain()    |                    |                      |\n------------>|   handle_buffer()  |                      |\n             |------------------->|                      |\n             |                    | [!writable || !size] |\n             |                    |     alloc buffer     |\n             |                  .-|                      |\n             |  <transform_ip>  | |                      |\n             |                  '>|                      |\n             |                    |      pad_push()      |\n             |                    |--------------------->|\n             |                    |                      |\n\n\n\ncopy transform: a new output buffer is allocated and the data from\nthe input buffer is transformed into the output buffer. The flow is\nexactly the same as the case with the same-caps negotiation. (DCC)\n\n\n\n\nthe sink pad receives new caps, this triggers the above downstream\nrenegotation process, see above for the flow.\n\n\nthe transform element wants to renegotiate (because of changed\nproperties, for example). This essentially clears the current steady\nstate and triggers the downstream and upstream renegotiation\nprocess. This situation also happens when a RECONFIGURE event was\nreceived on the transform srcpad.\n\n\n"});