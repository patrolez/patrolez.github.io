fragment_downloaded_cb({"url":"additional/design/relations.html#establishing-the-parentchild-relationship","fragment":"establishing the parent-child relationship\nThe application then calls a method on the parent object to take ownership of\nthe child object. The parent performs the following actions:\nthe _set_parent() method performs the following actions:\nThe function atomically checks if the child has no parent yet\nand will set the parent if not. It will also sink the child, meaning\nall floating references to the child are invalid now as it takes\nover the refcount of the object.\nVisually:\nafter _set_parent() returns TRUE:\nafter parent updates ref_pointer to child.\nonly one parent is able to _sink the same object because the\n_set_parent() method is atomic.\nsince only one parent is able to _set_parent() the object, only\none will add a reference to the object.\nsince the parent can hold multiple references to children, we don’t\nneed to lock the parent when locking the child. Many threads can\ncall _set_parent() on the children with the same parent, the\nparent can then add all those to its lists.\nNote: that the signal is emitted before the parent has added the\nelement to its internal data structures. This is not a problem\nsince the parent usually has his own signal to inform the app that\nthe child was reffed. One possible solution would be to update the\ninternal structure first and then perform a rollback if the _set_parent()\nfailed. This is not a good solution as iterators might grab the\n'half-added' child too soon.\n\n\nonly one parent is able to _sink the same object because the\n_set_parent() method is atomic.\n\n\nsince only one parent is able to _set_parent() the object, only\none will add a reference to the object.\n\n\nsince the parent can hold multiple references to children, we don’t\nneed to lock the parent when locking the child. Many threads can\ncall _set_parent() on the children with the same parent, the\nparent can then add all those to its lists.\n\n\n"});