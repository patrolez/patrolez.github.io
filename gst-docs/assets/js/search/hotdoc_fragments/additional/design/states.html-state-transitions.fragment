fragment_downloaded_cb({"url":"additional/design/states.html#state-transitions","fragment":"State transitions\nthe following state changes are possible:\nNULL -> READY:\nREADY -> PAUSED:\nPAUSED -> PLAYING:\nPLAYING -> PAUSED:\nPAUSED -> READY:\nREADY -> NULL:\n\n\nNULL -> READY:\n\nThe element must check if the resources it needs are available.\nDevice sinks and sources typically try to probe the device to constrain\ntheir caps.\nThe element opens the device, this is needed if the previous step requires\nthe device to be opened.\n\n\n\nREADY -> PAUSED:\n\nThe element pads are activated in order to receive data in PAUSED.\nStreaming threads are started.\nSome elements might need to return ASYNC and complete the state change\nwhen they have enough information. It is a requirement for sinks to\nreturn ASYNC and complete the state change when they receive the first\nbuffer or EOS event (preroll). Sinks also block the dataflow when in PAUSED.\nA pipeline resets the running_time to 0.\nLive sources return NO_PREROLL and don't generate data.\n\n\n\nPAUSED -> PLAYING:\n\nMost elements ignore this state change.\nThe pipeline selects a clock and distributes this to all the children\nbefore setting them to PLAYING. This means that it is only allowed to\nsynchronize on the clock in the PLAYING state.\nThe pipeline uses the clock and the running_time to calculate the\nbase_time. This base_time is distributed to all children when\nperforming the state change.\nSink elements stop blocking on the preroll buffer or event and start\nrendering the data.\nSinks can post the EOS message in the PLAYING state. It is not allowed to\npost EOS when not in the PLAYING state.\nWhile streaming in PAUSED or PLAYING elements can create and remove\nsometimes pads.\nLive sources start generating data and return SUCCESS.\n\n\n\nPLAYING -> PAUSED:\n\nMost elements ignore this state change.\nThe pipeline calculates the running_time based on the last selected clock\nand the base_time. It stores this information to continue playback when\ngoing back to the PLAYING state.\nSinks unblock any clock wait calls.\nWhen a sink does not have a pending buffer to play, it returns ASYNC from\nthis state change and completes the state change when it receives a new\nbuffer or an EOS event.\nAny queued EOS messages are removed since they will be reposted when going\nback to the PLAYING state. The EOS messages are queued in GstBins.\nLive sources stop generating data and return NO_PREROLL.\n\n\n\nPAUSED -> READY:\n\nSinks unblock any waits in the preroll.\nElements unblock any waits on devices\nChain or get_range() functions return FLUSHING.\nThe element pads are deactivated so that streaming becomes impossible and\nall streaming threads are stopped.\nThe sink forgets all negotiated formats\nElements remove all sometimes pads\n\n\n\nREADY -> NULL:\n\nElements close devices\nElements reset any internal state.\n\n\n\n\nThe element must check if the resources it needs are available.\nDevice sinks and sources typically try to probe the device to constrain\ntheir caps.\nThe element opens the device, this is needed if the previous step requires\nthe device to be opened.\n\n\nThe element pads are activated in order to receive data in PAUSED.\nStreaming threads are started.\nSome elements might need to return ASYNC and complete the state change\nwhen they have enough information. It is a requirement for sinks to\nreturn ASYNC and complete the state change when they receive the first\nbuffer or EOS event (preroll). Sinks also block the dataflow when in PAUSED.\nA pipeline resets the running_time to 0.\nLive sources return NO_PREROLL and don't generate data.\n\n\nMost elements ignore this state change.\nThe pipeline selects a clock and distributes this to all the children\nbefore setting them to PLAYING. This means that it is only allowed to\nsynchronize on the clock in the PLAYING state.\nThe pipeline uses the clock and the running_time to calculate the\nbase_time. This base_time is distributed to all children when\nperforming the state change.\nSink elements stop blocking on the preroll buffer or event and start\nrendering the data.\nSinks can post the EOS message in the PLAYING state. It is not allowed to\npost EOS when not in the PLAYING state.\nWhile streaming in PAUSED or PLAYING elements can create and remove\nsometimes pads.\nLive sources start generating data and return SUCCESS.\n\n\nMost elements ignore this state change.\nThe pipeline calculates the running_time based on the last selected clock\nand the base_time. It stores this information to continue playback when\ngoing back to the PLAYING state.\nSinks unblock any clock wait calls.\nWhen a sink does not have a pending buffer to play, it returns ASYNC from\nthis state change and completes the state change when it receives a new\nbuffer or an EOS event.\nAny queued EOS messages are removed since they will be reposted when going\nback to the PLAYING state. The EOS messages are queued in GstBins.\nLive sources stop generating data and return NO_PREROLL.\n\n\nSinks unblock any waits in the preroll.\nElements unblock any waits on devices\nChain or get_range() functions return FLUSHING.\nThe element pads are deactivated so that streaming becomes impossible and\nall streaming threads are stopped.\nThe sink forgets all negotiated formats\nElements remove all sometimes pads\n\n\nElements close devices\nElements reset any internal state.\n\n"});