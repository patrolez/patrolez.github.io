fragment_downloaded_cb({"url":"additional/design/bufferpool.html#videotestsrc-queue-myvideosink","fragment":"videotestsrc ! queue ! myvideosink\nIn this second use case we have a videosink that can at most allocate 3 video\nbuffers.\nAgain videotestsrc will have to negotiate a bufferpool with the peer element.\nFor this it will perform the ALLOCATION query which queue will proxy to its\ndownstream peer element.\nThe bufferpool returned from myvideosink will have a max_buffers set to 3.\nqueue and videotestsrc can operate with this upper limit because none of those\nelements require more than that amount of buffers for temporary storage.\nMyvideosink's bufferpool will then be configured with the size of the buffers\nfor the negotiated format and according to the padding and alignment rules.\nWhen videotestsrc sets the pool to active, the 3 video buffers will be\npreallocated in the pool.\nvideotestsrc acquires a buffer from the configured pool on its srcpad and\npushes this into the queue. When videotestsrc has acquired and pushed 3 frames,\nthe next call to gst_buffer_pool_acquire_buffer() will block (assuming the\nGST_BUFFER_POOL_ACQUIRE_FLAG_DONTWAIT is not specified).\nWhen the queue has pushed out a buffer and the sink has rendered it, the\nrefcount of the buffer reaches 0 and the buffer is recycled in the pool. This\nwill wake up the videotestsrc that was blocked, waiting for more buffers and\nwill make it produce the next buffer.\nIn this setup, there are at most 3 buffers active in the pipeline and the\nvideotestsrc is rate limited by the rate at which buffers are recycled in the\nbufferpool.\nWhen shutting down, videotestsrc will first set the bufferpool on the srcpad\nto inactive. This causes any pending (blocked) acquire to return with\na FLUSHING result and causes the streaming thread to pause.\n\n\nIn this second use case we have a videosink that can at most allocate 3 video\nbuffers.\n\n\nAgain videotestsrc will have to negotiate a bufferpool with the peer element.\nFor this it will perform the ALLOCATION query which queue will proxy to its\ndownstream peer element.\n\n\nThe bufferpool returned from myvideosink will have a max_buffers set to 3.\nqueue and videotestsrc can operate with this upper limit because none of those\nelements require more than that amount of buffers for temporary storage.\n\n\nMyvideosink's bufferpool will then be configured with the size of the buffers\nfor the negotiated format and according to the padding and alignment rules.\nWhen videotestsrc sets the pool to active, the 3 video buffers will be\npreallocated in the pool.\n\n\nvideotestsrc acquires a buffer from the configured pool on its srcpad and\npushes this into the queue. When videotestsrc has acquired and pushed 3 frames,\nthe next call to gst_buffer_pool_acquire_buffer() will block (assuming the\nGST_BUFFER_POOL_ACQUIRE_FLAG_DONTWAIT is not specified).\n\n\nWhen the queue has pushed out a buffer and the sink has rendered it, the\nrefcount of the buffer reaches 0 and the buffer is recycled in the pool. This\nwill wake up the videotestsrc that was blocked, waiting for more buffers and\nwill make it produce the next buffer.\n\n\nIn this setup, there are at most 3 buffers active in the pipeline and the\nvideotestsrc is rate limited by the rate at which buffers are recycled in the\nbufferpool.\n\n\nWhen shutting down, videotestsrc will first set the bufferpool on the srcpad\nto inactive. This causes any pending (blocked) acquire to return with\na FLUSHING result and causes the streaming thread to pause.\n\n\n"});