fragment_downloaded_cb({"url":"additional/design/overview.html#dataflow-and-buffers","fragment":"Dataflow and buffers\nGStreamer supports two possible types of dataflow, the push and pull\nmodel. In the push model, an upstream element sends data to a downstream\nelement by calling a method on a sinkpad. In the pull model, a\ndownstream element requests data from an upstream element by calling a\nmethod on a source pad.\nThe most common dataflow is the push model. The pull model can be used\nin specific circumstances by demuxer elements. The pull model can also\nbe used by low latency audio applications.\nThe data passed between pads is encapsulated in Buffers. The buffer\ncontains pointers to the actual memory and also metadata describing the\nmemory. This metadata includes:\ntimestamp of the data, this is the time instance at which the data\nwas captured or the time at which the data should be played back.\noffset of the data: a media specific offset, this could be samples\nfor audio or frames for video.\nthe duration of the data in time.\nadditional flags describing special properties of the data such as\ndiscontinuities or delta units.\nadditional arbitrary metadata\nWhen an element whishes to send a buffer to another element is does this\nusing one of the pads that is linked to a pad of the other element. In\nthe push model, a buffer is pushed to the peer pad with\ngst_pad_push(). In the pull model, a buffer is pulled from the peer\nwith the gst_pad_pull_range() function.\nBefore an element pushes out a buffer, it should make sure that the peer\nelement can understand the buffer contents. It does this by querying the\npeer element for the supported formats and by selecting a suitable\ncommon format. The selected format is then first sent to the peer\nelement with a CAPS event before pushing the buffer (see\nnegotiation).\nWhen an element pad receives a CAPS event, it has to check if it\nunderstand the media type. The element must refuse following buffers if\nthe media type preceding it was not accepted.\nBoth gst_pad_push() and gst_pad_pull_range() have a return value\nindicating whether the operation succeeded. An error code means that no\nmore data should be sent to that pad. A source element that initiates\nthe data flow in a thread typically pauses the producing thread when\nthis happens.\nA buffer can be created with gst_buffer_new() or by requesting a\nusable buffer from a buffer pool using\ngst_buffer_pool_acquire_buffer(). Using the second method, it is\npossible for the peer element to implement a custom buffer allocation\nalgorithm.\nThe process of selecting a media type is called caps negotiation.\n\n\ntimestamp of the data, this is the time instance at which the data\nwas captured or the time at which the data should be played back.\n\n\noffset of the data: a media specific offset, this could be samples\nfor audio or frames for video.\n\n\nthe duration of the data in time.\n\n\nadditional flags describing special properties of the data such as\ndiscontinuities or delta units.\n\n\nadditional arbitrary metadata\n\n\n"});