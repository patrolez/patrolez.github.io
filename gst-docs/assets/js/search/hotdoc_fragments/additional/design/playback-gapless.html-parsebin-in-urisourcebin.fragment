fragment_downloaded_cb({"url":"additional/design/playback-gapless.html#parsebin-in-urisourcebin","fragment":"parsebin in urisourcebin\nIn order to figure out the optimal time at which a switch should happen\n(i.e. a given amount of \"time\" before the end of the previous play entry), this\ncan only be done on \"timed\" data (i.e. parsed elementary streams).\nThere is therefore a new option on urisourcebin : parse-streams, which if\nset to TRUE (non-default) will add a parsebin (if and where needed) so that\nurisourcebin only outputs elementary streams. A multiqueue will also be\npresent to handle any interleave present (i.e. only queue up what is needed to\noffer coherent streams downstream).\nIf buffering is activated on urisourcebin, the multiqueue present after the\nparsebin will be configured in order to handle it (and post the appropriate\nbuffering messages).\nThis offers the following benefits:\nabout-to-finish can be emitted by urisourcebin as soon as EOS enters\nthose multiqueue, which will be more precise than the previous usage (before\nqueue2 on non-timed data)\nbuffering is much closer to the actual buffering amount (in time) which is\nspecified on the properties.\nALL scheduling downstream of urisourcebin is push-based, removing a lot of\nissues when trying to change scheduling modes (push vs pull) dynamically.\nThe parse-streams property is set to TRUE when used in uridecodebin3\n\n\nabout-to-finish can be emitted by urisourcebin as soon as EOS enters\nthose multiqueue, which will be more precise than the previous usage (before\nqueue2 on non-timed data)\n\n\nbuffering is much closer to the actual buffering amount (in time) which is\nspecified on the properties.\n\n\nALL scheduling downstream of urisourcebin is push-based, removing a lot of\nissues when trying to change scheduling modes (push vs pull) dynamically.\n\n\n"});