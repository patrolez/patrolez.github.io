fragment_downloaded_cb({"url":"additional/design/latency.html#example-1","fragment":"Example 1\nAn audio capture/playback pipeline.\nNULL→READY:\nREADY→PAUSED:\nSince the source is a live source, it will only produce data in\nthe PLAYING state. To note this fact, it returns NO_PREROLL\nfrom the state change function.\nThis sink returns ASYNC because it can only complete the state\nchange to PAUSED when it receives the first buffer.\nAt this point the pipeline is not processing data and the clock is not\nrunning. Unless a new action is performed on the pipeline, this situation will\nnever change.\nPAUSED→PLAYING: asrc clock selected because it is the most upstream clock\nprovider. asink can only provide a clock when it received the first buffer and\nconfigured the device with the samplerate in the caps.\nsink: PAUSED:→PLAYING, sets pending state to PLAYING, returns ASYNC because it\nis not prerolled. The sink will commit state to PLAYING when it prerolls.\nsrc: PAUSED→PLAYING: starts pushing buffers.\nsince the sink is still performing a state change from READY→PAUSED, it remains ASYNC. The pending state will be set to\nPLAYING.\nThe clock starts running as soon as all the elements have been\nset to PLAYING.\nthe source is a live source with a latency. Since it is\nsynchronized with the clock, it will produce a buffer with\ntimestamp 0 and duration D after time D, ie. it will only be\nable to produce the last sample of the buffer (with timestamp D)\nat time D. This latency depends on the size of the buffer.\nthe sink will receive the buffer with timestamp 0 at time >= D.\nAt this point the buffer is too late already and might be\ndropped. This state of constantly dropping data will not change\nunless a constant latency correction is added to the incoming\nbuffer timestamps.\nThe problem is due to the fact that the sink is set to (pending) PLAYING\nwithout being prerolled, which only happens in live pipelines.\n\nasrc: audio source, provides a clock\nasink audio sink, provides a clock\n\n\n\nNULL→READY:\n\nasink: NULL→READY: probes device, returns SUCCESS\n\nasrc: NULL→READY:  probes device, returns SUCCESS\n\n\n\n\nREADY→PAUSED:\n\nasink: READY:→PAUSED open device, returns ASYNC\n\nasrc: READY→PAUSED:  open device, returns NO_PREROLL\n\n\n\n\n\nasink: NULL→READY: probes device, returns SUCCESS\n\nasrc: NULL→READY:  probes device, returns SUCCESS\n\n\n\nasink: READY:→PAUSED open device, returns ASYNC\n\nasrc: READY→PAUSED:  open device, returns NO_PREROLL\n\n\n\n\nSince the source is a live source, it will only produce data in\nthe PLAYING state. To note this fact, it returns NO_PREROLL\nfrom the state change function.\n\n\nThis sink returns ASYNC because it can only complete the state\nchange to PAUSED when it receives the first buffer.\n\n\n\n\nPAUSED→PLAYING: asrc clock selected because it is the most upstream clock\nprovider. asink can only provide a clock when it received the first buffer and\nconfigured the device with the samplerate in the caps.\n\n\nsink: PAUSED:→PLAYING, sets pending state to PLAYING, returns ASYNC because it\nis not prerolled. The sink will commit state to PLAYING when it prerolls.\n\n\nsrc: PAUSED→PLAYING: starts pushing buffers.\n\n\n\n\nsince the sink is still performing a state change from READY→PAUSED, it remains ASYNC. The pending state will be set to\nPLAYING.\n\n\nThe clock starts running as soon as all the elements have been\nset to PLAYING.\n\n\nthe source is a live source with a latency. Since it is\nsynchronized with the clock, it will produce a buffer with\ntimestamp 0 and duration D after time D, ie. it will only be\nable to produce the last sample of the buffer (with timestamp D)\nat time D. This latency depends on the size of the buffer.\n\n\nthe sink will receive the buffer with timestamp 0 at time >= D.\nAt this point the buffer is too late already and might be\ndropped. This state of constantly dropping data will not change\nunless a constant latency correction is added to the incoming\nbuffer timestamps.\n\n\n"});