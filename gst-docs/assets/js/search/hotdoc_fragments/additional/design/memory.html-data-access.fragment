fragment_downloaded_cb({"url":"additional/design/memory.html#data-access","fragment":"Data Access\nAccess to the memory region is always controlled with a map() and unmap() method\ncall. This allows the implementation to monitor the access patterns or set up\nthe required memory mappings when needed.\nThe access of the memory object is controlled with the locking mechanism on\nGstMiniObject (See miniobject).\nMapping a memory region requires the caller to specify the access method: READ\nand/or WRITE. Mapping a memory region will first try to get a lock on the\nmemory in the requested access mode. This means that the map operation can\nfail when WRITE access is requested on a non-writable memory object (it has\nan exclusive counter > 1, the memory is already locked in an incompatible\naccess mode or the memory is marked readonly).\nAfter the data has been accessed in the object, the unmap() call must be\nperformed, which will unlock the memory again.\nIt is allowed to recursively map multiple times with the same or narrower\naccess modes. For each of the map() calls, a corresponding unmap() call\nneeds to be made. WRITE-only memory cannot be mapped in READ mode and\nREAD-only memory cannot be mapped in WRITE mode.\nThe memory pointer returned from the map() call is guaranteed to remain\nvalid in the requested mapping mode until the corresponding unmap() call is\nperformed on the pointer.\nWhen multiple map() operations are nested and return the same pointer, the\npointer is valid until the last unmap() call is done.\nWhen the final reference on a memory object is dropped, all outstanding\nmappings should have been unmapped.\nResizing a GstMemory does not influence any current mappings in any way.\n"});