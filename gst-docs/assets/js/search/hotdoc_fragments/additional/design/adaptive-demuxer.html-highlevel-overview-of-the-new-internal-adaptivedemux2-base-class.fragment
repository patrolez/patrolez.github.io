fragment_downloaded_cb({"url":"additional/design/adaptive-demuxer.html#highlevel-overview-of-the-new-internal-adaptivedemux2-base-class","fragment":"High-level overview of the new internal AdaptiveDemux2 base class:\nBuffering is handled inside the adaptive streaming element, based on\nelementary streams (i.e. de-multiplexed from the downloaded fragments) and\nstored inside the adaptivedemux-based element.\nThe download strategy has full visibility on bitrates, bandwidth, per-stream\nqueueing level (in time and bytes), playback position, etc. This opens up the\npossibility of much more intelligent adaptive download strategies.\nOutput pads are not handled directly by the subclasses. Instead subclasses\nspecify which tracks of elementary streams they can provide and what\n\"download streams\" can provide contents for those tracks. The baseclass\nhandles usage and activation of the tracks based on application\nselect-streams requests, and activation of the stream needed to feed each\nselected track.\nOutput is done from a single thread, with the various elementary streams\npackets being output in time order (i.e. behaving like a regular demuxer, with\ninterleaving reduced to its minimum). There is minimal buffering downstream\nin the pipeline - only the amount required to perform decode and display.\nThe adaptive streaming element only exposes src pads for the selected\nGstStreams. Typically, there will be one video track, one audio track and\nperhaps one subtitle track exposed at a time, for example.\nStream selection is handled by the element directly. When switching on a\nnew media stream, the output to the relevant source pad is switched once\nthere is enough content buffered on the newly requested stream,\nproviding rapid and seamless stream switching.\nOnly 3 threads are used regardless of the number of streams/tracks. One is\ndedicated to download, one for output, and one for scheduling and feeding\ncontents to the tracks.\nThe main components of the new adaptive demuxers are:\nGstAdaptiveDemuxTrack : end-user meaningful elementary streams. Those can be\nselected by the user. They are provided by the subclasses based on the\nmanifest.\nOutputSlot : A track being exposed via a source pad. This is handled by the\nparent class.\nGstAdaptiveDemuxStream : implementation-specific download stream. This is\nlinked to one or more GstAdaptiveDemuxTrack. The contents of that stream\nwill be parsed (via parsebin) and fed to the target tracks.\nDownload thread : Receives download requests from the scheduling thread that\ncan be queried and interrupted. Performs all download servicing in a\nsingle dedicated thread that can estimate download bandwidth across all\nsimultaneous requests.\nScheduling thread : In charge of deciding what new downloads should be started\nbased on overall position, track buffering levels, selected tracks, current\ntime ... It is also in charge of handling completed downloads. Fragment\ndownloads are sent to dedicated parsebin elements that feed the parsed\nelementary data to GstAdaptiveDemuxTrack\nOutput thread : In charge of deciding which track should be\noutputted/removed/switched (via OutputSlot) based on requested selection and\ntrack levels.\n\n\nBuffering is handled inside the adaptive streaming element, based on\nelementary streams (i.e. de-multiplexed from the downloaded fragments) and\nstored inside the adaptivedemux-based element.\n\n\nThe download strategy has full visibility on bitrates, bandwidth, per-stream\nqueueing level (in time and bytes), playback position, etc. This opens up the\npossibility of much more intelligent adaptive download strategies.\n\n\nOutput pads are not handled directly by the subclasses. Instead subclasses\nspecify which tracks of elementary streams they can provide and what\n\"download streams\" can provide contents for those tracks. The baseclass\nhandles usage and activation of the tracks based on application\nselect-streams requests, and activation of the stream needed to feed each\nselected track.\n\n\nOutput is done from a single thread, with the various elementary streams\npackets being output in time order (i.e. behaving like a regular demuxer, with\ninterleaving reduced to its minimum). There is minimal buffering downstream\nin the pipeline - only the amount required to perform decode and display.\n\n\nThe adaptive streaming element only exposes src pads for the selected\nGstStreams. Typically, there will be one video track, one audio track and\nperhaps one subtitle track exposed at a time, for example.\n\n\nStream selection is handled by the element directly. When switching on a\nnew media stream, the output to the relevant source pad is switched once\nthere is enough content buffered on the newly requested stream,\nproviding rapid and seamless stream switching.\n\n\nOnly 3 threads are used regardless of the number of streams/tracks. One is\ndedicated to download, one for output, and one for scheduling and feeding\ncontents to the tracks.\n\n\n\n\nGstAdaptiveDemuxTrack : end-user meaningful elementary streams. Those can be\nselected by the user. They are provided by the subclasses based on the\nmanifest.\n\nThey each correspond to a GstStream of a GstStreamCollection\n\nThey are unique by GstStreamType and any other unique identifier specified\nby the manifest (ex: language)\nThe caps can change through time\n\n\n\nOutputSlot : A track being exposed via a source pad. This is handled by the\nparent class.\n\n\nGstAdaptiveDemuxStream : implementation-specific download stream. This is\nlinked to one or more GstAdaptiveDemuxTrack. The contents of that stream\nwill be parsed (via parsebin) and fed to the target tracks.\n\nWhat tracks are provided by a given GstAdaptiveDemuxStream is specified by\nthe subclass. But can also be discovered at runtime if the manifest did not\nprovide enough information (for example with HLS).\n\n\n\nDownload thread : Receives download requests from the scheduling thread that\ncan be queried and interrupted. Performs all download servicing in a\nsingle dedicated thread that can estimate download bandwidth across all\nsimultaneous requests.\n\n\nScheduling thread : In charge of deciding what new downloads should be started\nbased on overall position, track buffering levels, selected tracks, current\ntime ... It is also in charge of handling completed downloads. Fragment\ndownloads are sent to dedicated parsebin elements that feed the parsed\nelementary data to GstAdaptiveDemuxTrack\n\n\nOutput thread : In charge of deciding which track should be\noutputted/removed/switched (via OutputSlot) based on requested selection and\ntrack levels.\n\n\n\nThey each correspond to a GstStream of a GstStreamCollection\n\nThey are unique by GstStreamType and any other unique identifier specified\nby the manifest (ex: language)\nThe caps can change through time\n\n\nWhat tracks are provided by a given GstAdaptiveDemuxStream is specified by\nthe subclass. But can also be discovered at runtime if the manifest did not\nprovide enough information (for example with HLS).\n\n"});