fragment_downloaded_cb({"url":"additional/design/element-transform.html#transform-elements","fragment":"Transform elements\nTransform elements transform input buffers to output buffers based on\nthe sink and source caps.\nAn important requirement for a transform is that the output caps are\ncompletely defined by the input caps and vice versa. This means that a\ntypical decoder element can NOT be implemented with a transform element,\nthis is because the output caps like width and height of the\ndecompressed video frame, for example, are encoded in the stream and\nthus not defined by the input caps.\nTypical transform elements include:\naudio convertors (audioconvert, audioresample,…)\nvideo convertors (colorspace, videoscale, …)\nfilters (capsfilter, volume, colorbalance, …)\nThe implementation of the transform element has to take care of the\nfollowing things:\nefficient negotiation both up and downstream\nefficient buffer alloc and other buffer management\nSome transform elements can operate in different modes:\npassthrough (no changes are done on the input buffers)\nin-place (changes made directly to the incoming buffers without\nrequiring a copy or new buffer allocation)\nmetadata changes only\nDepending on the mode of operation the buffer allocation strategy might\nchange.\nThe transform element should at any point be able to renegotiate sink\nand src caps as well as change the operation mode.\nIn addition, the transform element will typically take care of the\nfollowing things as well:\nflushing, seeking\nstate changes\ntimestamping, this is typically done by copying the input timestamps\nto the output buffers but subclasses should be able to override\nthis.\nQoS, avoiding calls to the subclass transform function\nhandle scheduling issues such as push and pull based operation.\nIn the next sections, we will describe the behaviour of the transform\nelement in each of the above use cases. We focus mostly on the buffer\nallocation strategies and caps negotiation.\n\n\naudio convertors (audioconvert, audioresample,…)\n\n\nvideo convertors (colorspace, videoscale, …)\n\n\nfilters (capsfilter, volume, colorbalance, …)\n\n\n\n\nefficient negotiation both up and downstream\n\n\nefficient buffer alloc and other buffer management\n\n\n\n\npassthrough (no changes are done on the input buffers)\n\n\nin-place (changes made directly to the incoming buffers without\nrequiring a copy or new buffer allocation)\n\n\nmetadata changes only\n\n\n\n\nflushing, seeking\n\n\nstate changes\n\n\ntimestamping, this is typically done by copying the input timestamps\nto the output buffers but subclasses should be able to override\nthis.\n\n\nQoS, avoiding calls to the subclass transform function\n\n\nhandle scheduling issues such as push and pull based operation.\n\n\n"});