fragment_downloaded_cb({"url":"additional/design/events.html#flush_startstop","fragment":"FLUSH_START/STOP\nA flush event is sent both downstream and upstream to clear any pending\ndata from the pipeline. This might be needed to make the graph more\nresponsive when the normal dataflow gets interrupted by for example a\nseek event.\nFlushing happens in two stages.\na source element sends the FLUSH_START event to the downstream peer element.\nThe downstream element starts rejecting buffers from the upstream elements. It\nsends the flush event further downstream and discards any buffers it is\nholding as well as return from the chain function as soon as possible.\nThis makes sure that all upstream elements get unblocked.\nThis event is not synchronized with the STREAM_LOCK and can be done in the\napplication thread.\na source element sends the FLUSH_STOP event to indicate\nthat the downstream element can accept buffers again. The downstream\nelement sends the flush event to its peer elements. After this step dataflow\ncontinues. The FLUSH_STOP call is synchronized with the STREAM_LOCK so any\ndata used by the chain function can safely freed here if needed. Any\npending EOS events should be discarded too.\nAfter the flush completes the second stage, data is flowing again in the\npipeline and all buffers are more recent than those before the flush.\nFor elements that use the pullrange function, they send both flush\nevents to the upstream pads in the same way to make sure that the\npullrange function unlocks and any pending buffers are cleared in the\nupstream elements.\nA FLUSH_START may instruct the pipeline to distribute a new base_time\nto elements so that the running_time is reset to 0. (see\nclocks and synchronisation).\n"});