fragment_downloaded_cb({"url":"additional/design/decodebin.html#gstmultiqueue","fragment":"GstMultiQueue\nMultiple input-output data queue.\nmultiqueue achieves the same functionality as queue, with a\nfew differences:\nMultiple streams handling.\nThe element handles queueing data on more than one stream at once.\nTo achieve such a feature it has request sink pads (sink_%u) and\n'sometimes' src pads (src_%u).\nWhen requesting a given sinkpad, the associated srcpad for that\nstream will be created. Ex: requesting sink_1 will generate src_1.\nNon-starvation on multiple streams.\nIf more than one stream is used with the element, the streams'\nqueues will be dynamically grown (up to a limit), in order to ensure\nthat no stream is risking data starvation. This guarantees that at\nany given time there are at least N bytes queued and available for\neach individual stream.\nIf an EOS event comes through a srcpad, the associated queue should\nbe considered as 'not-empty' in the queue-size-growing algorithm.\nNon-linked srcpads graceful handling.\nA GstTask is started for all srcpads when going to\nGST_STATE_PAUSED.\nThe task are blocking against a GCondition which will be fired in\ntwo different cases:\nWhen the associated queue has received a buffer.\nWhen the associated queue was previously declared as 'not-linked'\nand the first buffer of the queue is scheduled to be pushed\nsynchronously in relation to the order in which it arrived globally\nin the element (see 'Synchronous data pushing' below).\nWhen woken up by the GCondition, the GstTask will try to push the\nnext GstBuffer/GstEvent on the queue. If pushing returns\nGST_FLOW_NOT_LINKED, the associated queue is marked as not-linked.\nIf pushing succeeds, the queue will no longer be marked as not-linked.\nIf pushing on all srcpads returns a GstFlowReturn different from\nGST_FLOW_OK, then all the srcpads' tasks are stopped and\nsubsequent pushes on sinkpads will return GST_FLOW_NOT_LINKED.\nSynchronous data pushing for non-linked pads.\nIn order to better support dynamic switching between streams, the\nmultiqueue (unlike the current GStreamer queue) continues to push\nbuffers on non-linked pads rather than shutting down.\nIn addition, to prevent a non-linked stream from very quickly\nconsuming all available buffers and thus 'racing ahead' of the other\nstreams, the element must ensure that buffers and inlined events for\na non-linked stream are pushed in the same order as they were\nreceived, relative to the other streams controlled by the element.\nThis means that a buffer cannot be pushed to a non-linked pad any\nsooner than buffers in any other stream which were received before\nit.\n\n\nMultiple streams handling.\nThe element handles queueing data on more than one stream at once.\nTo achieve such a feature it has request sink pads (sink_%u) and\n'sometimes' src pads (src_%u).\nWhen requesting a given sinkpad, the associated srcpad for that\nstream will be created. Ex: requesting sink_1 will generate src_1.\n\n\nNon-starvation on multiple streams.\nIf more than one stream is used with the element, the streams'\nqueues will be dynamically grown (up to a limit), in order to ensure\nthat no stream is risking data starvation. This guarantees that at\nany given time there are at least N bytes queued and available for\neach individual stream.\nIf an EOS event comes through a srcpad, the associated queue should\nbe considered as 'not-empty' in the queue-size-growing algorithm.\n\n\nNon-linked srcpads graceful handling.\nA GstTask is started for all srcpads when going to\nGST_STATE_PAUSED.\nThe task are blocking against a GCondition which will be fired in\ntwo different cases:\n\n\nWhen the associated queue has received a buffer.\n\n\nWhen the associated queue was previously declared as 'not-linked'\nand the first buffer of the queue is scheduled to be pushed\nsynchronously in relation to the order in which it arrived globally\nin the element (see 'Synchronous data pushing' below).\n\n\nWhen woken up by the GCondition, the GstTask will try to push the\nnext GstBuffer/GstEvent on the queue. If pushing returns\nGST_FLOW_NOT_LINKED, the associated queue is marked as not-linked.\nIf pushing succeeds, the queue will no longer be marked as not-linked.\nIf pushing on all srcpads returns a GstFlowReturn different from\nGST_FLOW_OK, then all the srcpads' tasks are stopped and\nsubsequent pushes on sinkpads will return GST_FLOW_NOT_LINKED.\n\n\nSynchronous data pushing for non-linked pads.\nIn order to better support dynamic switching between streams, the\nmultiqueue (unlike the current GStreamer queue) continues to push\nbuffers on non-linked pads rather than shutting down.\nIn addition, to prevent a non-linked stream from very quickly\nconsuming all available buffers and thus 'racing ahead' of the other\nstreams, the element must ensure that buffers and inlined events for\na non-linked stream are pushed in the same order as they were\nreceived, relative to the other streams controlled by the element.\nThis means that a buffer cannot be pushed to a non-linked pad any\nsooner than buffers in any other stream which were received before\nit.\n\n\n\n\nWhen the associated queue has received a buffer.\n\n\nWhen the associated queue was previously declared as 'not-linked'\nand the first buffer of the queue is scheduled to be pushed\nsynchronously in relation to the order in which it arrived globally\nin the element (see 'Synchronous data pushing' below).\n\n\n"});