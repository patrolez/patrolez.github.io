fragment_downloaded_cb({"url":"additional/design/streams.html#typical-stream","fragment":"Typical stream\nA typical stream starts with a STREAM_START event that marks the start of the\nstream, followed by a SEGMENT event that marks the buffer timestamp\nrange. After that buffers are sent one after the other. After the last buffer an\nEOS event marks the end of the stream. No more buffers are to be processed\nafter the EOS event.\nSTREAM_START\nSEGMENT, rate, start/stop, time. (See also\nSegments)\nN buffers\ndisplayable buffers are between start/stop of the SEGMENT (S). Buffers\noutside the segment range should be dropped or clipped.\nrunning_time: For each buffer, a monotonically increasing value that can\nbe used to synchronize against the clock (See also\nsynchronisation).\nstream_time: The current position in the stream, between 0 and duration.\nEOS\n\nmarks the start of a stream; unlike the SEGMENT event, there\nwill be no STREAM_START event after flushing seeks.\n\n\nmarks valid buffer timestamp range (start, stop)\nmarks stream_time of buffers (time). This is the stream time of buffers\nwith a timestamp of S.start.\nmarks playback rate (rate). This is the required playback rate.\nmarks applied rate (applied_rate). This is the already applied playback\nrate. (See also trickmodes)\nmarks running_time of buffers. This is the time used to synchronize\nagainst the clock.\n\n\n\ndisplayable buffers are between start/stop of the SEGMENT (S). Buffers\noutside the segment range should be dropped or clipped.\n\n\nrunning_time: For each buffer, a monotonically increasing value that can\nbe used to synchronize against the clock (See also\nsynchronisation).\nif (S.rate > 0.0)\n  running_time = (B.timestamp - S.start) / ABS (S.rate) + S.base;\nelse\n  running_time = (S.stop - B.timestamp) / ABS (S.rate) + S.base;\n\n\n\nstream_time: The current position in the stream, between 0 and duration.\nstream_time = (B.timestamp - S.start) * ABS (S.applied_rate) + S.time;\n\n\n\n\nmarks the end of data, nothing is to be expected after EOS, elements\nshould refuse more data and return GST_FLOW_EOS. A FLUSH_STOP\nevent clears the EOS state of an element.\n\n"});