fragment_downloaded_cb({"url":"additional/design/segments.html#flushing-seek","fragment":"FLUSHING seek\nWhen doing a seek in this pipeline for a segment 1 to 5 seconds, avidemux\nwill perform the seek.\nAvidemux starts by sending a FLUSH_START event downstream and upstream. This\nwill cause its streaming task to PAUSED because _pad_pull_range() and\n_pad_push() will return FLUSHING. It then waits for the STREAM_LOCK,\nwhich will be unlocked when the streaming task pauses. At this point no\nstreaming is happening anymore in the pipeline and a FLUSH_STOP is sent\nupstream and downstream.\nWhen avidemux starts playback of the segment from second 1 to 5, it pushes\nout a segment with 1 and 5 as start and stop times. The stream_time in\nthe segment is also 1 as this is the position we seek to.\nThe video decoder stores these values internally and forwards them to the\nnext downstream element (videosink, which also stores the values)\nSince second 1 does not contain a keyframe, the avi demuxer starts sending\ndata from the previous keyframe which is at timestamp 0.\nThe video decoder decodes the keyframe but knows it should not push the\nvideo frame yet as it falls outside of the configured segment.\nWhen the video decoder receives the frame with timestamp 1, it is able to\ndecode this frame as it received and decoded the data up to the previous\nkeyframe. It then continues to decode and push frames with timestamps >= 1.\nWhen it reaches timestamp 5, it does not decode and push frames anymore.\nThe video sink receives a frame of timestamp 1. It takes the start value of\nthe previous segment and applies the following (simplified) formula:\nIt then syncs against the clock with this render_time. Note that\nBUFFER_TIMESTAMP is always >= segment_start or else it would fall outside\nof the configured segment.\nVideosink reports its current position as (simplified):\nSee synchronisation for a more detailed and\naccurate explanation of synchronisation and position reporting.\nSince after a flushing seek the stream_time is reset to 0, the new buffer\nwill be rendered immediately after the seek and the current_position will be\nthe stream_time of the seek that was performed.\nThe stop time is important when the video format contains B frames. The\nvideo decoder receives a P frame first, which it can decode but not push yet.\nWhen it receives a B frame, it can decode the B frame and push the B frame\nfollowed by the previously decoded P frame. If the P frame is outside of the\nsegment, the decoder knows it should not send the P frame.\nAvidemux stops sending data after pushing a frame with timestamp 5 and\nreturns GST_FLOW_EOS from the chain function to make the upstream\nelements perform the EOS logic.\n"});