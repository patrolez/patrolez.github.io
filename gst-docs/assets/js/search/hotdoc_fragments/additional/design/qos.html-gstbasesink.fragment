fragment_downloaded_cb({"url":"additional/design/qos.html#gstbasesink","fragment":"GstBaseSink\nThe primary implementor of QoS is GstBaseSink. It will calculate the\nfollowing values:\nupstream running average of processing time (5) in stream time.\nrunning average of buffer durations.\nrunning average of render time (in system time)\nrendered/dropped buffers\nThe processing time and the average buffer durations will be used to\ncalculate a proportion.\nThe processing time in system time is compared to render time to decide\nif the majority of the time is spend upstream or in the sink itself.\nThis value is used to decide overflow or underflow.\nThe number of rendered and dropped buffers is used to query stats on the\nsink.\nA QoS event with the most current values is sent upstream for each\nbuffer that was received by the sink.\nNormally QoS is only enabled for video pipelines. The reason being that\ndrops in audio are more disturbing than dropping video frames. Also\nvideo requires in general more processing than audio.\nNormally there is a threshold for when buffers get dropped in a video\nsink. Frames that arrive 20 milliseconds late are still rendered as it\nis not noticeable for the human eye.\nA QoS message is posted whenever a (part of a) buffer is dropped.\nIn throttle mode, the sink sends QoS event upstream with the timestamp\nset to the running_time of the latest buffer and the jitter set to the\nthrottle interval. If the throttled buffer is late, the lateness is\nsubtracted from the throttle interval in order to keep the desired\nthrottle interval.\n\n\nupstream running average of processing time (5) in stream time.\n\n\nrunning average of buffer durations.\n\n\nrunning average of render time (in system time)\n\n\nrendered/dropped buffers\n\n\n"});