fragment_downloaded_cb({"url":"additional/design/MT-refcounting.html#mutable-substructures","fragment":"Mutable substructures:\nSpecial techniques are necessary to ensure the consistency of compound shared\nobjects. As mentioned above, shared objects need to have a reference count of\n1 if they are to be modified. Implicit in this assumption is that all parts of\nthe shared object belong only to the object. For example, a GstStructure in\none GstCaps object should not belong to any other GstCaps object. This\ncondition suggests a parent-child relationship: structures can only be added\nto parent object if they do not already have a parent object.\nIn addition, these substructures must not be modified while more than one code\nsegment has a reference on the parent object. For example, if the user creates\na GstStructure, adds it to a GstCaps, and the GstCaps is then referenced by\nother code segments, the GstStructure should then become immutable, so that\nchanges to that data structure do not affect other parts of the code. This\nmeans that the child is only mutable when the parent's reference count is 1,\nas well as when the child structure has no parent.\nThe general solution to this problem is to include a field in child structures\npointing to the parent's atomic reference count. When set to NULL, this\nindicates that the child has no parent. Otherwise, procedures that modify the\nchild structure must check if the parent's refcount is 1, and otherwise must\ncause an error to be signaled.\nNote that this is an internal implementation detail; application or plugin\ncode that calls _get_writable() on an object is guaranteed to receive an\nobject of refcount 1, which must then be writable. The only trick is that a\npointer to a child structure of an object is only valid while the calling code\nhas a reference on the parent object, because the parent is the owner of the\nchild.\n"});