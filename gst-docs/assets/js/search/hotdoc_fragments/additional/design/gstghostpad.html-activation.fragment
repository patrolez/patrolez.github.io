fragment_downloaded_cb({"url":"additional/design/gstghostpad.html#activation","fragment":"Activation\nSometimes ghost pads should proxy activation functions. This thingie\nattempts to explain how it should work in the different cases.\nAll of the labeled boxes are pads. The dashes (---) show pad links, and\nthe double-lines (===) are internal connections. The box around a, b, c,\nand d is a bin. B and C are ghost pads, and a and d are proxy pads. The\narrow represents the direction of a state change algorithm. Not counting\nthe bin, there are three elements involved here — the parent of D, the\nparent of A, and the parent of b and c.\nNow, in the state change from READY to PAUSED, assuming the pipeline\ndoes not have a live source, all of the pads will end up activated at\nthe end. There are 4 possible activation modes:\nWhen activating (1), the state change algorithm will first visit the\nparent of D and activate D in push mode. Then it visits the bin. The bin\nwill first change the state of its child before activating its pads.\nThat means c will be activated in push mode. [*] At this point, d and\nC should also be active in push mode, because it could be that\nactivating c in push mode starts a thread, which starts pushing to pads\nwhich aren’t ready yet. Then b is activated in push mode. Then, the bin\nactivates C in push mode, which should already be in push mode, so\nnothing is done. It then activates B in push mode, which activates b in\npush mode, but it’s already there, then activates a in push mode as\nwell. The order of activating a and b does not matter in this case.\nThen, finally, the state change algorithm moves to the parent of A,\nactivates A in push mode, and dataflow begins.\n[*] Not yet implemented.\nActivation mode (2) is implausible, so we can ignore it for now. That\nleaves us with the rest.\n(3) is the same as (1) until you get to activating b. Activating b will\nproxy directly to activating a, which will activate B and A as well.\nThen when the state change algorithm gets to B and A it sees that they\nare already active, so it ignores them.\nSimilarly in (4), activating D will cause the activation of all of the\nrest of the pads, in this order: C d c b a B A. Then when the state\nchange gets to the other elements they are already active, and in fact\ndata flow is already occurring.\nSo, from these scenarios, we can distill how ghost pad activation\nfunctions should work:\nGhost source pads (e.g. C): push: called by: element state change\nhandler behavior: just return TRUE pull: called by: peer’s activatepull\nbehavior: change the internal pad, which proxies to its peer e.g. C\nchanges d which changes c.\nInternal sink pads (e.g. d): push: called by: nobody (doesn’t seem\npossible) behavior: n/a pull: called by: ghost pad behavior: proxy to\npeer first\nInternal src pads (e.g. a): push: called by: ghost pad behavior:\nactivate peer in push mode pull: called by: peer’s activatepull\nbehavior: proxy to ghost pad, which proxies to its peer (e.g. a calls B\nwhich calls A)\nGhost sink pads (e.g. B): push: called by: element state change handler\nbehavior: change the internal pad, which proxies to peer (e.g. B changes\na which changes b) pull: called by: internal pad behavior: proxy to peer\nIt doesn’t really make sense to have activation functions on proxy pads\nthat aren’t part of a ghost pad arrangement.\n"});