fragment_downloaded_cb({"url":"additional/design/audiosinks.html#design","fragment":"Design\nThe design is based on a set of base classes and the concept of a\nringbuffer of samples.\nThe ringbuffer is a contiguous piece of memory divided into segtotal\npieces of segments. Each segment has segsize bytes.\nThe ringbuffer has a play position, which is expressed in segments. The\nplay position is where the device is currently reading samples from the\nbuffer.\nThe ringbuffer can be put to the PLAYING or STOPPED state.\nIn the STOPPED state no samples are played to the device and the play\npointer does not advance.\nIn the PLAYING state samples are written to the device and the\nringbuffer should call a configurable callback after each segment is\nwritten to the device. In this state the play pointer is advanced after\neach segment is written.\nA write operation to the ringbuffer will put new samples in the\nringbuffer. If there is not enough space in the ringbuffer, the write\noperation will block. The playback of the buffer never stops, even if\nthe buffer is empty. When the buffer is empty, silence is played by the\ndevice.\nThe ringbuffer is implemented with lockfree atomic operations,\nespecially on the reading side so that low-latency operations are\npossible.\nWhenever new samples are to be put into the ringbuffer, the position of\nthe read pointer is taken. The required write position is taken and the\ndiff is made between the required and actual position. If the difference\nis < 0, the sample is too late. If the difference is bigger than\nsegtotal, the writing part has to wait for the play pointer to advance.\n"});