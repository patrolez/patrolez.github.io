fragment_downloaded_cb({"url":"additional/design/events.html#eos","fragment":"EOS\nThe EOS event can only be sent on a sinkpad. It is typically emitted by\nthe source element when it has finished sending data. This event is\nmainly sent in the streaming thread but can also be sent from the\napplication thread.\nThe downstream element should forward the EOS event to its downstream\npeer elements. This way the event will eventually reach the sinks which\nshould then post an EOS message on the bus when in PLAYING.\nAn element might want to flush its internally queued data before\nforwarding the EOS event downstream. This flushing can be done in the\nsame thread as the one handling the EOS event.\nFor elements with multiple sink pads it might be possible to wait for\nEOS on all the pads before forwarding the event.\nThe EOS event should always be interleaved with the data flow, therefore\nthe GStreamer core will take the STREAM_LOCK.\nSometimes the EOS event is generated by another element than the source,\nfor example a demuxer element can generate an EOS event before the\nsource element. This is not a problem, the demuxer does not send an EOS\nevent to the upstream element but returns GST_FLOW_EOS, causing the\nsource element to stop sending data.\nAn element that sends EOS on a pad should stop sending data on that pad.\nSource elements typically pause() their task for that purpose.\nBy default, a GstBin collects all EOS messages from all its sinks before\nposting the EOS message to its parent.\nThe EOS is only posted on the bus by the sink elements in the PLAYING\nstate. If the EOS event is received in the PAUSED state, it is queued\nuntil the element goes to PLAYING.\nA FLUSH_STOP event on an element flushes the EOS state and all pending\nEOS messages.\n"});