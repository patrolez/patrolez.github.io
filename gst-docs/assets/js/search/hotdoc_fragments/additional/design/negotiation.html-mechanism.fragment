fragment_downloaded_cb({"url":"additional/design/negotiation.html#mechanism","fragment":"Mechanism\nThe sink determines that the upstream elements support pull based\nscheduling by doing a SCHEDULING query.\nThe sink initiates the negotiation process by intersecting the results\nof gst_pad_query_caps() on its sink pad and its peer src pad. This is\nthe operation performed by gst_pad_get_allowed_caps() In the simple\npassthrough case, the peer padâ€™s caps query should return the\nintersection of calling get_allowed_caps() on all of its sink pads. In\nthis way the sink element knows the capabilities of the entire pipeline.\nThe sink element then fixates the resulting caps, if necessary,\nresulting in the flow caps. From now on, the caps query of the sinkpad\nwill only return these fixed caps meaning that upstream elements will\nonly be able to produce this format.\nIf the sink element could not set caps on its sink pad, it should post\nan error message on the bus indicating that negotiation was not\npossible.\nWhen negotiation succeeded, the sinkpad and all upstream internally\nlinked pads are activated in pull mode. Typically, this operation will\ntrigger negotiation on the downstream elements, which will now be forced\nto negotiate to the final fixed desired caps of the sinkpad.\nAfter these steps, the sink element returns ASYNC from the state change\nfunction. The state will commit to PAUSED when the first buffer is\nreceived in the sink. This is needed to provide a consistent API to the\napplications that expect ASYNC return values from sinks but it also\nallows us to perform the remainder of the negotiation outside of the\ncontext of the pulling thread.\n"});