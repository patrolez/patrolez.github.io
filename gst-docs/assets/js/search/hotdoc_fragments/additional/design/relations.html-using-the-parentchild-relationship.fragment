fragment_downloaded_cb({"url":"additional/design/relations.html#using-the-parentchild-relationship","fragment":"using the parent-child relationship\nsince the initial floating reference to the child object became\ninvalid after giving it to the parent, any reference to a child has\nat least a refcount > 1.\nthis means that unreffing a child object cannot decrease the\nrefcount to 0. In fact, only the parent can destroy and dispose the\nchild object.\ngiven a reference to the child object, the parent pointer is only\nvalid when holding the child LOCK. Indeed, after unlocking the child\nLOCK, the parent can unparent the child or the parent could even\nbecome disposed. To avoid the parent dispose problem, when obtaining\nthe parent pointer, if should be reffed before releasing the child\nLOCK.\ngetting a reference to a child\na reference to a child can be obtained by reffing it before adding\nit to the parent or by querying the parent.\nwhen requesting a child from the parent, a reference is held to the\nparent so it cannot be disposed. The parent will use its internal\ndata structures to locate the child element and will return a\nreference to it with an incremented refcount. The requester should\n_unref() the child after usage.\ndestroying the parent-child relationship\nonly the parent can actively destroy the parent-child relationship\nthis typically happens when a method is called on the parent to\nrelease ownership of the child.\na child shall never remove itself from the parent.\nsince calling a method on the parent with the child as an argument\nrequires the caller to obtain a valid reference to the child, the\nchild refcount is at least > 1.\nthe parent will perform the folowing actions:\nThe _unparent() method performs the following actions:\nSince the _unparent() method unrefs the child object, it is possible that\nthe child pointer is invalid after this function. If the parent wants to\nperform other actions on the child (such as signal emission) it should\n_ref() the child first.\n\n\nsince the initial floating reference to the child object became\ninvalid after giving it to the parent, any reference to a child has\nat least a refcount > 1.\n\n\nthis means that unreffing a child object cannot decrease the\nrefcount to 0. In fact, only the parent can destroy and dispose the\nchild object.\n\n\ngiven a reference to the child object, the parent pointer is only\nvalid when holding the child LOCK. Indeed, after unlocking the child\nLOCK, the parent can unparent the child or the parent could even\nbecome disposed. To avoid the parent dispose problem, when obtaining\nthe parent pointer, if should be reffed before releasing the child\nLOCK.\n\n\n\ngetting a reference to the parent.\n\na referece is held to the child, so it cannot be disposed.\n\n\n\n\na referece is held to the child, so it cannot be disposed.\n\n\n\ngetting a reference to a child\n\n\na reference to a child can be obtained by reffing it before adding\nit to the parent or by querying the parent.\n\n\nwhen requesting a child from the parent, a reference is held to the\nparent so it cannot be disposed. The parent will use its internal\ndata structures to locate the child element and will return a\nreference to it with an incremented refcount. The requester should\n_unref() the child after usage.\n\n\n\n\ndestroying the parent-child relationship\n\n\nonly the parent can actively destroy the parent-child relationship\nthis typically happens when a method is called on the parent to\nrelease ownership of the child.\n\n\na child shall never remove itself from the parent.\n\n\nsince calling a method on the parent with the child as an argument\nrequires the caller to obtain a valid reference to the child, the\nchild refcount is at least > 1.\n\n\nthe parent will perform the folowing actions:\n\n\n\n\n\n\na reference to a child can be obtained by reffing it before adding\nit to the parent or by querying the parent.\n\n\nwhen requesting a child from the parent, a reference is held to the\nparent so it cannot be disposed. The parent will use its internal\ndata structures to locate the child element and will return a\nreference to it with an incremented refcount. The requester should\n_unref() the child after usage.\n\n\n\n\nonly the parent can actively destroy the parent-child relationship\nthis typically happens when a method is called on the parent to\nrelease ownership of the child.\n\n\na child shall never remove itself from the parent.\n\n\nsince calling a method on the parent with the child as an argument\nrequires the caller to obtain a valid reference to the child, the\nchild refcount is at least > 1.\n\n\nthe parent will perform the folowing actions:\n\n\n"});