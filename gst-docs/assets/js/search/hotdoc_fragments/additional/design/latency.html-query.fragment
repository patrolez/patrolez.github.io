fragment_downloaded_cb({"url":"additional/design/latency.html#query","fragment":"Query\nThe pipeline latency is queried with the LATENCY query.\nlive G_TYPE_BOOLEAN (default FALSE): - if a live element is found upstream\nmin-latency G_TYPE_UINT64 (default 0, must not be NONE): - the minimum\nlatency in the pipeline, meaning the minimum time downstream elements\nsynchronizing to the clock have to wait until they can be sure all data\nfor the current running time has been received.\nElements answering the latency query and introducing latency must\nset this to the maximum time for which they will delay data, while\nconsidering upstream's minimum latency. As such, from an element's\nperspective this is not its own minimum latency but its own\nmaximum latency.\nConsidering upstream's minimum latency generally means that the\nelement's own value is added to upstream's value, as this will give\nthe overall minimum latency of all elements from the source to the\ncurrent element:\nElements answering the latency query should set this to the maximum\ntime for which they can buffer upstream data without blocking or\ndropping further data. For an element, this value will generally be\nits own minimum latency, but might be bigger than that if it can\nbuffer more data. As such, queue elements can be used to increase\nthe maximum latency.\nThe value set in the query should again consider upstream's maximum\nlatency:\nIf the element has multiple sinkpads, the minimum upstream latency is\nthe maximum of all live upstream minimum latencies.\nIf the current element has leaky buffering, i.e. it drops data by itself\nwhen its internal buffer is full, it should take the minimum of its own\nmaximum latency and upstreamâ€™s. Examples for such elements are audio sinks\nand sources with an internal ringbuffer, leaky queues and in general live\nsources with a limited amount of internal buffers that can be used.\nNote: many GStreamer base classes allow subclasses to set a\nminimum and maximum latency and handle the query themselves. These\nbase classes assume non-leaky (i.e. blocking) buffering for the\nmaximum latency. The base class' default query handler needs to be\noverridden to correctly handle leaky buffering.\nIf the element has multiple sinkpads, the maximum upstream latency is the\nminimum of all live upstream maximum latencies.\n\n\nlive G_TYPE_BOOLEAN (default FALSE): - if a live element is found upstream\n\n\nmin-latency G_TYPE_UINT64 (default 0, must not be NONE): - the minimum\nlatency in the pipeline, meaning the minimum time downstream elements\nsynchronizing to the clock have to wait until they can be sure all data\nfor the current running time has been received.\n\n\n\n\nmax-latency G_TYPE_UINT64 (default 0, NONE meaning infinity): - the\nmaximum latency in the pipeline, meaning the maximum time an element\nsynchronizing to the clock is allowed to wait for receiving all data for the\ncurrent running time. Waiting for a longer time will result in data loss,\nbuffer overruns and underruns and, in general, breaks synchronized data flow\nin the pipeline.\n\n\nIf the current element has blocking buffering, i.e. it does not drop data by\nitself when its internal buffer is full, it should just add its own maximum\nlatency (i.e. the size of its internal buffer) to upstream's value. If\nupstream's maximum latency, or the elements internal maximum latency was NONE\n(i.e. infinity), it will be set to infinity.\n\n"});