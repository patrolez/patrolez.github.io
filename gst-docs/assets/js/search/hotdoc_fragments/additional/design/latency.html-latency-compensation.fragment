fragment_downloaded_cb({"url":"additional/design/latency.html#latency-compensation","fragment":"Latency compensation\nLatency calculation and compensation is performed before the pipeline\nproceeds to the PLAYING state.\nWhen the pipeline collected all ASYNC_DONE messages it can calculate\nthe global latency as follows:\nThe sinks gather this information with a LATENCY query upstream.\nIntermediate elements pass the query upstream and add the amount of\nlatency they add to the result.\nThe latency is set on the pipeline by sending a LATENCY event to the\nsinks in the pipeline. This event configures the total latency on the\nsinks. The sink forwards this LATENCY event upstream so that\nintermediate elements can configure themselves as well.\nAfter this step, the pipeline continues setting the pending state on its\nelements.\nA sink adds the latency value, received in the LATENCY event, to the\ntimes used for synchronizing against the clock. This will effectively\ndelay the rendering of the buffer with the required latency. Since this\ndelay is the same for all sinks, all sinks will render data relatively\nsynchronised.\n\nperform a latency query on all sinks\nsources set their minimum and maximum latency\nother elements add their own values as described above\nlatency = MAX (all min latencies)\n\nif MIN (all max latencies) < latency, we have an impossible\nsituation and we must generate an error indicating that this\npipeline cannot be played. This usually means that there is not\nenough buffering in some chain of the pipeline. A queue can be added\nto those chains.\n\n"});