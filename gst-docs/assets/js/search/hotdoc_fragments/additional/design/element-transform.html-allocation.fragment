fragment_downloaded_cb({"url":"additional/design/element-transform.html#allocation","fragment":"Allocation\nAfter the transform element is configured with caps, a bufferpool needs\nto be negotiated to perform the allocation of buffers. We have 2 cases:\nThe element is operating in passthrough we don’t need to allocate a\nbuffer in the transform element.\nThe element is not operating in passthrough and needs to allocation\nan output buffer.\nIn case 1, we don’t query and configure a pool. We let upstream decide\nif it wants to use a bufferpool and then we will proxy the bufferpool\nfrom downstream to upstream.\nIn case 2, we query and set a bufferpool on the srcpad that will be used\nfor doing the allocations.\nIn order to perform allocation, we need to be able to get the size of\nthe output buffer after the transform. We need additional function to\nretrieve the size. There are two functions:\ntransform_size(): Given a caps and a size on one pad, and a caps on the\nother pad, calculate the size of the other buffer. This function is able to\nperform all size transforms and is the preferred method of transforming\na size.\nget_unit_size(): When the input size and output size are always\na multiple of each other (audio conversion, ..) we can define a more simple\nget_unit_size() function. The transform will use this function to get the\nsame amount of units in the source and destination buffers. For performance\nreasons, the mapping between caps and size is kept in a cache.\n\n\nThe element is operating in passthrough we don’t need to allocate a\nbuffer in the transform element.\n\n\nThe element is not operating in passthrough and needs to allocation\nan output buffer.\n\n\n\n\ntransform_size(): Given a caps and a size on one pad, and a caps on the\nother pad, calculate the size of the other buffer. This function is able to\nperform all size transforms and is the preferred method of transforming\na size.\n\n\nget_unit_size(): When the input size and output size are always\na multiple of each other (audio conversion, ..) we can define a more simple\nget_unit_size() function. The transform will use this function to get the\nsame amount of units in the source and destination buffers. For performance\nreasons, the mapping between caps and size is kept in a cache.\n\n\n"});