fragment_downloaded_cb({"url":"additional/design/decodebin.html#parsers-decoders-and-autoplugging","fragment":"Parsers, decoders and auto-plugging\nThis section has DRAFT status.\nSome media formats come in different \"flavours\" or \"stream formats\".\nThese formats differ in the way the setup data and media data is\nsignalled and/or packaged. An example for this is H.264 video, where\nthere is a bytestream format (with codec setup data signalled inline and\nunits prefixed by a sync code and packet length information) and a \"raw\"\nformat where codec setup data is signalled out of band (via the caps)\nand the chunking is implicit in the way the buffers were muxed into a\ncontainer, to mention just two of the possible variants.\nEspecially on embedded platforms it is common that decoders can only\nhandle one particular stream format, and not all of them.\nWhere there are multiple stream formats, parsers are usually expected to\nbe able to convert between the different formats. This will, if\nimplemented correctly, work as expected in a static pipeline such as\nwhere the parser can query the decoder's capabilities even before\nprocessing the first piece of data, and configure itself to convert\naccordingly, if conversion is needed at all.\nIn an auto-plugging context this is not so straight-forward though,\nbecause elements are plugged incrementally and not before the previous\nelement has processed some data and decided what it will output exactly\n(unless the template caps are completely fixed, then it can continue\nright away, this is not always the case here though, see below). A\nparser will thus have to decide on some output format so auto-plugging\ncan continue. It doesn't know anything about the available decoders and\ntheir capabilities though, so it's possible that it will choose a format\nthat is not supported by any of the available decoders, or by the\npreferred decoder.\nIf the parser had sufficiently concise but fixed source pad template\ncaps, decodebin could continue to plug a decoder right away, allowing\nthe parser to configure itself in the same way as it would with a static\npipeline. This is not an option, unfortunately, because often the parser\nneeds to process some data to determine e.g. the format's profile or\nother stream properties (resolution, sample rate, channel configuration,\netc.), and there may be different decoders for different profiles (e.g.\nDSP codec for baseline profile, and software fallback for main/high\nprofile; or a DSP codec only supporting certain resolutions, with a\nsoftware fallback for unusual resolutions). So if decodebin just plugged\nthe most highest-ranking decoder, that decoder might not be be able to\nhandle the actual stream later on, which would yield an error (this is a\ndata flow error then which would be hard to intercept and avoid in\ndecodebin). In other words, we can't solve this issue by plugging a\ndecoder right away with the parser.\nSo decodebin needs to communicate to the parser the set of available\ndecoder caps (which would contain the relevant capabilities/restrictions\nsuch as supported profiles, resolutions, etc.), after the usual\n\"autoplug-*\" signal filtering/sorting of course.\nThis is done by plugging a capsfilter element right after the parser,\nand constructing set of filter caps from the list of available decoders\n(one appends at the end just the name(s) of the caps structures from the\nparser pad template caps to function as an 'ANY other' caps equivalent).\nThis let the parser negotiate to a supported stream format in the same\nway as with the static pipeline mentioned above, but of course incur\nsome overhead through the additional capsfilter element.\n"});