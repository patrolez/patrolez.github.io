fragment_downloaded_cb({"url":"playback/playbin.html#advanced-usage-specifying-the-audio-and-video-sink","fragment":"Advanced Usage: specifying the audio and video sink\nBy default, if no audio sink or video sink has been specified via the\naudio-sink or video-sink property, playbin will use the autoaudiosink\nand autovideosink elements to find the first-best available output method.\nThis should work in most cases, but is not always desirable. Often either\nthe user or application might want to specify more explicitly what to use\nfor audio and video output.\nIf the application wants more control over how audio or video should be\noutput, it may create the audio/video sink elements itself (for example\nusing gst_element_factory_make) and provide them to playbin using the\naudio-sink or video-sink property.\nGNOME-based applications, for example, will usually want to create\ngconfaudiosink and gconfvideosink elements and make playbin use those,\nso that output happens to whatever the user has configured in the GNOME\nMultimedia System Selector configuration dialog.\nThe sink elements do not necessarily need to be ready-made sinks. It is\npossible to create container elements that look like a sink to playbin,\nbut in reality contain a number of custom elements linked together. This\ncan be achieved by creating a GstBin and putting elements in there and\nlinking them, and then creating a sink GstGhostPad for the bin and pointing\nit to the sink pad of the first element within the bin. This can be used\nfor a number of purposes, for example to force output to a particular\nformat or to modify or observe the data before it is output.\nIt is also possible to 'suppress' audio and/or video output by using\n'fakesink' elements (or capture it from there using the fakesink element's\n\"handoff\" signal, which, nota bene, is fired from the streaming thread!).\n"});