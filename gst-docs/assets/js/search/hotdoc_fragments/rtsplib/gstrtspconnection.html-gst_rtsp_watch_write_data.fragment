fragment_downloaded_cb({"url":"rtsplib/gstrtspconnection.html#gst_rtsp_watch_write_data","fragment":"\n\tgst_rtsp_watch_write_data\n\n\n\tGstRtsp.RTSPWatch.prototype.write_data\n\n\n\tGstRtsp.RTSPWatch.write_data\n\nWrite data using the connection of the watch. If it cannot be sent\nimmediately, it will be queued for transmission in watch. The contents of\nmessage will then be serialized and transmitted when the connection of the\nwatch becomes writable. In case the message is queued, the ID returned in\nid will be non-zero and used as the ID argument in the message_sent\ncallback.\nThis function will take ownership of data and g_free it after use.\nIf the amount of queued data exceeds the limits set with\ngst_rtsp_watch_set_send_backlog, this function will return\nGST_RTSP_ENOMEM.\nParameters:\na GstRTSPWatch\nthe data to queue\nthe size of data\nlocation for a message ID or NULL\nGST_RTSP_OK on success. GST_RTSP_ENOMEM when the backlog limits\nare reached. GST_RTSP_EINTR when watch was flushing.\nWrite data using the connection of the watch. If it cannot be sent\nimmediately, it will be queued for transmission in watch. The contents of\nmessage will then be serialized and transmitted when the connection of the\nwatch becomes writable. In case the message is queued, the ID returned in\nid will be non-zero and used as the ID argument in the message_sent\ncallback.\nThis function will take ownership of data and GLib.prototype.free it after use.\nIf the amount of queued data exceeds the limits set with\nGstRtsp.RTSPWatch.prototype.set_send_backlog, this function will return\nGstRtsp.RTSPResult.ENOMEM.\nParameters:\na GstRtsp.RTSPWatch\nthe data to queue\nthe size of data\nReturns a tuple made of:\nGstRtsp.RTSPResult.OK on success. GstRtsp.RTSPResult.ENOMEM when the backlog limits\nare reached. GstRtsp.RTSPResult.EINTR when watch was flushing.\nGstRtsp.RTSPResult.OK on success. GstRtsp.RTSPResult.ENOMEM when the backlog limits\nare reached. GstRtsp.RTSPResult.EINTR when watch was flushing.\nWrite data using the connection of the watch. If it cannot be sent\nimmediately, it will be queued for transmission in watch. The contents of\nmessage will then be serialized and transmitted when the connection of the\nwatch becomes writable. In case the message is queued, the ID returned in\nid will be non-zero and used as the ID argument in the message_sent\ncallback.\nThis function will take ownership of data and GLib.free it after use.\nIf the amount of queued data exceeds the limits set with\nGstRtsp.RTSPWatch.set_send_backlog, this function will return\nGstRtsp.RTSPResult.ENOMEM.\nParameters:\na GstRtsp.RTSPWatch\nthe data to queue\nthe size of data\nReturns a tuple made of:\nGstRtsp.RTSPResult.OK on success. GstRtsp.RTSPResult.ENOMEM when the backlog limits\nare reached. GstRtsp.RTSPResult.EINTR when watch was flushing.\nGstRtsp.RTSPResult.OK on success. GstRtsp.RTSPResult.ENOMEM when the backlog limits\nare reached. GstRtsp.RTSPResult.EINTR when watch was flushing.\n"});