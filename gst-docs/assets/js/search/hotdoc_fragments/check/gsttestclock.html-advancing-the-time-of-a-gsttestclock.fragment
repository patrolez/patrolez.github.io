fragment_downloaded_cb({"url":"check/gsttestclock.html#advancing-the-time-of-a-gsttestclock","fragment":"Advancing the time of a GstTestClock\n\nGstClock allows for setting up single shot or periodic clock notifications\nas well as waiting for these notifications synchronously (using\ngst_clock_id_wait) or asynchronously (using gst_clock_id_wait_async or\ngst_clock_id_wait_async). This is used by many GStreamer elements,\namong them GstBaseSrc and GstBaseSink.\nGstTestClock keeps track of these clock notifications. By calling\ngst_test_clock_wait_for_next_pending_id or\ngst_test_clock_wait_for_multiple_pending_ids a unit tests may wait for the\nnext one or several clock notifications to be requested. Additionally unit\ntests may release blocked waits in a controlled fashion by calling\ngst_test_clock_process_next_clock_id. This way a unit test can control the\ninaccuracy (jitter) of clock notifications, since the test can decide to\nrelease blocked waits when the clock time has advanced exactly to, or past,\nthe requested clock notification time.\nThere are also interfaces for determining if a notification belongs to a\nGstTestClock or not, as well as getting the number of requested clock\nnotifications so far.\nN.B.: When a unit test waits for a certain amount of clock notifications to\nbe requested in gst_test_clock_wait_for_next_pending_id or\ngst_test_clock_wait_for_multiple_pending_ids then these functions may block\nfor a long time. If they block forever then the expected clock notifications\nwere never requested from GstTestClock, and so the assumptions in the code\nof the unit test are wrong. The unit test case runner in gstcheck is\nexpected to catch these cases either by the default test case timeout or the\none set for the unit test by calling tcase_set_timeout().\nThe sample code below assumes that the element under test will delay a\nbuffer pushed on the source pad by some latency until it arrives on the sink\npad. Moreover it is assumed that the element will at some point call\ngst_clock_id_wait to synchronously wait for a specific time. The first\nbuffer sent will arrive exactly on time only delayed by the latency. The\nsecond buffer will arrive a little late (7ms) due to simulated jitter in the\nclock notification.\n"});