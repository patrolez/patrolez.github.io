fragment_downloaded_cb({"url":"coreelements/multiqueue.html#multiqueue-page","fragment":"multiqueue\nMultiqueue is similar to a normal queue with the following additional\nfeatures:\nData is queued until one of the limits specified by the\nmax-size-buffers, max-size-bytes and/or\nmax-size-time properties has been reached. Any attempt to push\nmore buffers into the queue will block the pushing thread until more space\nbecomes available. extra-size-buffers,\nextra-size-bytes and extra-size-time are\ncurrently unused.\nThe default queue size limits are 5 buffers, 10MB of data, or\ntwo second worth of data, whichever is reached first. Note that the number\nof buffers will dynamically grow depending on the fill level of\nother queues.\nThe underrun signal is emitted when all of the queues\nare empty. The overrun signal is emitted when one of the\nqueues is filled.\nBoth signals are emitted from the context of the streaming thread.\nWhen using sync-by-running-time the unlinked streams will\nbe throttled by the highest running-time of linked streams. This allows\nfurther relinking of those unlinked streams without them being in the\nfuture (i.e. to achieve gapless playback).\nWhen dealing with streams which have got different consumption requirements\ndownstream (ex: video decoders which will consume more buffer (in time) than\naudio decoders), it is recommended to group streams of the same type\nby using the pad \"group-id\" property. This will further throttle streams\nin time within that group.\n\nThe element handles queueing data on more than one stream at once. To\nachieve such a feature it has request sink pads (sink%u) and\n'sometimes' src pads (src%u). When requesting a given sinkpad with gst_element_request_pad,\nthe associated srcpad for that stream will be created.\nExample: requesting sink1 will generate src1.\n\n\nIf more than one stream is used with the element, the streams' queues\nwill be dynamically grown (up to a limit), in order to ensure that no\nstream is risking data starvation. This guarantees that at any given\ntime there are at least N bytes queued and available for each individual\nstream. If an EOS event comes through a srcpad, the associated queue will be\nconsidered as 'not-empty' in the queue-size-growing algorithm.\n\n\nIn order to better support dynamic switching between streams, the multiqueue\n(unlike the current GStreamer queue) continues to push buffers on non-linked\npads rather than shutting down. In addition, to prevent a non-linked stream from very quickly consuming all\navailable buffers and thus 'racing ahead' of the other streams, the element\nmust ensure that buffers and inlined events for a non-linked stream are pushed\nin the same order as they were received, relative to the other streams\ncontrolled by the element. This means that a buffer cannot be pushed to a\nnon-linked pad any sooner than buffers in any other stream which were received\nbefore it.\n\n"});