fragment_downloaded_cb({"url":"pbutils/gstpbutilsinstallplugins.html#overview","fragment":"Overview\nUsing this API, applications can request the installation of missing\nGStreamer plugins. These may be missing decoders/demuxers or\nencoders/muxers for a certain format, sources or sinks for a certain URI\nprotocol (e.g. 'http'), or certain elements known by their element\nfactory name ('audioresample').\nWhether plugin installation is supported or not depends on the operating\nsystem and/or distribution in question. The vendor of the operating\nsystem needs to make sure the necessary hooks and mechanisms are in\nplace for plugin installation to work. See below for more detailed\ninformation.\nFrom the application perspective, plugin installation is usually\ntriggered either\nThe install functions in this section all take one or more 'detail\nstrings'. These detail strings contain information about the type of\nplugin that needs to be installed (decoder, encoder, source, sink, or\nnamed element), and some additional information such GStreamer version\nused and a human-readable description of the component to install for\nuser dialogs.\nApplications should not concern themselves with the composition of the\nstring itself. They should regard the string as if it was a shared\nsecret between GStreamer and the plugin installer application.\nDetail strings can be obtained using the function\ngst_missing_plugin_message_get_installer_detail on a\nmissing-plugin message. Such a message will either have been found by\nthe application on a pipeline's GstBus, or the application will have\ncreated it itself using gst_missing_element_message_new,\ngst_missing_decoder_message_new,\ngst_missing_encoder_message_new,\ngst_missing_uri_sink_message_new, or\ngst_missing_uri_source_message_new.\nFor each GStreamer element/plugin/component that should be installed,\nthe application needs one of those 'installer detail' string mentioned\nin the previous section. This string can be obtained, as already\nmentioned above, from a missing-plugin message using the function\ngst_missing_plugin_message_get_installer_detail. The\nmissing-plugin message is either posted by another element and then\nfound on the bus by the application, or the application has created it\nitself as described above.\nThe application will then call gst_install_plugins_async, passing a\nNULL-terminated array of installer detail strings, and a function that\nshould be called when the installation of the plugins has finished\n(successfully or not). Optionally, a GstInstallPluginsContext created\nwith gst_install_plugins_context_new may be passed as well. This\nway additional optional arguments like the application window's XID can\nbe passed to the external installer application.\ngst_install_plugins_async will return almost immediately, with the\nreturn code indicating whether plugin installation was started or not.\nIf the necessary hooks for plugin installation are in place and an\nexternal installer application has in fact been called, the passed in\nfunction will be called with a result code as soon as the external\ninstaller has finished. If the result code indicates that new plugins\nhave been installed, the application will want to call\ngst_update_registry so the run-time plugin registry is updated and\nthe new plugins are made available to the application.\nA Gtk/GLib main loop must be running in order for the result function\nto be called when the external installer has finished. If this is not\nthe case, make sure to regularly call in your code:\ng_main_context_iteration (NULL,FALSE);\n\nwhen the application itself has found that it wants or needs to\ninstall a certain element\nwhen the application has been notified by an element (such as\nplaybin or decodebin) that one or more plugins are missing and the\napplication has decided that it wants to install one or more of\nthose missing plugins\n\n"});